# 1 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp"
# 1 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 1





# 1 "C:/upp/uppsrc/Core/Core.h" 1
# 203 "C:/upp/uppsrc/Core/Core.h"
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/typeinfo" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/typeinfo" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception" 1 3
# 40 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception" 3
extern "C++" {

namespace std
{
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 100 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 115 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception" 3
  void __verbose_terminate_handler ();
}

}
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/typeinfo" 2 3

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 106 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

}
# 204 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/math.h" 1
# 16 "C:/upp/mingw/include/math.h"
       
# 17 "C:/upp/mingw/include/math.h" 3



# 1 "C:/upp/mingw/include/_mingw.h" 1 3
# 27 "C:/upp/mingw/include/_mingw.h" 3
       
# 28 "C:/upp/mingw/include/_mingw.h" 3
# 21 "C:/upp/mingw/include/math.h" 2 3
# 90 "C:/upp/mingw/include/math.h" 3
extern "C" {
# 134 "C:/upp/mingw/include/math.h" 3
struct _exception
{
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};

 double __attribute__((__cdecl__)) sin (double);
 double __attribute__((__cdecl__)) cos (double);
 double __attribute__((__cdecl__)) tan (double);
 double __attribute__((__cdecl__)) sinh (double);
 double __attribute__((__cdecl__)) cosh (double);
 double __attribute__((__cdecl__)) tanh (double);
 double __attribute__((__cdecl__)) asin (double);
 double __attribute__((__cdecl__)) acos (double);
 double __attribute__((__cdecl__)) atan (double);
 double __attribute__((__cdecl__)) atan2 (double, double);
 double __attribute__((__cdecl__)) exp (double);
 double __attribute__((__cdecl__)) log (double);
 double __attribute__((__cdecl__)) log10 (double);
 double __attribute__((__cdecl__)) pow (double, double);
 double __attribute__((__cdecl__)) sqrt (double);
 double __attribute__((__cdecl__)) ceil (double);
 double __attribute__((__cdecl__)) floor (double);
 double __attribute__((__cdecl__)) fabs (double);
 double __attribute__((__cdecl__)) ldexp (double, int);
 double __attribute__((__cdecl__)) frexp (double, int*);
 double __attribute__((__cdecl__)) modf (double, double*);
 double __attribute__((__cdecl__)) fmod (double, double);
# 210 "C:/upp/mingw/include/math.h" 3
struct _complex
{
 double x;
 double y;
};

 double __attribute__((__cdecl__)) _cabs (struct _complex);

 double __attribute__((__cdecl__)) _hypot (double, double);
 double __attribute__((__cdecl__)) _j0 (double);
 double __attribute__((__cdecl__)) _j1 (double);
 double __attribute__((__cdecl__)) _jn (int, double);
 double __attribute__((__cdecl__)) _y0 (double);
 double __attribute__((__cdecl__)) _y1 (double);
 double __attribute__((__cdecl__)) _yn (int, double);
 int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 234 "C:/upp/mingw/include/math.h" 3
 double __attribute__((__cdecl__)) _chgsign (double);
 double __attribute__((__cdecl__)) _copysign (double, double);
 double __attribute__((__cdecl__)) _logb (double);
 double __attribute__((__cdecl__)) _nextafter (double, double);
 double __attribute__((__cdecl__)) _scalb (double, long);

 int __attribute__((__cdecl__)) _finite (double);
 int __attribute__((__cdecl__)) _fpclass (double);
 int __attribute__((__cdecl__)) _isnan (double);
# 254 "C:/upp/mingw/include/math.h" 3
 double __attribute__((__cdecl__)) j0 (double);
 double __attribute__((__cdecl__)) j1 (double);
 double __attribute__((__cdecl__)) jn (int, double);
 double __attribute__((__cdecl__)) y0 (double);
 double __attribute__((__cdecl__)) y1 (double);
 double __attribute__((__cdecl__)) yn (int, double);

 double __attribute__((__cdecl__)) chgsign (double);
 double __attribute__((__cdecl__)) scalb (double, long);
 int __attribute__((__cdecl__)) finite (double);
 int __attribute__((__cdecl__)) fpclass (double);
# 329 "C:/upp/mingw/include/math.h" 3
extern int __attribute__((__cdecl__)) __fpclassifyf (float);
extern int __attribute__((__cdecl__)) __fpclassify (double);

inline int __attribute__((__cdecl__)) __fpclassifyl (long double x){
  unsigned short sw;
  __asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (x));
  return sw & (0x0100 | 0x0400 | 0x4000 );
}
# 352 "C:/upp/mingw/include/math.h" 3
inline int __attribute__((__cdecl__)) __isnan (double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}

inline int __attribute__((__cdecl__)) __isnanf (float _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}

inline int __attribute__((__cdecl__)) __isnanl (long double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}
# 388 "C:/upp/mingw/include/math.h" 3
inline int __attribute__((__cdecl__)) __signbit (double x) {
  unsigned short stw;
  __asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

inline int __attribute__((__cdecl__)) __signbitf (float x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

inline int __attribute__((__cdecl__)) __signbitl (long double x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}






extern float __attribute__((__cdecl__)) sinf (float);
extern long double __attribute__((__cdecl__)) sinl (long double);

extern float __attribute__((__cdecl__)) cosf (float);
extern long double __attribute__((__cdecl__)) cosl (long double);

extern float __attribute__((__cdecl__)) tanf (float);
extern long double __attribute__((__cdecl__)) tanl (long double);

extern float __attribute__((__cdecl__)) asinf (float);
extern long double __attribute__((__cdecl__)) asinl (long double);

extern float __attribute__((__cdecl__)) acosf (float);
extern long double __attribute__((__cdecl__)) acosl (long double);

extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanl (long double);

extern float __attribute__((__cdecl__)) atan2f (float, float);
extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


inline float __attribute__((__cdecl__)) sinhf (float x)
  {return (float) sinh (x);}
extern long double __attribute__((__cdecl__)) sinhl (long double);

inline float __attribute__((__cdecl__)) coshf (float x)
  {return (float) cosh (x);}
extern long double __attribute__((__cdecl__)) coshl (long double);

inline float __attribute__((__cdecl__)) tanhf (float x)
  {return (float) tanh (x);}
extern long double __attribute__((__cdecl__)) tanhl (long double);



extern double __attribute__((__cdecl__)) acosh (double);
extern float __attribute__((__cdecl__)) acoshf (float);
extern long double __attribute__((__cdecl__)) acoshl (long double);


extern double __attribute__((__cdecl__)) asinh (double);
extern float __attribute__((__cdecl__)) asinhf (float);
extern long double __attribute__((__cdecl__)) asinhl (long double);


extern double __attribute__((__cdecl__)) atanh (double);
extern float __attribute__((__cdecl__)) atanhf (float);
extern long double __attribute__((__cdecl__)) atanhl (long double);



inline float __attribute__((__cdecl__)) expf (float x)
  {return (float) exp (x);}
extern long double __attribute__((__cdecl__)) expl (long double);


extern double __attribute__((__cdecl__)) exp2(double);
extern float __attribute__((__cdecl__)) exp2f(float);
extern long double __attribute__((__cdecl__)) exp2l(long double);



extern double __attribute__((__cdecl__)) expm1(double);
extern float __attribute__((__cdecl__)) expm1f(float);
extern long double __attribute__((__cdecl__)) expm1l(long double);


inline float __attribute__((__cdecl__)) frexpf (float x, int* expn)
  {return (float) frexp (x, expn);}
extern long double __attribute__((__cdecl__)) frexpl (long double, int*);




extern int __attribute__((__cdecl__)) ilogb (double);
extern int __attribute__((__cdecl__)) ilogbf (float);
extern int __attribute__((__cdecl__)) ilogbl (long double);


inline float __attribute__((__cdecl__)) ldexpf (float x, int expn)
  {return (float) ldexp (x, expn);}
extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


extern float __attribute__((__cdecl__)) logf (float);
extern long double __attribute__((__cdecl__)) logl (long double);


extern float __attribute__((__cdecl__)) log10f (float);
extern long double __attribute__((__cdecl__)) log10l (long double);


extern double __attribute__((__cdecl__)) log1p(double);
extern float __attribute__((__cdecl__)) log1pf(float);
extern long double __attribute__((__cdecl__)) log1pl(long double);


extern double __attribute__((__cdecl__)) log2 (double);
extern float __attribute__((__cdecl__)) log2f (float);
extern long double __attribute__((__cdecl__)) log2l (long double);


extern double __attribute__((__cdecl__)) logb (double);
extern float __attribute__((__cdecl__)) logbf (float);
extern long double __attribute__((__cdecl__)) logbl (long double);




inline double __attribute__((__cdecl__)) logb (double x)
{
  double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

inline float __attribute__((__cdecl__)) logbf (float x)
{
  float res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

inline long double __attribute__((__cdecl__)) logbl (long double x)
{
  long double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}



extern float __attribute__((__cdecl__)) modff (float, float*);
extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


extern double __attribute__((__cdecl__)) scalbn (double, int);
extern float __attribute__((__cdecl__)) scalbnf (float, int);
extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

extern double __attribute__((__cdecl__)) scalbln (double, long);
extern float __attribute__((__cdecl__)) scalblnf (float, long);
extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



extern double __attribute__((__cdecl__)) cbrt (double);
extern float __attribute__((__cdecl__)) cbrtf (float);
extern long double __attribute__((__cdecl__)) cbrtl (long double);


extern float __attribute__((__cdecl__)) fabsf (float x);
extern long double __attribute__((__cdecl__)) fabsl (long double x);


extern double __attribute__((__cdecl__)) hypot (double, double);
inline float __attribute__((__cdecl__)) hypotf (float x, float y)
  { return (float) hypot (x, y);}
extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


inline float __attribute__((__cdecl__)) powf (float x, float y)
  {return (float) pow (x, y);}
extern long double __attribute__((__cdecl__)) powl (long double, long double);


extern float __attribute__((__cdecl__)) sqrtf (float);
extern long double __attribute__((__cdecl__)) sqrtl (long double);


extern double __attribute__((__cdecl__)) erf (double);
extern float __attribute__((__cdecl__)) erff (float);
extern long double __attribute__((__cdecl__)) erfl (long double);


extern double __attribute__((__cdecl__)) erfc (double);
extern float __attribute__((__cdecl__)) erfcf (float);
extern long double __attribute__((__cdecl__)) erfcl (long double);


extern double __attribute__((__cdecl__)) lgamma (double);
extern float __attribute__((__cdecl__)) lgammaf (float);
extern long double __attribute__((__cdecl__)) lgammal (long double);


extern double __attribute__((__cdecl__)) tgamma (double);
extern float __attribute__((__cdecl__)) tgammaf (float);
extern long double __attribute__((__cdecl__)) tgammal (long double);


extern float __attribute__((__cdecl__)) ceilf (float);
extern long double __attribute__((__cdecl__)) ceill (long double);


extern float __attribute__((__cdecl__)) floorf (float);
extern long double __attribute__((__cdecl__)) floorl (long double);


extern double __attribute__((__cdecl__)) nearbyint ( double);
extern float __attribute__((__cdecl__)) nearbyintf (float);
extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

extern long long __attribute__((__cdecl__)) llrint (double);
extern long long __attribute__((__cdecl__)) llrintf (float);
extern long long __attribute__((__cdecl__)) llrintl (long double);




inline double __attribute__((__cdecl__)) rint (double x)
{
  double retval;
  __asm__ ("frndint;": "=t" (retval) : "0" (x));
  return retval;
}

inline float __attribute__((__cdecl__)) rintf (float x)
{
  float retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

inline long double __attribute__((__cdecl__)) rintl (long double x)
{
  long double retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

inline long __attribute__((__cdecl__)) lrint (double x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long __attribute__((__cdecl__)) lrintf (float x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long __attribute__((__cdecl__)) lrintl (long double x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrint (double x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrintf (float x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrintl (long double x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}




extern double __attribute__((__cdecl__)) round (double);
extern float __attribute__((__cdecl__)) roundf (float);
extern long double __attribute__((__cdecl__)) roundl (long double);


extern long __attribute__((__cdecl__)) lround (double);
extern long __attribute__((__cdecl__)) lroundf (float);
extern long __attribute__((__cdecl__)) lroundl (long double);

extern long long __attribute__((__cdecl__)) llround (double);
extern long long __attribute__((__cdecl__)) llroundf (float);
extern long long __attribute__((__cdecl__)) llroundl (long double);



extern double __attribute__((__cdecl__)) trunc (double);
extern float __attribute__((__cdecl__)) truncf (float);
extern long double __attribute__((__cdecl__)) truncl (long double);


extern float __attribute__((__cdecl__)) fmodf (float, float);
extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


extern double __attribute__((__cdecl__)) remainder (double, double);
extern float __attribute__((__cdecl__)) remainderf (float, float);
extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


extern double __attribute__((__cdecl__)) remquo(double, double, int *);
extern float __attribute__((__cdecl__)) remquof(float, float, int *);
extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


extern double __attribute__((__cdecl__)) copysign (double, double);
extern float __attribute__((__cdecl__)) copysignf (float, float);
extern long double __attribute__((__cdecl__)) copysignl (long double, long double);


extern double __attribute__((__cdecl__)) nan(const char *tagp);
extern float __attribute__((__cdecl__)) nanf(const char *tagp);
extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 757 "C:/upp/mingw/include/math.h" 3
extern double __attribute__((__cdecl__)) nextafter (double, double);
extern float __attribute__((__cdecl__)) nextafterf (float, float);
extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


extern double __attribute__((__cdecl__)) nexttoward (double, long double);
extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



extern double __attribute__((__cdecl__)) fdim (double x, double y);
extern float __attribute__((__cdecl__)) fdimf (float x, float y);
extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







extern double __attribute__((__cdecl__)) fmax (double, double);
extern float __attribute__((__cdecl__)) fmaxf (float, float);
extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


extern double __attribute__((__cdecl__)) fmin (double, double);
extern float __attribute__((__cdecl__)) fminf (float, float);
extern long double __attribute__((__cdecl__)) fminl (long double, long double);



extern double __attribute__((__cdecl__)) fma (double, double, double);
extern float __attribute__((__cdecl__)) fmaf (float, float, float);
extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 843 "C:/upp/mingw/include/math.h" 3
}
# 205 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/limits.h" 1
# 206 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/stdlib.h" 1
# 21 "C:/upp/mingw/include/stdlib.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 213 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 3 4
typedef unsigned int size_t;
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 22 "C:/upp/mingw/include/stdlib.h" 2
# 60 "C:/upp/mingw/include/stdlib.h"
extern "C" {
# 71 "C:/upp/mingw/include/stdlib.h"
extern int _argc;
extern char** _argv;




extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argc(void);
extern char*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argv(void);
extern wchar_t*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___wargv(void);
# 112 "C:/upp/mingw/include/stdlib.h"
   extern __attribute__ ((__dllimport__)) int __mb_cur_max;
# 137 "C:/upp/mingw/include/stdlib.h"
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);


 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __doserrno(void);
# 149 "C:/upp/mingw/include/stdlib.h"
  extern char *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__environ(void);
  extern wchar_t *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wenviron(void);
# 172 "C:/upp/mingw/include/stdlib.h"
  extern __attribute__ ((__dllimport__)) int _sys_nerr;
# 196 "C:/upp/mingw/include/stdlib.h"
extern __attribute__ ((__dllimport__)) char* _sys_errlist[];
# 209 "C:/upp/mingw/include/stdlib.h"
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__osver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winmajor(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winminor(void);







extern __attribute__ ((__dllimport__)) unsigned int _osver;
extern __attribute__ ((__dllimport__)) unsigned int _winver;
extern __attribute__ ((__dllimport__)) unsigned int _winmajor;
extern __attribute__ ((__dllimport__)) unsigned int _winminor;
# 260 "C:/upp/mingw/include/stdlib.h"
 char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__pgmptr(void);

 wchar_t** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wpgmptr(void);
# 293 "C:/upp/mingw/include/stdlib.h"
extern __attribute__ ((__dllimport__)) int _fmode;
# 303 "C:/upp/mingw/include/stdlib.h"
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atof (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoi (const char*);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atol (const char*);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi (const wchar_t *);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtol (const wchar_t *);

 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod (const char*, char**);

float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof (const char * __restrict__, char ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold (const char * __restrict__, char ** __restrict__);


 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtol (const char*, char**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoul (const char*, char**, int);



 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstol (const wchar_t*, wchar_t**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoul (const wchar_t*, wchar_t**, int);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstod (const wchar_t*, wchar_t**);

float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstof( const wchar_t * __restrict__, wchar_t ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);


 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetenv(const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wputenv(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsystem(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfullpath (wchar_t*, const wchar_t*, size_t);




 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstombs (char*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctomb (char*, wchar_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mblen (const char*, size_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbstowcs (wchar_t*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbtowc (wchar_t*, const char*, size_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rand (void);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) srand (unsigned int);

 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) calloc (size_t, size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) malloc (size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) realloc (void*, size_t);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) free (void*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abort (void) __attribute__ ((__noreturn__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit (int) __attribute__ ((__noreturn__));


int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atexit (void (*)(void));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) system (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getenv (const char*);


 void* __attribute__((__cdecl__)) bsearch (const void*, const void*, size_t, size_t,
          int (*)(const void*, const void*));
 void __attribute__((__cdecl__)) qsort(void*, size_t, size_t,
      int (*)(const void*, const void*));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abs (int) __attribute__ ((__const__));
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) labs (long) __attribute__ ((__const__));
# 380 "C:/upp/mingw/include/stdlib.h"
typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;

 div_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) div (int, int) __attribute__ ((__const__));
 ldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ldiv (long, long) __attribute__ ((__const__));







 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _beep (unsigned int, unsigned int) __attribute__ ((__deprecated__));

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _seterrormode (int) __attribute__ ((__deprecated__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _sleep (unsigned long) __attribute__ ((__deprecated__));

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit (int) __attribute__ ((__noreturn__));



typedef int (* _onexit_t)(void);
_onexit_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _onexit( _onexit_t );

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _searchenv (const char*, const char*, char*);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _gcvt (double, int, char*);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _makepath (char*, const char*, const char*, const char*, const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _splitpath (const char*, char*, char*, char*, char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fullpath (char*, const char*, size_t);

 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltoa (long, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultoa(unsigned long, char*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itow (int, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltow (long, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultow (unsigned long, wchar_t*, int);


 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _atoi64(const char *);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64toa(long long, char *, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64toa(unsigned long long, char *, int);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi64(const wchar_t *);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64tow(long long, wchar_t *, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64tow(unsigned long long, wchar_t *, int);


 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rotl(unsigned int, int) __attribute__ ((__const__));
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rotr(unsigned int, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lrotl(unsigned long, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lrotr(unsigned long, int) __attribute__ ((__const__));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _set_error_mode (int);
# 468 "C:/upp/mingw/include/stdlib.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) searchenv (const char*, const char*, char*);

 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ltoa (long, char*, int);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gcvt (double, int, char*);
# 488 "C:/upp/mingw/include/stdlib.h"
void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _Exit(int) __attribute__ ((__noreturn__));

inline void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _Exit(int __status)
 { _exit (__status); }


typedef struct { long long quot, rem; } lldiv_t;

lldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lldiv (long long, long long) __attribute__ ((__const__));

long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) llabs(long long);
inline long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) llabs(long long _j)
  {return (_j >= 0 ? _j : -_j);}

long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoll (const char* __restrict__, char** __restrict, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoull (const char* __restrict__, char** __restrict__, int);


long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoll (const char *);


long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wtoll (const wchar_t *);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltoa (long long, char *, int);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltoa (unsigned long long , char *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltow (long long, wchar_t *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltow (unsigned long long, wchar_t *, int);


inline long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoll (const char * _c)
 { return _atoi64 (_c); }
inline char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltoa (long long _n, char * _c, int _i)
 { return _i64toa (_n, _c, _i); }
inline char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltoa (unsigned long long _n, char * _c, int _i)
 { return _ui64toa (_n, _c, _i); }
inline long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wtoll (const wchar_t * _w)
  { return _wtoi64 (_w); }
inline wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltow (long long _n, wchar_t * _w, int _i)
 { return _i64tow (_n, _w, _i); }
inline wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltow (unsigned long long _n, wchar_t * _w, int _i)
 { return _ui64tow (_n, _w, _i); }
# 536 "C:/upp/mingw/include/stdlib.h"
}
# 207 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/stdio.h" 1
# 26 "C:/upp/mingw/include/stdio.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 354 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 3 4
typedef short unsigned int wint_t;
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 27 "C:/upp/mingw/include/stdio.h" 2

# 1 "C:/upp/mingw/include/stdarg.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stdarg.h" 1 3 4
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 2 3
# 7 "C:/upp/mingw/include/stdarg.h" 2
# 29 "C:/upp/mingw/include/stdio.h" 2
# 129 "C:/upp/mingw/include/stdio.h"
typedef struct _iobuf
{
 char* _ptr;
 int _cnt;
 char* _base;
 int _flag;
 int _file;
 int _charbuf;
 int _bufsiz;
 char* _tmpfname;
} FILE;
# 154 "C:/upp/mingw/include/stdio.h"
extern __attribute__ ((__dllimport__)) FILE _iob[];
# 163 "C:/upp/mingw/include/stdio.h"
extern "C" {





 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) freopen (const char*, const char*, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fflush (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fclose (FILE*);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) remove (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rename (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpfile (void);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpnam (char*);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _unlink (const char*);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) unlink (const char*);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setvbuf (FILE*, char*, int, size_t);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setbuf (FILE*, char*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fprintf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) printf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sprintf (char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snprintf (char*, size_t, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfprintf (FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vprintf (const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsprintf (char*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnprintf (char*, size_t, const char*, __gnuc_va_list);
# 216 "C:/upp/mingw/include/stdio.h"
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snprintf(char *, size_t, const char *, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnprintf (char *, size_t, const char *, __gnuc_va_list);

int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vscanf (const char * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfscanf (FILE * __restrict__, const char * __restrict__,
       __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsscanf (const char * __restrict__,
       const char * __restrict__, __gnuc_va_list);







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fscanf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) scanf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sscanf (const char*, const char*, ...);




 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetc (FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgets (char*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputc (int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputs (const char*, FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gets (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) puts (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetc (int, FILE*);







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filbuf (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flsbuf (int, FILE*);
# 286 "C:/upp/mingw/include/stdio.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getc (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putc (int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putchar (int);







 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fread (void*, size_t, size_t, FILE*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwrite (const void*, size_t, size_t, FILE*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseek (FILE*, long, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftell (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rewind (FILE*);
# 340 "C:/upp/mingw/include/stdio.h"
typedef long long fpos_t;




 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetpos (FILE*, fpos_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fsetpos (FILE*, const fpos_t*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE*);


inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE* __F)
  { return __F->_flag & 0x0010; }
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE* __F)
  { return __F->_flag & 0x0020; }





 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clearerr (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) perror (const char*);






 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _pclose (FILE*);


 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) pclose (FILE*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flushall (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fileno (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcloseall(void);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fsopen(const char*, const char*, int);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getmaxstdio(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _setmaxstdio(int);
# 402 "C:/upp/mingw/include/stdio.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fileno (FILE*);
# 414 "C:/upp/mingw/include/stdio.h"
# 1 "C:/upp/mingw/include/sys/types.h" 1
# 21 "C:/upp/mingw/include/sys/types.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 151 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 22 "C:/upp/mingw/include/sys/types.h" 2





typedef long time_t;




typedef long long __time64_t;





typedef long _off_t;


typedef _off_t off_t;







typedef unsigned int _dev_t;





typedef _dev_t dev_t;






typedef short _ino_t;


typedef _ino_t ino_t;






typedef int _pid_t;


typedef _pid_t pid_t;






typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef int _sigset_t;


typedef _sigset_t sigset_t;





typedef long _ssize_t;


typedef _ssize_t ssize_t;





typedef long long fpos64_t;




typedef long long off64_t;
# 415 "C:/upp/mingw/include/stdio.h" 2
inline FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen64 (const char* filename, const char* mode)
{
  return fopen (filename, mode);
}

int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseeko64 (FILE*, off64_t, int);






inline off64_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftello64 (FILE * stream)
{
  fpos_t pos;
  if (fgetpos(stream, &pos))
    return -1LL;
  else
   return ((off64_t) pos);
}
# 443 "C:/upp/mingw/include/stdio.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwprintf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wprintf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swprintf (wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snwprintf (wchar_t*, size_t, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwprintf (FILE*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswprintf (wchar_t*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnwprintf (wchar_t*, size_t, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwscanf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wscanf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swscanf (const wchar_t*, const wchar_t*, ...);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwc (wchar_t, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetwc (wchar_t, FILE*);


 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetws (wchar_t*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputws (const wchar_t*, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwchar (void);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getws (wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwc (wint_t, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putws (const wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwchar (wint_t);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfdopen(int, wchar_t *);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfopen (const wchar_t*, const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfreopen (const wchar_t*, const wchar_t*, FILE*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfsopen (const wchar_t*, const wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtmpnam (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtempnam (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrename (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wremove (const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wperror (const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wpopen (const wchar_t*, const wchar_t*);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snwprintf (wchar_t* s, size_t n, const wchar_t* format, ...);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
vsnwprintf (wchar_t* s, size_t n, const wchar_t* format, __gnuc_va_list arg)
  { return _vsnwprintf ( s, n, format, arg);}
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwscanf (const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwscanf (FILE * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswscanf (const wchar_t * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
# 497 "C:/upp/mingw/include/stdio.h"
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wpopen (const wchar_t*, const wchar_t*);






 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putw (int, FILE*);


 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putw (int, FILE*);





}
# 208 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/string.h" 1
# 24 "C:/upp/mingw/include/string.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 25 "C:/upp/mingw/include/string.h" 2





extern "C" {





 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memchr (const void*, int, size_t) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcmp (const void*, const void*, size_t) __attribute__ ((__pure__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcpy (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memmove (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memset (void*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcat (char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strchr (const char*, int) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmp (const char*, const char*) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcpy (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strerror (int);

 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlen (const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncat (char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncmp (const char*, const char*, size_t) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncpy (char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strpbrk (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrchr (const char*, int) __attribute__ ((__pure__));
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strstr (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtok (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strxfrm (char*, const char*, size_t);





 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strerror (const char *);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricmp (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicmp (const char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strupr (char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _swab (const char*, char*, size_t);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strncoll(const char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicoll(const char*, const char*, size_t);
# 90 "C:/upp/mingw/include/string.h"
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricmp (const char*, const char*);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcasecmp (const char*, const char *);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
strcasecmp (const char * __sz1, const char * __sz2)
  {return _stricmp (__sz1, __sz2);}
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnicmp (const char*, const char*, size_t);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncasecmp (const char *, const char *, size_t);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
strncasecmp (const char * __sz1, const char * __sz2, size_t __sizeMaxCompare)
  {return _strnicmp (__sz1, __sz2, __sizeMaxCompare);}
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strupr (char*);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swab (const char*, char*, size_t);
# 122 "C:/upp/mingw/include/string.h"
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscat (wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcschr (const wchar_t*, wchar_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscpy (wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscspn (const wchar_t*, const wchar_t*);

 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslen (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncat (wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncmp(const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncpy(wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcspbrk(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrchr(const wchar_t*, wchar_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsspn(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsstr(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstok(wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsxfrm(wchar_t*, const wchar_t*, size_t);
# 148 "C:/upp/mingw/include/string.h"
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsupr (wchar_t*);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsncoll(const wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicoll(const wchar_t*, const wchar_t*, size_t);
# 169 "C:/upp/mingw/include/string.h"
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2);
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2)
  {return _wcsicmp (__ws1, __ws2);}
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsupr (wchar_t*);
# 190 "C:/upp/mingw/include/string.h"
}
# 209 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/stdarg.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stdarg.h" 1 3 4
# 106 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 2 3
# 7 "C:/upp/mingw/include/stdarg.h" 2
# 210 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/mingw/include/ctype.h" 1
# 20 "C:/upp/mingw/include/ctype.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 21 "C:/upp/mingw/include/ctype.h" 2
# 45 "C:/upp/mingw/include/ctype.h"
extern "C" {


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalnum(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalpha(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscntrl(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isdigit(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isgraph(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) islower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isprint(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ispunct(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isspace(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isupper(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isxdigit(int);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isblank (int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _isctype (int, int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toupper(int);
# 83 "C:/upp/mingw/include/ctype.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _toupper(int);
# 112 "C:/upp/mingw/include/ctype.h"
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];


  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
# 154 "C:/upp/mingw/include/ctype.h"
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalnum(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0103|0x0004)) : _isctype(c, (0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalpha(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0103) : _isctype(c, 0x0103));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscntrl(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0020) : _isctype(c, 0x0020));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isdigit(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0004) : _isctype(c, 0x0004));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isgraph(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0010|0x0103|0x0004)) : _isctype(c, (0x0010|0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) islower(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0002) : _isctype(c, 0x0002));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isprint(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0040|0x0010|0x0103|0x0004)) : _isctype(c, (0x0040|0x0010|0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ispunct(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0010) : _isctype(c, 0x0010));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isspace(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0008) : _isctype(c, 0x0008));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isupper(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0001) : _isctype(c, 0x0001));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isxdigit(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0080) : _isctype(c, 0x0080));}



inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isblank (int c)
  {return ((__mb_cur_max == 1 ? (_pctype[c] & 0x0040) : _isctype(c, 0x0040)) || c == '\t');}



inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tolower(int c) {return ( c -'A'+'a');}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _toupper(int c) {return ( c -'a'+'A');}
# 188 "C:/upp/mingw/include/ctype.h"
typedef wchar_t wctype_t;



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);





 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);





inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t wc) {return (iswctype(wc,0x0103|0x0004));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t wc) {return (iswctype(wc,0x0103));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t wc) {return ((wc & ~0x7F) ==0);}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t wc) {return (iswctype(wc,0x0020));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t wc) {return (iswctype(wc,0x0004));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t wc) {return (iswctype(wc,0x0010|0x0103|0x0004));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t wc) {return (iswctype(wc,0x0002));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t wc) {return (iswctype(wc,0x0040|0x0010|0x0103|0x0004));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t wc) {return (iswctype(wc,0x0010));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t wc) {return (iswctype(wc,0x0008));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t wc) {return (iswctype(wc,0x0001));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t wc) {return (iswctype(wc,0x0080));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte(int c) {return (_pctype[(unsigned char)(c)] & 0x8000);}


inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t wc)
  {return (iswctype(wc,0x0040) || wc == L'\t');}





int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsym (int);


inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __isascii(int c) {return ((c & ~0x7F) == 0);}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __toascii(int c) {return (c & 0x7F);}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsymf(int c) {return (isalpha(c) || (c == '_'));}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsym(int c) {return (isalnum(c) || (c == '_'));}




int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsym (int);





}
# 212 "C:/upp/uppsrc/Core/Core.h" 2
# 255 "C:/upp/uppsrc/Core/Core.h"
# 1 "C:/upp/mingw/include/io.h" 1
# 41 "C:/upp/mingw/include/io.h"
  typedef int intptr_t;




typedef unsigned long _fsize_t;
# 63 "C:/upp/mingw/include/io.h"
struct _finddata_t
{
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 _fsize_t size;
 char name[(260)];
};

struct _finddatai64_t {
    unsigned attrib;
    time_t time_create;
    time_t time_access;
    time_t time_write;
    long long size;
    char name[(260)];
};
# 95 "C:/upp/mingw/include/io.h"
struct _wfinddata_t {
     unsigned attrib;
     time_t time_create;
     time_t time_access;
     time_t time_write;
     _fsize_t size;
     wchar_t name[(260)];
};

struct _wfinddatai64_t {
    unsigned attrib;
    time_t time_create;
    time_t time_access;
    time_t time_write;
    long long size;
    wchar_t name[(260)];
};
# 129 "C:/upp/mingw/include/io.h"
extern "C" {
# 139 "C:/upp/mingw/include/io.h"
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _findfirst (const char*, struct _finddata_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _findnext (long, struct _finddata_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _findclose (long);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _chdir (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getcwd (char*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _mkdir (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _mktemp (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rmdir (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _chmod (const char*, int);


 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filelengthi64(int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _findfirsti64(const char*, struct _finddatai64_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _findnexti64(long, struct _finddatai64_t*);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lseeki64(int, long long, int);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _telli64(int);






inline off64_t lseek64 (int, off64_t, int);
inline off64_t lseek64 (int fd, off64_t offset, int whence)
{
  return _lseeki64(fd, (long long) offset, whence);
}







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) chdir (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getcwd (char*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mkdir (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mktemp (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rmdir (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) chmod (const char*, int);





}
# 206 "C:/upp/mingw/include/io.h"
extern "C" {


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _access (const char*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _chsize (int, long);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _close (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _commit(int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _creat (const char*, int);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _dup (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _dup2 (int, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filelength (int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _get_osfhandle (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _isatty (int);







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _eof (int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _locking (int, int, long);

 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lseek (int, long, int);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _open (const char*, int, ...);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _open_osfhandle (long, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _pipe (int *, unsigned int, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _read (int, void*, unsigned int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _setmode (int, int);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) remove (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rename (const char*, const char*);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _sopen (const char*, int, int, ...);

 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tell (int);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _umask (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _unlink (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _write (int, const void*, unsigned int);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _waccess(const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchmod(const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcreat(const wchar_t*, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirst(const wchar_t*, struct _wfinddata_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnext(long, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wunlink(const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wopen(const wchar_t*, int, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsopen(const wchar_t*, int, int, ...);
 wchar_t * __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmktemp(wchar_t*);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirsti64(const wchar_t*, struct _wfinddatai64_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnexti64(long, struct _wfinddatai64_t*);
# 290 "C:/upp/mingw/include/io.h"
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) access (const char*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) chsize (int, long );
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) close (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) creat (const char*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) dup (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) dup2 (int, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) eof (int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) filelength (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isatty (int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lseek (int, long, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) open (const char*, int, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) read (int, void*, unsigned int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setmode (int, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sopen (const char*, int, int, ...);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tell (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) umask (int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) unlink (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) write (int, const void*, unsigned int);
# 337 "C:/upp/mingw/include/io.h"
}
# 256 "C:/upp/uppsrc/Core/Core.h" 2
# 289 "C:/upp/uppsrc/Core/Core.h"
# 1 "C:/upp/mingw/include/windows.h" 1
# 16 "C:/upp/mingw/include/windows.h"
       
# 17 "C:/upp/mingw/include/windows.h" 3
# 47 "C:/upp/mingw/include/windows.h" 3
# 1 "C:/upp/mingw/include/stdarg.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 1 3
# 7 "C:/upp/mingw/include/stdarg.h" 2 3
# 48 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/windef.h" 1 3



       
# 5 "C:/upp/mingw/include/windef.h" 3



extern "C" {
# 229 "C:/upp/mingw/include/windef.h" 3
typedef unsigned long DWORD;
typedef int WINBOOL,*PWINBOOL,*LPWINBOOL;



typedef WINBOOL BOOL;



typedef unsigned char BYTE;

typedef BOOL *PBOOL,*LPBOOL;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BYTE *PBYTE,*LPBYTE;
typedef int *PINT,*LPINT;
typedef WORD *PWORD,*LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD,*LPDWORD;
typedef const void *PCVOID,*LPCVOID;
typedef int INT;
typedef unsigned int UINT,*PUINT,*LPUINT;

# 1 "C:/upp/mingw/include/winnt.h" 1 3



       
# 5 "C:/upp/mingw/include/winnt.h" 3
# 31 "C:/upp/mingw/include/winnt.h" 3
extern "C" {


# 1 "C:/upp/mingw/include/winerror.h" 1 3



       
# 5 "C:/upp/mingw/include/winerror.h" 3
# 35 "C:/upp/mingw/include/winnt.h" 2 3
# 77 "C:/upp/mingw/include/winnt.h" 3
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef char CCHAR, *PCCHAR;
typedef unsigned char UCHAR,*PUCHAR;
typedef unsigned short USHORT,*PUSHORT;
typedef unsigned long ULONG,*PULONG;
typedef char *PSZ;

typedef void *PVOID,*LPVOID;





typedef void* PVOID64;
# 105 "C:/upp/mingw/include/winnt.h" 3
typedef wchar_t WCHAR;
typedef WCHAR *PWCHAR,*LPWCH,*PWCH,*NWPSTR,*LPWSTR,*PWSTR;
typedef const WCHAR *LPCWCH,*PCWCH,*LPCWSTR,*PCWSTR;
typedef CHAR *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;
typedef const CHAR *LPCCH,*PCSTR,*LPCSTR;
# 120 "C:/upp/mingw/include/winnt.h" 3
typedef CHAR TCHAR;
typedef CHAR _TCHAR;


typedef TCHAR TBYTE,*PTCH,*PTBYTE;
typedef TCHAR *LPTCH,*PTSTR,*LPTSTR,*LP,*PTCHAR;
typedef const TCHAR *LPCTSTR;
# 145 "C:/upp/mingw/include/winnt.h" 3
typedef SHORT *PSHORT;
typedef LONG *PLONG;

typedef void *HANDLE;





typedef HANDLE *PHANDLE,*LPHANDLE;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
# 167 "C:/upp/mingw/include/winnt.h" 3
typedef long long LONGLONG;
typedef unsigned long long DWORDLONG;



typedef LONGLONG *PLONGLONG;
typedef DWORDLONG *PDWORDLONG;
typedef DWORDLONG ULONGLONG,*PULONGLONG;
typedef LONGLONG USN;
# 185 "C:/upp/mingw/include/winnt.h" 3
typedef BYTE BOOLEAN,*PBOOLEAN;

typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;


# 1 "C:/upp/mingw/include/basetsd.h" 1 3



       
# 5 "C:/upp/mingw/include/basetsd.h" 3
# 48 "C:/upp/mingw/include/basetsd.h" 3
extern "C" {

typedef int LONG32, *PLONG32;

typedef int INT32, *PINT32;

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;
# 97 "C:/upp/mingw/include/basetsd.h" 3
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef unsigned long HANDLE_PTR;


typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
typedef long long LONG64, *PLONG64;
typedef long long INT64, *PINT64;
typedef unsigned long long ULONG64, *PULONG64;
typedef unsigned long long DWORD64, *PDWORD64;
typedef unsigned long long UINT64, *PUINT64;

}
# 193 "C:/upp/mingw/include/winnt.h" 2 3
# 1726 "C:/upp/mingw/include/winnt.h" 3
typedef DWORD ACCESS_MASK, *PACCESS_MASK;







typedef struct _GUID {
 unsigned long Data1;
 unsigned short Data2;
 unsigned short Data3;
 unsigned char Data4[8];
} GUID, *REFGUID, *LPGUID;


typedef struct _GENERIC_MAPPING {
 ACCESS_MASK GenericRead;
 ACCESS_MASK GenericWrite;
 ACCESS_MASK GenericExecute;
 ACCESS_MASK GenericAll;
} GENERIC_MAPPING, *PGENERIC_MAPPING;
typedef struct _ACE_HEADER {
 BYTE AceType;
 BYTE AceFlags;
 WORD AceSize;
} ACE_HEADER, *PACE_HEADER;
typedef struct _ACCESS_ALLOWED_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} ACCESS_ALLOWED_ACE, *PACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} ACCESS_DENIED_ACE, *PACCESS_DENIED_ACE;
typedef struct _SYSTEM_AUDIT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_ALARM_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} SYSTEM_ALARM_ACE,*PSYSTEM_ALARM_ACE;
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE,*PACCESS_ALLOWED_OBJECT_ACE;
typedef struct _ACCESS_DENIED_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE,*PACCESS_DENIED_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE,*PSYSTEM_AUDIT_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE,*PSYSTEM_ALARM_OBJECT_ACE;
typedef struct _ACL {
 BYTE AclRevision;
 BYTE Sbz1;
 WORD AclSize;
 WORD AceCount;
 WORD Sbz2;
} ACL,*PACL;
typedef struct _ACL_REVISION_INFORMATION {
 DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef struct _ACL_SIZE_INFORMATION {
 DWORD AceCount;
 DWORD AclBytesInUse;
 DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
# 1835 "C:/upp/mingw/include/winnt.h" 3
typedef struct _FLOATING_SAVE_AREA {
 DWORD ControlWord;
 DWORD StatusWord;
 DWORD TagWord;
 DWORD ErrorOffset;
 DWORD ErrorSelector;
 DWORD DataOffset;
 DWORD DataSelector;
 BYTE RegisterArea[80];
 DWORD Cr0NpxState;
} FLOATING_SAVE_AREA;
typedef struct _CONTEXT {
 DWORD ContextFlags;
 DWORD Dr0;
 DWORD Dr1;
 DWORD Dr2;
 DWORD Dr3;
 DWORD Dr6;
 DWORD Dr7;
 FLOATING_SAVE_AREA FloatSave;
 DWORD SegGs;
 DWORD SegFs;
 DWORD SegEs;
 DWORD SegDs;
 DWORD Edi;
 DWORD Esi;
 DWORD Ebx;
 DWORD Edx;
 DWORD Ecx;
 DWORD Eax;
 DWORD Ebp;
 DWORD Eip;
 DWORD SegCs;
 DWORD EFlags;
 DWORD Esp;
 DWORD SegSs;
 BYTE ExtendedRegisters[512];
} CONTEXT;
# 2354 "C:/upp/mingw/include/winnt.h" 3
typedef CONTEXT *PCONTEXT,*LPCONTEXT;
typedef struct _EXCEPTION_RECORD {
 DWORD ExceptionCode;
 DWORD ExceptionFlags;
 struct _EXCEPTION_RECORD *ExceptionRecord;
 PVOID ExceptionAddress;
 DWORD NumberParameters;
 DWORD ExceptionInformation[15];
} EXCEPTION_RECORD,*PEXCEPTION_RECORD,*LPEXCEPTION_RECORD;
typedef struct _EXCEPTION_POINTERS {
 PEXCEPTION_RECORD ExceptionRecord;
 PCONTEXT ContextRecord;
} EXCEPTION_POINTERS,*PEXCEPTION_POINTERS,*LPEXCEPTION_POINTERS;
typedef union _LARGE_INTEGER {
  struct {
    DWORD LowPart;
    LONG HighPart;
  } u;

  __extension__ struct {
    DWORD LowPart;
    LONG HighPart;
  };

  LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
typedef union _ULARGE_INTEGER {
  struct {
    DWORD LowPart;
    DWORD HighPart;
  } u;

  __extension__ struct {
    DWORD LowPart;
    DWORD HighPart;
  };

  ULONGLONG QuadPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
typedef struct _LUID {
  DWORD LowPart;
  LONG HighPart;
} LUID, *PLUID;
#pragma pack(push,4)
typedef struct _LUID_AND_ATTRIBUTES {
 LUID Luid;
 DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;
#pragma pack(pop)
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;
typedef struct _PRIVILEGE_SET {
 DWORD PrivilegeCount;
 DWORD Control;
 LUID_AND_ATTRIBUTES Privilege[1];
} PRIVILEGE_SET,*PPRIVILEGE_SET;
typedef struct _SECURITY_ATTRIBUTES {
 DWORD nLength;
 LPVOID lpSecurityDescriptor;
 BOOL bInheritHandle;
} SECURITY_ATTRIBUTES,*PSECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;
typedef enum _SECURITY_IMPERSONATION_LEVEL {
 SecurityAnonymous,
 SecurityIdentification,
 SecurityImpersonation,
 SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL,*PSECURITY_IMPERSONATION_LEVEL;
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,*PSECURITY_CONTEXT_TRACKING_MODE;
typedef struct _SECURITY_QUALITY_OF_SERVICE {
 DWORD Length;
 SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
 SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
 BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE,*PSECURITY_QUALITY_OF_SERVICE;
typedef PVOID PACCESS_TOKEN;
typedef struct _SE_IMPERSONATION_STATE {
 PACCESS_TOKEN Token;
 BOOLEAN CopyOnOpen;
 BOOLEAN EffectiveOnly;
 SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE,*PSE_IMPERSONATION_STATE;
typedef struct _SID_IDENTIFIER_AUTHORITY {
 BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,*LPSID_IDENTIFIER_AUTHORITY;
typedef PVOID PSID;
typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   DWORD SubAuthority[1];
} SID, *PISID;
typedef struct _SID_AND_ATTRIBUTES {
 PSID Sid;
 DWORD Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
typedef struct _TOKEN_SOURCE {
 CHAR SourceName[8];
 LUID SourceIdentifier;
} TOKEN_SOURCE,*PTOKEN_SOURCE;
typedef struct _TOKEN_CONTROL {
 LUID TokenId;
 LUID AuthenticationId;
 LUID ModifiedId;
 TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL,*PTOKEN_CONTROL;
typedef struct _TOKEN_DEFAULT_DACL {
 PACL DefaultDacl;
} TOKEN_DEFAULT_DACL,*PTOKEN_DEFAULT_DACL;
typedef struct _TOKEN_GROUPS {
 DWORD GroupCount;
 SID_AND_ATTRIBUTES Groups[1];
} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;
typedef struct _TOKEN_OWNER {
 PSID Owner;
} TOKEN_OWNER,*PTOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
 PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP,*PTOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_PRIVILEGES {
 DWORD PrivilegeCount;
 LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;
typedef enum tagTOKEN_TYPE {
 TokenPrimary = 1,
 TokenImpersonation
} TOKEN_TYPE,*PTOKEN_TYPE;
typedef struct _TOKEN_STATISTICS {
 LUID TokenId;
 LUID AuthenticationId;
 LARGE_INTEGER ExpirationTime;
 TOKEN_TYPE TokenType;
 SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
 DWORD DynamicCharged;
 DWORD DynamicAvailable;
 DWORD GroupCount;
 DWORD PrivilegeCount;
 LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;
typedef struct _TOKEN_USER {
 SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;
typedef DWORD SECURITY_INFORMATION,*PSECURITY_INFORMATION;
typedef WORD SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR {
 BYTE Revision;
 BYTE Sbz1;
 SECURITY_DESCRIPTOR_CONTROL Control;
 PSID Owner;
 PSID Group;
 PACL Sacl;
 PACL Dacl;
} SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
typedef enum _TOKEN_INFORMATION_CLASS {
 TokenUser=1,
 TokenGroups,
 TokenPrivileges,
 TokenOwner,
 TokenPrimaryGroup,
 TokenDefaultDacl,
 TokenSource,
 TokenType,
 TokenImpersonationLevel,
 TokenStatistics,
 TokenRestrictedSids,
 TokenSessionId,
 TokenGroupsAndPrivileges,
 TokenSessionReference,
 TokenSandBoxInert,
 TokenAuditPolicy,
 TokenOrigin
} TOKEN_INFORMATION_CLASS;
typedef enum _SID_NAME_USE {
 SidTypeUser=1,
 SidTypeGroup,
 SidTypeDomain,
 SidTypeAlias,
 SidTypeWellKnownGroup,
 SidTypeDeletedAccount,
 SidTypeInvalid,
 SidTypeUnknown,
 SidTypeComputer
} SID_NAME_USE,*PSID_NAME_USE;
typedef struct _QUOTA_LIMITS {
 SIZE_T PagedPoolLimit;
 SIZE_T NonPagedPoolLimit;
 SIZE_T MinimumWorkingSetSize;
 SIZE_T MaximumWorkingSetSize;
 SIZE_T PagefileLimit;
 LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS,*PQUOTA_LIMITS;
typedef struct _IO_COUNTERS {
 ULONGLONG ReadOperationCount;
 ULONGLONG WriteOperationCount;
 ULONGLONG OtherOperationCount;
 ULONGLONG ReadTransferCount;
 ULONGLONG WriteTransferCount;
 ULONGLONG OtherTransferCount;
} IO_COUNTERS, *PIO_COUNTERS;
typedef struct _FILE_NOTIFY_INFORMATION {
 DWORD NextEntryOffset;
 DWORD Action;
 DWORD FileNameLength;
 WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION,*PFILE_NOTIFY_INFORMATION;
typedef struct _TAPE_ERASE {
 DWORD Type;
 BOOLEAN Immediate;
} TAPE_ERASE,*PTAPE_ERASE;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
 BOOLEAN ECC;
 BOOLEAN Compression;
 BOOLEAN DataPadding;
 BOOLEAN ReportSetmarks;
  DWORD DefaultBlockSize;
  DWORD MaximumBlockSize;
  DWORD MinimumBlockSize;
  DWORD MaximumPartitionCount;
  DWORD FeaturesLow;
  DWORD FeaturesHigh;
  DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS,*PTAPE_GET_DRIVE_PARAMETERS;
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
 LARGE_INTEGER Capacity;
 LARGE_INTEGER Remaining;
 DWORD BlockSize;
 DWORD PartitionCount;
 BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS,*PTAPE_GET_MEDIA_PARAMETERS;
typedef struct _TAPE_GET_POSITION {
 ULONG Type;
 ULONG Partition;
 ULONG OffsetLow;
 ULONG OffsetHigh;
} TAPE_GET_POSITION,*PTAPE_GET_POSITION;
typedef struct _TAPE_PREPARE {
 DWORD Operation;
 BOOLEAN Immediate;
} TAPE_PREPARE,*PTAPE_PREPARE;
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
 BOOLEAN ECC;
 BOOLEAN Compression;
 BOOLEAN DataPadding;
 BOOLEAN ReportSetmarks;
 ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS,*PTAPE_SET_DRIVE_PARAMETERS;
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
 ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS,*PTAPE_SET_MEDIA_PARAMETERS;
typedef struct _TAPE_SET_POSITION {
 DWORD Method;
 DWORD Partition;
 LARGE_INTEGER Offset;
 BOOLEAN Immediate;
} TAPE_SET_POSITION,*PTAPE_SET_POSITION;
typedef struct _TAPE_WRITE_MARKS {
 DWORD Type;
 DWORD Count;
 BOOLEAN Immediate;
} TAPE_WRITE_MARKS,*PTAPE_WRITE_MARKS;
typedef struct _TAPE_CREATE_PARTITION {
 DWORD Method;
 DWORD Count;
 DWORD Size;
} TAPE_CREATE_PARTITION,*PTAPE_CREATE_PARTITION;
typedef struct _MEMORY_BASIC_INFORMATION {
 PVOID BaseAddress;
 PVOID AllocationBase;
 DWORD AllocationProtect;
 DWORD RegionSize;
 DWORD State;
 DWORD Protect;
 DWORD Type;
} MEMORY_BASIC_INFORMATION,*PMEMORY_BASIC_INFORMATION;
typedef struct _MESSAGE_RESOURCE_ENTRY {
 WORD Length;
 WORD Flags;
 BYTE Text[1];
} MESSAGE_RESOURCE_ENTRY,*PMESSAGE_RESOURCE_ENTRY;
typedef struct _MESSAGE_RESOURCE_BLOCK {
 DWORD LowId;
 DWORD HighId;
 DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK,*PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
 DWORD NumberOfBlocks;
 MESSAGE_RESOURCE_BLOCK Blocks[1];
} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;
typedef struct _LIST_ENTRY {
 struct _LIST_ENTRY *Flink;
 struct _LIST_ENTRY *Blink;
} LIST_ENTRY,*PLIST_ENTRY;
typedef struct _SINGLE_LIST_ENTRY {
 struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY,*PSINGLE_LIST_ENTRY;






typedef union _SLIST_HEADER {
 ULONGLONG Alignment;
 __extension__ struct {
  SINGLE_LIST_ENTRY Next;
  WORD Depth;
  WORD Sequence;
 } ;
} SLIST_HEADER,*PSLIST_HEADER;


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
 WORD Type;
 WORD CreatorBackTraceIndex;
 struct _RTL_CRITICAL_SECTION *CriticalSection;
 LIST_ENTRY ProcessLocksList;
 DWORD EntryCount;
 DWORD ContentionCount;
 DWORD Spare[2];
} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG;
typedef struct _RTL_CRITICAL_SECTION {
 PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
 LONG LockCount;
 LONG RecursionCount;
 HANDLE OwningThread;
 HANDLE LockSemaphore;
 DWORD Reserved;
} RTL_CRITICAL_SECTION,*PRTL_CRITICAL_SECTION;
typedef struct _EVENTLOGRECORD {
 DWORD Length;
 DWORD Reserved;
 DWORD RecordNumber;
 DWORD TimeGenerated;
 DWORD TimeWritten;
 DWORD EventID;
 WORD EventType;
 WORD NumStrings;
 WORD EventCategory;
 WORD ReservedFlags;
 DWORD ClosingRecordNumber;
 DWORD StringOffset;
 DWORD UserSidLength;
 DWORD UserSidOffset;
 DWORD DataLength;
 DWORD DataOffset;
} EVENTLOGRECORD,*PEVENTLOGRECORD;
typedef struct _OSVERSIONINFOA {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 CHAR szCSDVersion[128];
} OSVERSIONINFOA,*POSVERSIONINFOA,*LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 WCHAR szCSDVersion[128];
} OSVERSIONINFOW,*POSVERSIONINFOW,*LPOSVERSIONINFOW;
typedef struct _OSVERSIONINFOEXA {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 CHAR szCSDVersion[128];
 WORD wServicePackMajor;
 WORD wServicePackMinor;
 WORD wSuiteMask;
 BYTE wProductType;
 BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 WCHAR szCSDVersion[128];
 WORD wServicePackMajor;
 WORD wServicePackMinor;
 WORD wSuiteMask;
 BYTE wProductType;
 BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW;
#pragma pack(push,2)
typedef struct _IMAGE_VXD_HEADER {
 WORD e32_magic;
 BYTE e32_border;
 BYTE e32_worder;
 DWORD e32_level;
 WORD e32_cpu;
 WORD e32_os;
 DWORD e32_ver;
 DWORD e32_mflags;
 DWORD e32_mpages;
 DWORD e32_startobj;
 DWORD e32_eip;
 DWORD e32_stackobj;
 DWORD e32_esp;
 DWORD e32_pagesize;
 DWORD e32_lastpagesize;
 DWORD e32_fixupsize;
 DWORD e32_fixupsum;
 DWORD e32_ldrsize;
 DWORD e32_ldrsum;
 DWORD e32_objtab;
 DWORD e32_objcnt;
 DWORD e32_objmap;
 DWORD e32_itermap;
 DWORD e32_rsrctab;
 DWORD e32_rsrccnt;
 DWORD e32_restab;
 DWORD e32_enttab;
 DWORD e32_dirtab;
 DWORD e32_dircnt;
 DWORD e32_fpagetab;
 DWORD e32_frectab;
 DWORD e32_impmod;
 DWORD e32_impmodcnt;
 DWORD e32_impproc;
 DWORD e32_pagesum;
 DWORD e32_datapage;
 DWORD e32_preload;
 DWORD e32_nrestab;
 DWORD e32_cbnrestab;
 DWORD e32_nressum;
 DWORD e32_autodata;
 DWORD e32_debuginfo;
 DWORD e32_debuglen;
 DWORD e32_instpreload;
 DWORD e32_instdemand;
 DWORD e32_heapsize;
 BYTE e32_res3[12];
 DWORD e32_winresoff;
 DWORD e32_winreslen;
 WORD e32_devid;
 WORD e32_ddkver;
} IMAGE_VXD_HEADER,*PIMAGE_VXD_HEADER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_FILE_HEADER {
 WORD Machine;
 WORD NumberOfSections;
 DWORD TimeDateStamp;
 DWORD PointerToSymbolTable;
 DWORD NumberOfSymbols;
 WORD SizeOfOptionalHeader;
 WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
 DWORD VirtualAddress;
 DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER {
 WORD Magic;
 BYTE MajorLinkerVersion;
 BYTE MinorLinkerVersion;
 DWORD SizeOfCode;
 DWORD SizeOfInitializedData;
 DWORD SizeOfUninitializedData;
 DWORD AddressOfEntryPoint;
 DWORD BaseOfCode;
 DWORD BaseOfData;
 DWORD ImageBase;
 DWORD SectionAlignment;
 DWORD FileAlignment;
 WORD MajorOperatingSystemVersion;
 WORD MinorOperatingSystemVersion;
 WORD MajorImageVersion;
 WORD MinorImageVersion;
 WORD MajorSubsystemVersion;
 WORD MinorSubsystemVersion;
 DWORD Win32VersionValue;
 DWORD SizeOfImage;
 DWORD SizeOfHeaders;
 DWORD CheckSum;
 WORD Subsystem;
 WORD DllCharacteristics;
 DWORD SizeOfStackReserve;
 DWORD SizeOfStackCommit;
 DWORD SizeOfHeapReserve;
 DWORD SizeOfHeapCommit;
 DWORD LoaderFlags;
 DWORD NumberOfRvaAndSizes;
 IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
 WORD Magic;
 BYTE MajorLinkerVersion;
 BYTE MinorLinkerVersion;
 DWORD SizeOfCode;
 DWORD SizeOfInitializedData;
 DWORD SizeOfUninitializedData;
 DWORD AddressOfEntryPoint;
 DWORD BaseOfCode;
 ULONGLONG ImageBase;
 DWORD SectionAlignment;
 DWORD FileAlignment;
 WORD MajorOperatingSystemVersion;
 WORD MinorOperatingSystemVersion;
 WORD MajorImageVersion;
 WORD MinorImageVersion;
 WORD MajorSubsystemVersion;
 WORD MinorSubsystemVersion;
 DWORD Win32VersionValue;
 DWORD SizeOfImage;
 DWORD SizeOfHeaders;
 DWORD CheckSum;
 WORD Subsystem;
 WORD DllCharacteristics;
 ULONGLONG SizeOfStackReserve;
 ULONGLONG SizeOfStackCommit;
 ULONGLONG SizeOfHeapReserve;
 ULONGLONG SizeOfHeapCommit;
 DWORD LoaderFlags;
 DWORD NumberOfRvaAndSizes;
 IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64,*PIMAGE_OPTIONAL_HEADER64;




typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32 PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
 WORD Magic;
 BYTE MajorLinkerVersion;
 BYTE MinorLinkerVersion;
 DWORD SizeOfCode;
 DWORD SizeOfInitializedData;
 DWORD SizeOfUninitializedData;
 DWORD AddressOfEntryPoint;
 DWORD BaseOfCode;
 DWORD BaseOfData;
 DWORD BaseOfBss;
 DWORD GprMask;
 DWORD CprMask[4];
 DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER,*PIMAGE_ROM_OPTIONAL_HEADER;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_DOS_HEADER {
 WORD e_magic;
 WORD e_cblp;
 WORD e_cp;
 WORD e_crlc;
 WORD e_cparhdr;
 WORD e_minalloc;
 WORD e_maxalloc;
 WORD e_ss;
 WORD e_sp;
 WORD e_csum;
 WORD e_ip;
 WORD e_cs;
 WORD e_lfarlc;
 WORD e_ovno;
 WORD e_res[4];
 WORD e_oemid;
 WORD e_oeminfo;
 WORD e_res2[10];
 LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER {
 WORD ne_magic;
 CHAR ne_ver;
 CHAR ne_rev;
 WORD ne_enttab;
 WORD ne_cbenttab;
 LONG ne_crc;
 WORD ne_flags;
 WORD ne_autodata;
 WORD ne_heap;
 WORD ne_stack;
 LONG ne_csip;
 LONG ne_sssp;
 WORD ne_cseg;
 WORD ne_cmod;
 WORD ne_cbnrestab;
 WORD ne_segtab;
 WORD ne_rsrctab;
 WORD ne_restab;
 WORD ne_modtab;
 WORD ne_imptab;
 LONG ne_nrestab;
 WORD ne_cmovent;
 WORD ne_align;
 WORD ne_cres;
 BYTE ne_exetyp;
 BYTE ne_flagsothers;
 WORD ne_pretthunks;
 WORD ne_psegrefbytes;
 WORD ne_swaparea;
 WORD ne_expver;
} IMAGE_OS2_HEADER,*PIMAGE_OS2_HEADER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_NT_HEADERS {
 DWORD Signature;
 IMAGE_FILE_HEADER FileHeader;
 IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_NT_HEADERS64 {
 DWORD Signature;
 IMAGE_FILE_HEADER FileHeader;
 IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS64,*PIMAGE_NT_HEADERS64;




typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
 IMAGE_FILE_HEADER FileHeader;
 IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS,*PIMAGE_ROM_HEADERS;
typedef struct _IMAGE_SECTION_HEADER {
 BYTE Name[8];
 union {
  DWORD PhysicalAddress;
  DWORD VirtualSize;
 } Misc;
 DWORD VirtualAddress;
 DWORD SizeOfRawData;
 DWORD PointerToRawData;
 DWORD PointerToRelocations;
 DWORD PointerToLinenumbers;
 WORD NumberOfRelocations;
 WORD NumberOfLinenumbers;
 DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_SYMBOL {
 union {
  BYTE ShortName[8];
  struct {
   DWORD Short;
   DWORD Long;
  } Name;
  PBYTE LongName[2];
 } N;
 DWORD Value;
 SHORT SectionNumber;
 WORD Type;
 BYTE StorageClass;
 BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL,*PIMAGE_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL {
 struct {
  DWORD TagIndex;
  union {
   struct {
    WORD Linenumber;
    WORD Size;
   } LnSz;
   DWORD TotalSize;
  } Misc;
  union {
   struct {
    DWORD PointerToLinenumber;
    DWORD PointerToNextFunction;
   } Function;
   struct {
    WORD Dimension[4];
   } Array;
  } FcnAry;
  WORD TvIndex;
 } Sym;
 struct {
  BYTE Name[18];
 } File;
 struct {
  DWORD Length;
  WORD NumberOfRelocations;
  WORD NumberOfLinenumbers;
  DWORD CheckSum;
  SHORT Number;
  BYTE Selection;
 } Section;
} IMAGE_AUX_SYMBOL,*PIMAGE_AUX_SYMBOL;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
 DWORD NumberOfSymbols;
 DWORD LvaToFirstSymbol;
 DWORD NumberOfLinenumbers;
 DWORD LvaToFirstLinenumber;
 DWORD RvaToFirstByteOfCode;
 DWORD RvaToLastByteOfCode;
 DWORD RvaToFirstByteOfData;
 DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER,*PIMAGE_COFF_SYMBOLS_HEADER;
typedef struct _IMAGE_RELOCATION {
 __extension__ union {
  DWORD VirtualAddress;
  DWORD RelocCount;
 } ;
 DWORD SymbolTableIndex;
 WORD Type;
} IMAGE_RELOCATION,*PIMAGE_RELOCATION;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_BASE_RELOCATION {
 DWORD VirtualAddress;
 DWORD SizeOfBlock;
} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_LINENUMBER {
 union {
  DWORD SymbolTableIndex;
  DWORD VirtualAddress;
 } Type;
 WORD Linenumber;
} IMAGE_LINENUMBER,*PIMAGE_LINENUMBER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
 BYTE Name[16];
 BYTE Date[12];
 BYTE UserID[6];
 BYTE GroupID[6];
 BYTE Mode[8];
 BYTE Size[10];
 BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER,*PIMAGE_ARCHIVE_MEMBER_HEADER;
typedef struct _IMAGE_EXPORT_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD Name;
 DWORD Base;
 DWORD NumberOfFunctions;
 DWORD NumberOfNames;
 DWORD AddressOfFunctions;
 DWORD AddressOfNames;
 DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;
typedef struct _IMAGE_IMPORT_BY_NAME {
 WORD Hint;
 BYTE Name[1];
} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;
typedef struct _IMAGE_THUNK_DATA32 {
 union {
  DWORD ForwarderString;
  DWORD Function;
  DWORD Ordinal;
  DWORD AddressOfData;
 } u1;
} IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;
typedef struct _IMAGE_THUNK_DATA64 {
 union {
  ULONGLONG ForwarderString;
  ULONGLONG Function;
  ULONGLONG Ordinal;
  ULONGLONG AddressOfData;
 } u1;
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;




typedef IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32 PIMAGE_THUNK_DATA;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
 __extension__ union {
  DWORD Characteristics;
  DWORD OriginalFirstThunk;
 } ;
 DWORD TimeDateStamp;
 DWORD ForwarderChain;
 DWORD Name;
 DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
 DWORD TimeDateStamp;
 WORD OffsetModuleName;
 WORD NumberOfModuleForwarderRefs;
} IMAGE_BOUND_IMPORT_DESCRIPTOR,*PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
 DWORD TimeDateStamp;
 WORD OffsetModuleName;
 WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;
typedef void(__attribute__((__stdcall__)) *PIMAGE_TLS_CALLBACK)(PVOID,DWORD,PVOID);
typedef struct _IMAGE_TLS_DIRECTORY32 {
 DWORD StartAddressOfRawData;
 DWORD EndAddressOfRawData;
 DWORD AddressOfIndex;
 DWORD AddressOfCallBacks;
 DWORD SizeOfZeroFill;
 DWORD Characteristics;
} IMAGE_TLS_DIRECTORY32,*PIMAGE_TLS_DIRECTORY32;
typedef struct _IMAGE_TLS_DIRECTORY64 {
 ULONGLONG StartAddressOfRawData;
 ULONGLONG EndAddressOfRawData;
 ULONGLONG AddressOfIndex;
 ULONGLONG AddressOfCallBacks;
 DWORD SizeOfZeroFill;
 DWORD Characteristics;
} IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64;




typedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;

typedef struct _IMAGE_RESOURCE_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 WORD NumberOfNamedEntries;
 WORD NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;
__extension__ typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
 __extension__ union {
  __extension__ struct {
   DWORD NameOffset:31;
   DWORD NameIsString:1;
  };
  DWORD Name;
  WORD Id;
 } ;
 __extension__ union {
  DWORD OffsetToData;
  __extension__ struct {
   DWORD OffsetToDirectory:31;
   DWORD DataIsDirectory:1;
  } ;
 } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
 WORD Length;
 CHAR NameString[1];
} IMAGE_RESOURCE_DIRECTORY_STRING,*PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
 WORD Length;
 WCHAR NameString[1];
} IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
 DWORD OffsetToData;
 DWORD Size;
 DWORD CodePage;
 DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY,*PIMAGE_RESOURCE_DATA_ENTRY;
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD GlobalFlagsClear;
 DWORD GlobalFlagsSet;
 DWORD CriticalSectionDefaultTimeout;
 DWORD DeCommitFreeBlockThreshold;
 DWORD DeCommitTotalFreeThreshold;
 PVOID LockPrefixTable;
 DWORD MaximumAllocationSize;
 DWORD VirtualMemoryThreshold;
 DWORD ProcessHeapFlags;
 DWORD Reserved[4];
} IMAGE_LOAD_CONFIG_DIRECTORY,*PIMAGE_LOAD_CONFIG_DIRECTORY;
typedef struct {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD GlobalFlagsClear;
 DWORD GlobalFlagsSet;
 DWORD CriticalSectionDefaultTimeout;
 ULONGLONG DeCommitFreeBlockThreshold;
 ULONGLONG DeCommitTotalFreeThreshold;
 ULONGLONG LockPrefixTable;
 ULONGLONG MaximumAllocationSize;
 ULONGLONG VirtualMemoryThreshold;
 ULONGLONG ProcessAffinityMask;
 DWORD ProcessHeapFlags;
 WORD CSDFlags;
 WORD Reserved1;
 ULONGLONG EditList;
 DWORD Reserved[2];
} IMAGE_LOAD_CONFIG_DIRECTORY64,*PIMAGE_LOAD_CONFIG_DIRECTORY64;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
 DWORD BeginAddress;
 DWORD EndAddress;
 PVOID ExceptionHandler;
 PVOID HandlerData;
 DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
 unsigned int FuncStart:32;
 unsigned int PrologLen:8;
 unsigned int FuncLen:22;
 unsigned int ThirtyTwoBit:1;
 unsigned int ExceptionFlag:1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_DEBUG_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD Type;
 DWORD SizeOfData;
 DWORD AddressOfRawData;
 DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY,*PIMAGE_DEBUG_DIRECTORY;
typedef struct _FPO_DATA {
 DWORD ulOffStart;
 DWORD cbProcSize;
 DWORD cdwLocals;
 WORD cdwParams;
 WORD cbProlog:8;
 WORD cbRegs:3;
 WORD fHasSEH:1;
 WORD fUseBP:1;
 WORD reserved:1;
 WORD cbFrame:2;
} FPO_DATA,*PFPO_DATA;
typedef struct _IMAGE_DEBUG_MISC {
 DWORD DataType;
 DWORD Length;
 BOOLEAN Unicode;
 BYTE Reserved[3];
 BYTE Data[1];
} IMAGE_DEBUG_MISC,*PIMAGE_DEBUG_MISC;
typedef struct _IMAGE_FUNCTION_ENTRY {
 DWORD StartingAddress;
 DWORD EndingAddress;
 DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY,*PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_FUNCTION_ENTRY64 {
 ULONGLONG StartingAddress;
 ULONGLONG EndingAddress;
 __extension__ union {
  ULONGLONG EndOfPrologue;
  ULONGLONG UnwindInfoAddress;
 } ;
} IMAGE_FUNCTION_ENTRY64,*PIMAGE_FUNCTION_ENTRY64;
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
 WORD Signature;
 WORD Flags;
 WORD Machine;
 WORD Characteristics;
 DWORD TimeDateStamp;
 DWORD CheckSum;
 DWORD ImageBase;
 DWORD SizeOfImage;
 DWORD NumberOfSections;
 DWORD ExportedNamesSize;
 DWORD DebugDirectorySize;
 DWORD SectionAlignment;
 DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER,*PIMAGE_SEPARATE_DEBUG_HEADER;
#pragma pack(pop)
typedef enum _CM_SERVICE_NODE_TYPE {
 DriverType=1,
 FileSystemType=2,
 Win32ServiceOwnProcess=16,
 Win32ServiceShareProcess=32,
 AdapterType=4,
 RecognizerType=8
} SERVICE_NODE_TYPE;
typedef enum _CM_SERVICE_LOAD_TYPE {
 BootLoad=0,
 SystemLoad=1,
 AutoLoad=2,
 DemandLoad=3,
 DisableLoad=4
} SERVICE_LOAD_TYPE;
typedef enum _CM_ERROR_CONTROL_TYPE {
 IgnoreError=0,
 NormalError=1,
 SevereError=2,
 CriticalError=3
} SERVICE_ERROR_TYPE;
typedef struct _NT_TIB {
 struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
 PVOID StackBase;
 PVOID StackLimit;
 PVOID SubSystemTib;
 __extension__ union {
  PVOID FiberData;
  DWORD Version;
 } ;
 PVOID ArbitraryUserPointer;
 struct _NT_TIB *Self;
} NT_TIB,*PNT_TIB;
typedef struct _REPARSE_DATA_BUFFER {
 DWORD ReparseTag;
 WORD ReparseDataLength;
 WORD Reserved;
 __extension__ union {
  struct {
   WORD SubstituteNameOffset;
   WORD SubstituteNameLength;
   WORD PrintNameOffset;
   WORD PrintNameLength;
   ULONG Flags;
   WCHAR PathBuffer[1];
  } SymbolicLinkReparseBuffer;
  struct {
   WORD SubstituteNameOffset;
   WORD SubstituteNameLength;
   WORD PrintNameOffset;
   WORD PrintNameLength;
   WCHAR PathBuffer[1];
  } MountPointReparseBuffer;
  struct {
   BYTE DataBuffer[1];
  } GenericReparseBuffer;
 } ;
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
typedef struct _REPARSE_GUID_DATA_BUFFER {
 DWORD ReparseTag;
 WORD ReparseDataLength;
 WORD Reserved;
 GUID ReparseGuid;
 struct {
  BYTE DataBuffer[1];
 } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
typedef struct _REPARSE_POINT_INFORMATION {
 WORD ReparseDataLength;
 WORD UnparsedNameLength;
} REPARSE_POINT_INFORMATION, *PREPARSE_POINT_INFORMATION;

typedef union _FILE_SEGMENT_ELEMENT {
 PVOID64 Buffer;
 ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
# 3439 "C:/upp/mingw/include/winnt.h" 3
typedef enum _JOBOBJECTINFOCLASS {
 JobObjectBasicAccountingInformation = 1,
 JobObjectBasicLimitInformation,
 JobObjectBasicProcessIdList,
 JobObjectBasicUIRestrictions,
 JobObjectSecurityLimitInformation,
 JobObjectEndOfJobTimeInformation,
 JobObjectAssociateCompletionPortInformation,
 JobObjectBasicAndIoAccountingInformation,
 JobObjectExtendedLimitInformation,
 JobObjectJobSetInformation,
 MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
 LARGE_INTEGER TotalUserTime;
 LARGE_INTEGER TotalKernelTime;
 LARGE_INTEGER ThisPeriodTotalUserTime;
 LARGE_INTEGER ThisPeriodTotalKernelTime;
 DWORD TotalPageFaultCount;
 DWORD TotalProcesses;
 DWORD ActiveProcesses;
 DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,*PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
 LARGE_INTEGER PerProcessUserTimeLimit;
 LARGE_INTEGER PerJobUserTimeLimit;
 DWORD LimitFlags;
 SIZE_T MinimumWorkingSetSize;
 SIZE_T MaximumWorkingSetSize;
 DWORD ActiveProcessLimit;
 ULONG_PTR Affinity;
 DWORD PriorityClass;
 DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION,*PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
 DWORD NumberOfAssignedProcesses;
 DWORD NumberOfProcessIdsInList;
 ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
 DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS,*PJOBOBJECT_BASIC_UI_RESTRICTIONS;
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
 DWORD SecurityLimitFlags;
 HANDLE JobToken;
 PTOKEN_GROUPS SidsToDisable;
 PTOKEN_PRIVILEGES PrivilegesToDelete;
 PTOKEN_GROUPS RestrictedSids;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION,*PJOBOBJECT_SECURITY_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
 DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION,*PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
 PVOID CompletionKey;
 HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT,*PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
 IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION,*PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
 JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
 IO_COUNTERS IoInfo;
 SIZE_T ProcessMemoryLimit;
 SIZE_T JobMemoryLimit;
 SIZE_T PeakProcessMemoryUsed;
 SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION,*PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
 DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION,*PJOBOBJECT_JOBSET_INFORMATION;



# 1 "C:/upp/mingw/include/pshpack4.h" 1 3

#pragma pack(push,4)
# 3514 "C:/upp/mingw/include/winnt.h" 2 3






typedef enum _LATENCY_TIME {
 LT_DONT_CARE,
 LT_LOWEST_LATENCY
} LATENCY_TIME, *PLATENCY_TIME;

typedef enum _SYSTEM_POWER_STATE {
 PowerSystemUnspecified,
 PowerSystemWorking,
 PowerSystemSleeping1,
 PowerSystemSleeping2,
 PowerSystemSleeping3,
 PowerSystemHibernate,
 PowerSystemShutdown,
 PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;


typedef enum {
 PowerActionNone,
 PowerActionReserved,
 PowerActionSleep,
 PowerActionHibernate,
 PowerActionShutdown,
 PowerActionShutdownReset,
 PowerActionShutdownOff,
 PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
 PowerDeviceUnspecified,
 PowerDeviceD0,
 PowerDeviceD1,
 PowerDeviceD2,
 PowerDeviceD3,
 PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef struct {
 DWORD Granularity;
 DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;

typedef struct _POWER_ACTION_POLICY {
 POWER_ACTION Action;
 ULONG Flags;
 ULONG EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
# 3595 "C:/upp/mingw/include/winnt.h" 3
typedef struct _SYSTEM_POWER_LEVEL {
 BOOLEAN Enable;
 UCHAR Spare[3];
 ULONG BatteryLevel;
 POWER_ACTION_POLICY PowerPolicy;
 SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

typedef struct _SYSTEM_POWER_POLICY {
 ULONG Revision;
 POWER_ACTION_POLICY PowerButton;
 POWER_ACTION_POLICY SleepButton;
 POWER_ACTION_POLICY LidClose;
 SYSTEM_POWER_STATE LidOpenWake;
 ULONG Reserved;
 POWER_ACTION_POLICY Idle;
 ULONG IdleTimeout;
 UCHAR IdleSensitivity;
 UCHAR DynamicThrottle;
 UCHAR Spare2[2];
 SYSTEM_POWER_STATE MinSleep;
 SYSTEM_POWER_STATE MaxSleep;
 SYSTEM_POWER_STATE ReducedLatencySleep;
 ULONG WinLogonFlags;
 ULONG Spare3;
 ULONG DozeS4Timeout;
 ULONG BroadcastCapacityResolution;
 SYSTEM_POWER_LEVEL DischargePolicy[4];
 ULONG VideoTimeout;
 BOOLEAN VideoDimDisplay;
 ULONG VideoReserved[3];
 ULONG SpindownTimeout;
 BOOLEAN OptimizeForPower;
 UCHAR FanThrottleTolerance;
 UCHAR ForcedThrottle;
 UCHAR MinThrottle;
 POWER_ACTION_POLICY OverThrottled;
} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;

typedef struct _SYSTEM_POWER_CAPABILITIES {
 BOOLEAN PowerButtonPresent;
 BOOLEAN SleepButtonPresent;
 BOOLEAN LidPresent;
 BOOLEAN SystemS1;
 BOOLEAN SystemS2;
 BOOLEAN SystemS3;
 BOOLEAN SystemS4;
 BOOLEAN SystemS5;
 BOOLEAN HiberFilePresent;
 BOOLEAN FullWake;
 BOOLEAN VideoDimPresent;
 BOOLEAN ApmPresent;
 BOOLEAN UpsPresent;
 BOOLEAN ThermalControl;
 BOOLEAN ProcessorThrottle;
 UCHAR ProcessorMinThrottle;
 UCHAR ProcessorMaxThrottle;
 UCHAR spare2[4];
 BOOLEAN DiskSpinDown;
 UCHAR spare3[8];
 BOOLEAN SystemBatteriesPresent;
 BOOLEAN BatteriesAreShortTerm;
 BATTERY_REPORTING_SCALE BatteryScale[3];
 SYSTEM_POWER_STATE AcOnLineWake;
 SYSTEM_POWER_STATE SoftLidWake;
 SYSTEM_POWER_STATE RtcWake;
 SYSTEM_POWER_STATE MinDeviceWakeState;
 SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct _SYSTEM_BATTERY_STATE {
 BOOLEAN AcOnLine;
 BOOLEAN BatteryPresent;
 BOOLEAN Charging;
 BOOLEAN Discharging;
 BOOLEAN Spare1[4];
 ULONG MaxCapacity;
 ULONG RemainingCapacity;
 ULONG Rate;
 ULONG EstimatedTime;
 ULONG DefaultAlert1;
 ULONG DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;

typedef enum _POWER_INFORMATION_LEVEL {
 SystemPowerPolicyAc,
 SystemPowerPolicyDc,
 VerifySystemPolicyAc,
 VerifySystemPolicyDc,
 SystemPowerCapabilities,
 SystemBatteryState,
 SystemPowerStateHandler,
 ProcessorStateHandler,
 SystemPowerPolicyCurrent,
 AdministratorPowerPolicy,
 SystemReserveHiberFile,
 ProcessorInformation,
 SystemPowerInformation,
 ProcessorStateHandler2,
 LastWakeTime,
 LastSleepTime,
 SystemExecutionState,
 SystemPowerStateNotifyHandler,
 ProcessorPowerPolicyAc,
 ProcessorPowerPolicyDc,
 VerifyProcessorPowerPolicyAc,
 VerifyProcessorPowerPolicyDc,
 ProcessorPowerPolicyCurrent
} POWER_INFORMATION_LEVEL;





typedef struct _SYSTEM_POWER_INFORMATION {
 ULONG MaxIdlenessAllowed;
 ULONG Idleness;
 ULONG TimeRemaining;
 UCHAR CoolingMode;
} SYSTEM_POWER_INFORMATION,*PSYSTEM_POWER_INFORMATION;
# 3778 "C:/upp/mingw/include/winnt.h" 3
typedef struct _PROCESSOR_POWER_POLICY_INFO {
 ULONG TimeCheck;
 ULONG DemoteLimit;
 ULONG PromoteLimit;
 UCHAR DemotePercent;
 UCHAR PromotePercent;
 UCHAR Spare[2];
 ULONG AllowDemotion : 1;
 ULONG AllowPromotion : 1;
 ULONG Reserved : 30;
} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;
typedef struct _PROCESSOR_POWER_POLICY {
 ULONG Revision;
 UCHAR DynamicThrottle;
 UCHAR Spare[3];
 ULONG Reserved;
 ULONG PolicyCount;
 PROCESSOR_POWER_POLICY_INFO Policy[3];
} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;
typedef struct _ADMINISTRATOR_POWER_POLICY {
 SYSTEM_POWER_STATE MinSleep;
 SYSTEM_POWER_STATE MaxSleep;
 ULONG MinVideoTimeout;
 ULONG MaxVideoTimeout;
 ULONG MinSpindownTimeout;
 ULONG MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;
# 1 "C:/upp/mingw/include/poppack.h" 1 3

#pragma pack(pop)
# 3806 "C:/upp/mingw/include/winnt.h" 2 3
# 3816 "C:/upp/mingw/include/winnt.h" 3
typedef OSVERSIONINFOA OSVERSIONINFO,*POSVERSIONINFO,*LPOSVERSIONINFO;
typedef OSVERSIONINFOEXA OSVERSIONINFOEX,*POSVERSIONINFOEX,*LPOSVERSIONINFOEX;
# 3831 "C:/upp/mingw/include/winnt.h" 3
static __inline__ PVOID GetCurrentFiber(void)
{
    void* ret;
    __asm__ __volatile__ (
 "mov{l}	{%%fs:0x10,%0|%0,%%fs:0x10}"
 : "=r" (ret)
 );
    return ret;
}

static __inline__ PVOID GetFiberData(void)
{
    void* ret;
    __asm__ __volatile__ (
 "mov{l}	{%%fs:0x10,%0|%0,%%fs:0x10}\n\t"
 "mov{l}	{(%0),%0|%0,[%0]}"
 : "=r" (ret)
 );
    return ret;
}

static __inline__ struct _TEB * NtCurrentTeb(void)
{
    struct _TEB *ret;

    __asm__ __volatile__ (
        "mov{l} {%%fs:0x18,%0|%0,%%fs:0x18}\n"
        : "=r" (ret)
        :
    );

    return ret;
}
# 3927 "C:/upp/mingw/include/winnt.h" 3
}
# 254 "C:/upp/mingw/include/windef.h" 2 3

typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;

typedef LONG HRESULT;



typedef WORD ATOM;

typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
typedef void *HGDIOBJ;
typedef struct HACCEL__{int i;}*HACCEL;
typedef struct HBITMAP__{int i;}*HBITMAP;
typedef struct HBRUSH__{int i;}*HBRUSH;
typedef struct HCOLORSPACE__{int i;}*HCOLORSPACE;
typedef struct HDC__{int i;}*HDC;
typedef struct HGLRC__{int i;}*HGLRC;
typedef struct HDESK__{int i;}*HDESK;
typedef struct HENHMETAFILE__{int i;}*HENHMETAFILE;
typedef struct HFONT__{int i;}*HFONT;
typedef struct HICON__{int i;}*HICON;
typedef struct HKEY__{int i;}*HKEY;

typedef struct HMONITOR__{int i;}*HMONITOR;

typedef struct HTERMINAL__{int i;}*HTERMINAL;
typedef struct HWINEVENTHOOK__{int i;}*HWINEVENTHOOK;

typedef HKEY *PHKEY;
typedef struct HMENU__{int i;}*HMENU;
typedef struct HMETAFILE__{int i;}*HMETAFILE;
typedef struct HINSTANCE__{int i;}*HINSTANCE;
typedef HINSTANCE HMODULE;
typedef struct HPALETTE__{int i;}*HPALETTE;
typedef struct HPEN__{int i;}*HPEN;
typedef struct HRGN__{int i;}*HRGN;
typedef struct HRSRC__{int i;}*HRSRC;
typedef struct HSTR__{int i;}*HSTR;
typedef struct HTASK__{int i;}*HTASK;
typedef struct HWND__{int i;}*HWND;
typedef struct HWINSTA__{int i;}*HWINSTA;
typedef struct HKL__{int i;}*HKL;
typedef int HFILE;
typedef HICON HCURSOR;
typedef DWORD COLORREF;
typedef int (__attribute__((__stdcall__)) *FARPROC)();
typedef int (__attribute__((__stdcall__)) *NEARPROC)();
typedef int (__attribute__((__stdcall__)) *PROC)();
typedef struct tagRECT {
 LONG left;
 LONG top;
 LONG right;
 LONG bottom;
} RECT,*PRECT,*LPRECT;
typedef const RECT *LPCRECT;
typedef struct tagRECTL {
 LONG left;
 LONG top;
 LONG right;
 LONG bottom;
} RECTL,*PRECTL,*LPRECTL;
typedef const RECTL *LPCRECTL;
typedef struct tagPOINT {
 LONG x;
 LONG y;
} POINT,POINTL,*PPOINT,*LPPOINT,*PPOINTL,*LPPOINTL;
typedef struct tagSIZE {
 LONG cx;
 LONG cy;
} SIZE,SIZEL,*PSIZE,*LPSIZE,*PSIZEL,*LPSIZEL;
typedef struct tagPOINTS {
 SHORT x;
 SHORT y;
} POINTS,*PPOINTS,*LPPOINTS;


}
# 49 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/wincon.h" 1 3



       
# 5 "C:/upp/mingw/include/wincon.h" 3



extern "C" {
# 62 "C:/upp/mingw/include/wincon.h" 3
typedef struct _CHAR_INFO {
 union {
  WCHAR UnicodeChar;
  CHAR AsciiChar;
 } Char;
 WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;
typedef struct _SMALL_RECT {
 SHORT Left;
 SHORT Top;
 SHORT Right;
 SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;
typedef struct _CONSOLE_CURSOR_INFO {
 DWORD dwSize;
 BOOL bVisible;
} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;
typedef struct _COORD {
 SHORT X;
 SHORT Y;
} COORD, *PCOORD;
typedef struct _CONSOLE_FONT_INFO {
 DWORD nFont;
 COORD dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
 COORD dwSize;
 COORD dwCursorPosition;
 WORD wAttributes;
 SMALL_RECT srWindow;
 COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;
typedef BOOL(__attribute__((__stdcall__)) *PHANDLER_ROUTINE)(DWORD);
typedef struct _KEY_EVENT_RECORD {
 BOOL bKeyDown;
 WORD wRepeatCount;
 WORD wVirtualKeyCode;
 WORD wVirtualScanCode;
 union {
  WCHAR UnicodeChar;
  CHAR AsciiChar;
 } uChar;
 DWORD dwControlKeyState;
}


 __attribute__((packed))

KEY_EVENT_RECORD;

typedef struct _MOUSE_EVENT_RECORD {
 COORD dwMousePosition;
 DWORD dwButtonState;
 DWORD dwControlKeyState;
 DWORD dwEventFlags;
} MOUSE_EVENT_RECORD;
typedef struct _WINDOW_BUFFER_SIZE_RECORD { COORD dwSize; } WINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD { UINT dwCommandId; } MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;
typedef struct _FOCUS_EVENT_RECORD { BOOL bSetFocus; } FOCUS_EVENT_RECORD;
typedef struct _INPUT_RECORD {
 WORD EventType;
 union {
  KEY_EVENT_RECORD KeyEvent;
  MOUSE_EVENT_RECORD MouseEvent;
  WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
  MENU_EVENT_RECORD MenuEvent;
  FOCUS_EVENT_RECORD FocusEvent;
 } Event;
} INPUT_RECORD,*PINPUT_RECORD;

BOOL __attribute__((__stdcall__)) AllocConsole(void);




HANDLE __attribute__((__stdcall__)) CreateConsoleScreenBuffer(DWORD,DWORD,const SECURITY_ATTRIBUTES*,DWORD,LPVOID);
BOOL __attribute__((__stdcall__)) FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FillConsoleOutputCharacterA(HANDLE,CHAR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FlushConsoleInputBuffer(HANDLE);
BOOL __attribute__((__stdcall__)) FreeConsole(void);
BOOL __attribute__((__stdcall__)) GenerateConsoleCtrlEvent(DWORD,DWORD);
UINT __attribute__((__stdcall__)) GetConsoleCP(void);
BOOL __attribute__((__stdcall__)) GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);
BOOL __attribute__((__stdcall__)) GetConsoleMode(HANDLE,PDWORD);
UINT __attribute__((__stdcall__)) GetConsoleOutputCP(void);
BOOL __attribute__((__stdcall__)) GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);
DWORD __attribute__((__stdcall__)) GetConsoleTitleA(LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) GetConsoleTitleW(LPWSTR,DWORD);







COORD __attribute__((__stdcall__)) GetLargestConsoleWindowSize(HANDLE);
BOOL __attribute__((__stdcall__)) GetNumberOfConsoleInputEvents(HANDLE,PDWORD);
BOOL __attribute__((__stdcall__)) GetNumberOfConsoleMouseButtons(PDWORD);
BOOL __attribute__((__stdcall__)) PeekConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleA(HANDLE,PVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) ReadConsoleW(HANDLE,PVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) ReadConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputA(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) ScrollConsoleScreenBufferA(HANDLE,const SMALL_RECT*,const SMALL_RECT*,COORD,const CHAR_INFO*);
BOOL __attribute__((__stdcall__)) ScrollConsoleScreenBufferW(HANDLE,const SMALL_RECT*,const SMALL_RECT*,COORD,const CHAR_INFO*);
BOOL __attribute__((__stdcall__)) SetConsoleActiveScreenBuffer(HANDLE);
BOOL __attribute__((__stdcall__)) SetConsoleCP(UINT);
BOOL __attribute__((__stdcall__)) SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);
BOOL __attribute__((__stdcall__)) SetConsoleCursorInfo(HANDLE,const CONSOLE_CURSOR_INFO*);
BOOL __attribute__((__stdcall__)) SetConsoleCursorPosition(HANDLE,COORD);



BOOL __attribute__((__stdcall__)) SetConsoleMode(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) SetConsoleOutputCP(UINT);
BOOL __attribute__((__stdcall__)) SetConsoleScreenBufferSize(HANDLE,COORD);
BOOL __attribute__((__stdcall__)) SetConsoleTextAttribute(HANDLE,WORD);
BOOL __attribute__((__stdcall__)) SetConsoleTitleA(LPCSTR);
BOOL __attribute__((__stdcall__)) SetConsoleTitleW(LPCWSTR);
BOOL __attribute__((__stdcall__)) SetConsoleWindowInfo(HANDLE,BOOL,const SMALL_RECT*);
BOOL __attribute__((__stdcall__)) WriteConsoleA(HANDLE,PCVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) WriteConsoleW(HANDLE,PCVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) WriteConsoleInputA(HANDLE,const INPUT_RECORD*,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleInputW(HANDLE,const INPUT_RECORD*,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputA(HANDLE,const CHAR_INFO*,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputW(HANDLE,const CHAR_INFO*,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputAttribute(HANDLE,const WORD*,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputCharacterA(HANDLE,LPCSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,PDWORD);
# 230 "C:/upp/mingw/include/wincon.h" 3
}
# 50 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/winbase.h" 1 3



       
# 5 "C:/upp/mingw/include/winbase.h" 3
# 24 "C:/upp/mingw/include/winbase.h" 3
extern "C" {
# 569 "C:/upp/mingw/include/winbase.h" 3
typedef struct _FILETIME {
 DWORD dwLowDateTime;
 DWORD dwHighDateTime;
} FILETIME,*PFILETIME,*LPFILETIME;
typedef struct _BY_HANDLE_FILE_INFORMATION {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD dwVolumeSerialNumber;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
 DWORD nNumberOfLinks;
 DWORD nFileIndexHigh;
 DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;
typedef struct _DCB {
 DWORD DCBlength;
 DWORD BaudRate;
 DWORD fBinary:1;
 DWORD fParity:1;
 DWORD fOutxCtsFlow:1;
 DWORD fOutxDsrFlow:1;
 DWORD fDtrControl:2;
 DWORD fDsrSensitivity:1;
 DWORD fTXContinueOnXoff:1;
 DWORD fOutX:1;
 DWORD fInX:1;
 DWORD fErrorChar:1;
 DWORD fNull:1;
 DWORD fRtsControl:2;
 DWORD fAbortOnError:1;
 DWORD fDummy2:17;
 WORD wReserved;
 WORD XonLim;
 WORD XoffLim;
 BYTE ByteSize;
 BYTE Parity;
 BYTE StopBits;
 char XonChar;
 char XoffChar;
 char ErrorChar;
 char EofChar;
 char EvtChar;
 WORD wReserved1;
} DCB,*LPDCB;
typedef struct _COMM_CONFIG {
 DWORD dwSize;
 WORD wVersion;
 WORD wReserved;
 DCB dcb;
 DWORD dwProviderSubType;
 DWORD dwProviderOffset;
 DWORD dwProviderSize;
 WCHAR wcProviderData[1];
} COMMCONFIG,*LPCOMMCONFIG;
typedef struct _COMMPROP {
 WORD wPacketLength;
 WORD wPacketVersion;
 DWORD dwServiceMask;
 DWORD dwReserved1;
 DWORD dwMaxTxQueue;
 DWORD dwMaxRxQueue;
 DWORD dwMaxBaud;
 DWORD dwProvSubType;
 DWORD dwProvCapabilities;
 DWORD dwSettableParams;
 DWORD dwSettableBaud;
 WORD wSettableData;
 WORD wSettableStopParity;
 DWORD dwCurrentTxQueue;
 DWORD dwCurrentRxQueue;
 DWORD dwProvSpec1;
 DWORD dwProvSpec2;
 WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;
typedef struct _COMMTIMEOUTS {
 DWORD ReadIntervalTimeout;
 DWORD ReadTotalTimeoutMultiplier;
 DWORD ReadTotalTimeoutConstant;
 DWORD WriteTotalTimeoutMultiplier;
 DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;
typedef struct _COMSTAT {
 DWORD fCtsHold:1;
 DWORD fDsrHold:1;
 DWORD fRlsdHold:1;
 DWORD fXoffHold:1;
 DWORD fXoffSent:1;
 DWORD fEof:1;
 DWORD fTxim:1;
 DWORD fReserved:25;
 DWORD cbInQue;
 DWORD cbOutQue;
} COMSTAT,*LPCOMSTAT;
typedef DWORD (__attribute__((__stdcall__)) *LPTHREAD_START_ROUTINE)(LPVOID);
typedef struct _CREATE_PROCESS_DEBUG_INFO {
 HANDLE hFile;
 HANDLE hProcess;
 HANDLE hThread;
 LPVOID lpBaseOfImage;
 DWORD dwDebugInfoFileOffset;
 DWORD nDebugInfoSize;
 LPVOID lpThreadLocalBase;
 LPTHREAD_START_ROUTINE lpStartAddress;
 LPVOID lpImageName;
 WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO,*LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
 HANDLE hThread;
 LPVOID lpThreadLocalBase;
 LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO,*LPCREATE_THREAD_DEBUG_INFO;
typedef struct _EXCEPTION_DEBUG_INFO {
 EXCEPTION_RECORD ExceptionRecord;
 DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO,*LPEXCEPTION_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
 DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO,*LPEXIT_THREAD_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
 DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO,*LPEXIT_PROCESS_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
 HANDLE hFile;
 LPVOID lpBaseOfDll;
 DWORD dwDebugInfoFileOffset;
 DWORD nDebugInfoSize;
 LPVOID lpImageName;
 WORD fUnicode;
} LOAD_DLL_DEBUG_INFO,*LPLOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
 LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO,*LPUNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
 LPSTR lpDebugStringData;
 WORD fUnicode;
 WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO,*LPOUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
 DWORD dwError;
 DWORD dwType;
} RIP_INFO,*LPRIP_INFO;
typedef struct _DEBUG_EVENT {
 DWORD dwDebugEventCode;
 DWORD dwProcessId;
 DWORD dwThreadId;
 union {
  EXCEPTION_DEBUG_INFO Exception;
  CREATE_THREAD_DEBUG_INFO CreateThread;
  CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
  EXIT_THREAD_DEBUG_INFO ExitThread;
  EXIT_PROCESS_DEBUG_INFO ExitProcess;
  LOAD_DLL_DEBUG_INFO LoadDll;
  UNLOAD_DLL_DEBUG_INFO UnloadDll;
  OUTPUT_DEBUG_STRING_INFO DebugString;
  RIP_INFO RipInfo;
 } u;
} DEBUG_EVENT,*LPDEBUG_EVENT;
typedef struct _OVERLAPPED {
 ULONG_PTR Internal;
 ULONG_PTR InternalHigh;
 DWORD Offset;
 DWORD OffsetHigh;
 HANDLE hEvent;
} OVERLAPPED,*POVERLAPPED,*LPOVERLAPPED;
typedef struct _STARTUPINFOA {
 DWORD cb;
 LPSTR lpReserved;
 LPSTR lpDesktop;
 LPSTR lpTitle;
 DWORD dwX;
 DWORD dwY;
 DWORD dwXSize;
 DWORD dwYSize;
 DWORD dwXCountChars;
 DWORD dwYCountChars;
 DWORD dwFillAttribute;
 DWORD dwFlags;
 WORD wShowWindow;
 WORD cbReserved2;
 PBYTE lpReserved2;
 HANDLE hStdInput;
 HANDLE hStdOutput;
 HANDLE hStdError;
} STARTUPINFOA,*LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
 DWORD cb;
 LPWSTR lpReserved;
 LPWSTR lpDesktop;
 LPWSTR lpTitle;
 DWORD dwX;
 DWORD dwY;
 DWORD dwXSize;
 DWORD dwYSize;
 DWORD dwXCountChars;
 DWORD dwYCountChars;
 DWORD dwFillAttribute;
 DWORD dwFlags;
 WORD wShowWindow;
 WORD cbReserved2;
 PBYTE lpReserved2;
 HANDLE hStdInput;
 HANDLE hStdOutput;
 HANDLE hStdError;
} STARTUPINFOW,*LPSTARTUPINFOW;
typedef struct _PROCESS_INFORMATION {
 HANDLE hProcess;
 HANDLE hThread;
 DWORD dwProcessId;
 DWORD dwThreadId;
} PROCESS_INFORMATION,*PPROCESS_INFORMATION,*LPPROCESS_INFORMATION;
typedef struct _CRITICAL_SECTION_DEBUG {
 WORD Type;
 WORD CreatorBackTraceIndex;
 struct _CRITICAL_SECTION *CriticalSection;
 LIST_ENTRY ProcessLocksList;
 DWORD EntryCount;
 DWORD ContentionCount;
 DWORD Spare [2];
} CRITICAL_SECTION_DEBUG,*PCRITICAL_SECTION_DEBUG;
typedef struct _CRITICAL_SECTION {
 PCRITICAL_SECTION_DEBUG DebugInfo;
 LONG LockCount;
 LONG RecursionCount;
 HANDLE OwningThread;
 HANDLE LockSemaphore;
 DWORD SpinCount;
} CRITICAL_SECTION,*PCRITICAL_SECTION,*LPCRITICAL_SECTION;
typedef struct _SYSTEMTIME {
 WORD wYear;
 WORD wMonth;
 WORD wDayOfWeek;
 WORD wDay;
 WORD wHour;
 WORD wMinute;
 WORD wSecond;
 WORD wMilliseconds;
} SYSTEMTIME,*LPSYSTEMTIME;
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;
typedef struct _WIN32_FIND_DATAA {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;



 DWORD dwReserved0;
 DWORD dwReserved1;

 CHAR cFileName[260];

 CHAR cAlternateFileName[14];

} WIN32_FIND_DATAA,*PWIN32_FIND_DATAA,*LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;



 DWORD dwReserved0;
 DWORD dwReserved1;

 WCHAR cFileName[260];

 WCHAR cAlternateFileName[14];

} WIN32_FIND_DATAW,*PWIN32_FIND_DATAW,*LPWIN32_FIND_DATAW;
typedef struct _WIN32_STREAM_ID {
 DWORD dwStreamId;
 DWORD dwStreamAttributes;
 LARGE_INTEGER Size;
 DWORD dwStreamNameSize;
 WCHAR cStreamName[1];
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID;
typedef enum _FINDEX_INFO_LEVELS {
 FindExInfoStandard,
 FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS {
 FindExSearchNameMatch,
 FindExSearchLimitToDirectories,
 FindExSearchLimitToDevices,
 FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
typedef enum _ACL_INFORMATION_CLASS {
 AclRevisionInformation=1,
 AclSizeInformation
} ACL_INFORMATION_CLASS;
typedef struct tagHW_PROFILE_INFOA {
 DWORD dwDockInfo;
 CHAR szHwProfileGuid[39];
 CHAR szHwProfileName[80];
} HW_PROFILE_INFOA,*LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
 DWORD dwDockInfo;
 WCHAR szHwProfileGuid[39];
 WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW,*LPHW_PROFILE_INFOW;
typedef enum _GET_FILEEX_INFO_LEVELS {
 GetFileExInfoStandard,
 GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;
typedef struct _SYSTEM_INFO {
 __extension__ union {
  DWORD dwOemId;
  __extension__ struct {
   WORD wProcessorArchitecture;
   WORD wReserved;
  } ;
 } ;
 DWORD dwPageSize;
 PVOID lpMinimumApplicationAddress;
 PVOID lpMaximumApplicationAddress;
 DWORD dwActiveProcessorMask;
 DWORD dwNumberOfProcessors;
 DWORD dwProcessorType;
 DWORD dwAllocationGranularity;
 WORD wProcessorLevel;
 WORD wProcessorRevision;
} SYSTEM_INFO,*LPSYSTEM_INFO;
typedef struct _SYSTEM_POWER_STATUS {
 BYTE ACLineStatus;
 BYTE BatteryFlag;
 BYTE BatteryLifePercent;
 BYTE Reserved1;
 DWORD BatteryLifeTime;
 DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS,*LPSYSTEM_POWER_STATUS;
typedef struct _TIME_ZONE_INFORMATION {
 LONG Bias;
 WCHAR StandardName[32];
 SYSTEMTIME StandardDate;
 LONG StandardBias;
 WCHAR DaylightName[32];
 SYSTEMTIME DaylightDate;
 LONG DaylightBias;
} TIME_ZONE_INFORMATION,*LPTIME_ZONE_INFORMATION;
typedef struct _MEMORYSTATUS {
 DWORD dwLength;
 DWORD dwMemoryLoad;
 DWORD dwTotalPhys;
 DWORD dwAvailPhys;
 DWORD dwTotalPageFile;
 DWORD dwAvailPageFile;
 DWORD dwTotalVirtual;
 DWORD dwAvailVirtual;
} MEMORYSTATUS,*LPMEMORYSTATUS;
# 945 "C:/upp/mingw/include/winbase.h" 3
typedef struct _LDT_ENTRY {
 WORD LimitLow;
 WORD BaseLow;
 union {
  struct {
   BYTE BaseMid;
   BYTE Flags1;
   BYTE Flags2;
   BYTE BaseHi;
  } Bytes;
  struct {
   DWORD BaseMid:8;
   DWORD Type:5;
   DWORD Dpl:2;
   DWORD Pres:1;
   DWORD LimitHi:4;
   DWORD Sys:1;
   DWORD Reserved_0:1;
   DWORD Default_Big:1;
   DWORD Granularity:1;
   DWORD BaseHi:8;
  } Bits;
 } HighWord;
} LDT_ENTRY,*PLDT_ENTRY,*LPLDT_ENTRY;
typedef struct _PROCESS_HEAP_ENTRY {
 PVOID lpData;
 DWORD cbData;
 BYTE cbOverhead;
 BYTE iRegionIndex;
 WORD wFlags;
 __extension__ union {
  struct {
   HANDLE hMem;
   DWORD dwReserved[3];
  } Block;
  struct {
   DWORD dwCommittedSize;
   DWORD dwUnCommittedSize;
   LPVOID lpFirstBlock;
   LPVOID lpLastBlock;
  } Region;
 } ;
} PROCESS_HEAP_ENTRY,*LPPROCESS_HEAP_ENTRY;
typedef struct _OFSTRUCT {
 BYTE cBytes;
 BYTE fFixedDisk;
 WORD nErrCode;
 WORD Reserved1;
 WORD Reserved2;
 CHAR szPathName[128];
} OFSTRUCT,*LPOFSTRUCT,*POFSTRUCT;
typedef struct _WIN_CERTIFICATE {
      DWORD dwLength;
      WORD wRevision;
      WORD wCertificateType;
      BYTE bCertificate[1];
} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;
# 1062 "C:/upp/mingw/include/winbase.h" 3
typedef DWORD(__attribute__((__stdcall__)) *LPPROGRESS_ROUTINE)(LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,DWORD,DWORD,HANDLE,HANDLE,LPVOID);
typedef void(__attribute__((__stdcall__)) *LPFIBER_START_ROUTINE)(PVOID);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESLANGPROCA)(HMODULE,LPCSTR,LPCSTR,WORD,LONG);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESLANGPROCW)(HMODULE,LPCWSTR,LPCWSTR,WORD,LONG);





typedef BOOL(__attribute__((__stdcall__)) *ENUMRESNAMEPROCA)(HMODULE,LPCSTR,LPSTR,LONG);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESNAMEPROCW)(HMODULE,LPCWSTR,LPWSTR,LONG);





typedef BOOL(__attribute__((__stdcall__)) *ENUMRESTYPEPROCA)(HMODULE,LPSTR,LONG);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESTYPEPROCW)(HMODULE,LPWSTR,LONG);





typedef void(__attribute__((__stdcall__)) *LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD,DWORD,LPOVERLAPPED);
typedef LONG(__attribute__((__stdcall__)) *PTOP_LEVEL_EXCEPTION_FILTER)(LPEXCEPTION_POINTERS);
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
typedef void(__attribute__((__stdcall__)) *PAPCFUNC)(ULONG_PTR);
typedef void(__attribute__((__stdcall__)) *PTIMERAPCROUTINE)(PVOID,DWORD,DWORD);






int __attribute__((__stdcall__)) WinMain(HINSTANCE,HINSTANCE,LPSTR,int);



int __attribute__((__stdcall__)) wWinMain(HINSTANCE,HINSTANCE,LPWSTR,int);
 long __attribute__((__stdcall__)) _hread(HFILE,LPVOID,long);
 long __attribute__((__stdcall__)) _hwrite(HFILE,LPCSTR,long);
 HFILE __attribute__((__stdcall__)) _lclose(HFILE);
 HFILE __attribute__((__stdcall__)) _lcreat(LPCSTR,int);
 LONG __attribute__((__stdcall__)) _llseek(HFILE,LONG,int);
 HFILE __attribute__((__stdcall__)) _lopen(LPCSTR,int);
 UINT __attribute__((__stdcall__)) _lread(HFILE,LPVOID,UINT);
 UINT __attribute__((__stdcall__)) _lwrite(HFILE,LPCSTR,UINT);

 BOOL __attribute__((__stdcall__)) AccessCheck(PSECURITY_DESCRIPTOR,HANDLE,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,PDWORD,PDWORD,PBOOL);
 BOOL __attribute__((__stdcall__)) AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,PDWORD,PBOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,PDWORD,PBOOL,PBOOL);



 BOOL __attribute__((__stdcall__)) AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
 BOOL __attribute__((__stdcall__)) AddAccessDeniedAce(PACL,DWORD,DWORD,PSID);




 BOOL __attribute__((__stdcall__)) AddAce(PACL,DWORD,DWORD,PVOID,DWORD);
 ATOM __attribute__((__stdcall__)) AddAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) AddAtomW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) AddAuditAccessAce(PACL,DWORD,DWORD,PSID,BOOL,BOOL);






 BOOL __attribute__((__stdcall__)) AdjustTokenGroups(HANDLE,BOOL,PTOKEN_GROUPS,DWORD,PTOKEN_GROUPS,PDWORD);
 BOOL __attribute__((__stdcall__)) AdjustTokenPrivileges(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);
 BOOL __attribute__((__stdcall__)) AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID*);
 BOOL __attribute__((__stdcall__)) AllocateLocallyUniqueId(PLUID);
 BOOL __attribute__((__stdcall__)) AreAllAccessesGranted(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) AreAnyAccessesGranted(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) AreFileApisANSI(void);
 BOOL __attribute__((__stdcall__)) BackupEventLogA(HANDLE,LPCSTR);
 BOOL __attribute__((__stdcall__)) BackupEventLogW(HANDLE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) BackupRead(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID*);
 BOOL __attribute__((__stdcall__)) BackupSeek(HANDLE,DWORD,DWORD,LPDWORD,LPDWORD,LPVOID*);
 BOOL __attribute__((__stdcall__)) BackupWrite(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID*);
 BOOL __attribute__((__stdcall__)) Beep(DWORD,DWORD);
 HANDLE __attribute__((__stdcall__)) BeginUpdateResourceA(LPCSTR,BOOL);
 HANDLE __attribute__((__stdcall__)) BeginUpdateResourceW(LPCWSTR,BOOL);
 BOOL __attribute__((__stdcall__)) BuildCommDCBA(LPCSTR,LPDCB);
 BOOL __attribute__((__stdcall__)) BuildCommDCBW(LPCWSTR,LPDCB);
 BOOL __attribute__((__stdcall__)) BuildCommDCBAndTimeoutsA(LPCSTR,LPDCB,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) BuildCommDCBAndTimeoutsW(LPCWSTR,LPDCB,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) CallNamedPipeA(LPCSTR,PVOID,DWORD,PVOID,DWORD,PDWORD,DWORD);
 BOOL __attribute__((__stdcall__)) CallNamedPipeW(LPCWSTR,PVOID,DWORD,PVOID,DWORD,PDWORD,DWORD);
 BOOL __attribute__((__stdcall__)) CancelDeviceWakeupRequest(HANDLE);
 BOOL __attribute__((__stdcall__)) CancelIo(HANDLE);
 BOOL __attribute__((__stdcall__)) CancelWaitableTimer(HANDLE);
# 1167 "C:/upp/mingw/include/winbase.h" 3
 BOOL __attribute__((__stdcall__)) ClearCommBreak(HANDLE);
 BOOL __attribute__((__stdcall__)) ClearCommError(HANDLE,PDWORD,LPCOMSTAT);
 BOOL __attribute__((__stdcall__)) ClearEventLogA(HANDLE,LPCSTR);
 BOOL __attribute__((__stdcall__)) ClearEventLogW(HANDLE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) CloseEventLog(HANDLE);
 BOOL __attribute__((__stdcall__)) CloseHandle(HANDLE);
 BOOL __attribute__((__stdcall__)) CommConfigDialogA(LPCSTR,HWND,LPCOMMCONFIG);
 BOOL __attribute__((__stdcall__)) CommConfigDialogW(LPCWSTR,HWND,LPCOMMCONFIG);
 LONG __attribute__((__stdcall__)) CompareFileTime(const FILETIME*,const FILETIME*);
 BOOL __attribute__((__stdcall__)) ConnectNamedPipe(HANDLE,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ContinueDebugEvent(DWORD,DWORD,DWORD);

 BOOL __attribute__((__stdcall__)) ConvertFiberToThread(void);

 PVOID __attribute__((__stdcall__)) ConvertThreadToFiber(PVOID);
 BOOL __attribute__((__stdcall__)) CopyFileA(LPCSTR,LPCSTR,BOOL);
 BOOL __attribute__((__stdcall__)) CopyFileW(LPCWSTR,LPCWSTR,BOOL);
 BOOL __attribute__((__stdcall__)) CopyFileExA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
 BOOL __attribute__((__stdcall__)) CopyFileExW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
# 1194 "C:/upp/mingw/include/winbase.h" 3
 BOOL __attribute__((__stdcall__)) CopySid(DWORD,PSID,PSID);




 BOOL __attribute__((__stdcall__)) CreateDirectoryA(LPCSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryW(LPCWSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryExA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryExW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);
 LPVOID __attribute__((__stdcall__)) CreateFiber(SIZE_T,LPFIBER_START_ROUTINE,LPVOID);

 LPVOID __attribute__((__stdcall__)) CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_ROUTINE,LPVOID);

 HANDLE __attribute__((__stdcall__)) CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 HANDLE __attribute__((__stdcall__)) CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 HANDLE __attribute__((__stdcall__)) CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);




 HANDLE __attribute__((__stdcall__)) CreateIoCompletionPort(HANDLE,HANDLE,ULONG_PTR,DWORD);
# 1226 "C:/upp/mingw/include/winbase.h" 3
 HANDLE __attribute__((__stdcall__)) CreateMailslotA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateMailslotW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);



 HANDLE __attribute__((__stdcall__)) CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) CreateNamedPipeA(LPCSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateNamedPipeW(LPCWSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);
 BOOL __attribute__((__stdcall__)) CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR*,BOOL,HANDLE,PGENERIC_MAPPING);
 BOOL __attribute__((__stdcall__)) CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessAsUserA(HANDLE,LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessAsUserW(HANDLE,LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
# 1249 "C:/upp/mingw/include/winbase.h" 3
 HANDLE __attribute__((__stdcall__)) CreateRemoteThread(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
 HANDLE __attribute__((__stdcall__)) CreateSemaphoreA(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateSemaphoreW(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCWSTR);
 DWORD __attribute__((__stdcall__)) CreateTapePartition(HANDLE,DWORD,DWORD,DWORD);




 HANDLE __attribute__((__stdcall__)) CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,PVOID,DWORD,PDWORD);
 HANDLE __attribute__((__stdcall__)) CreateWaitableTimerA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateWaitableTimerW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);



 BOOL __attribute__((__stdcall__)) DebugActiveProcess(DWORD);



 void __attribute__((__stdcall__)) DebugBreak(void);




 BOOL __attribute__((__stdcall__)) DefineDosDeviceA(DWORD,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) DefineDosDeviceW(DWORD,LPCWSTR,LPCWSTR);

 BOOL __attribute__((__stdcall__)) DeleteAce(PACL,DWORD);
 ATOM __attribute__((__stdcall__)) DeleteAtom(ATOM);
 void __attribute__((__stdcall__)) DeleteCriticalSection(PCRITICAL_SECTION);
 void __attribute__((__stdcall__)) DeleteFiber(PVOID);
 BOOL __attribute__((__stdcall__)) DeleteFileA(LPCSTR);
 BOOL __attribute__((__stdcall__)) DeleteFileW(LPCWSTR);







 BOOL __attribute__((__stdcall__)) DeregisterEventSource(HANDLE);
 BOOL __attribute__((__stdcall__)) DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR*);
 BOOL __attribute__((__stdcall__)) DeviceIoControl(HANDLE,DWORD,PVOID,DWORD,PVOID,DWORD,PDWORD,POVERLAPPED);
 BOOL __attribute__((__stdcall__)) DisableThreadLibraryCalls(HMODULE);




 BOOL __attribute__((__stdcall__)) DisconnectNamedPipe(HANDLE);
 BOOL __attribute__((__stdcall__)) DosDateTimeToFileTime(WORD,WORD,LPFILETIME);
 BOOL __attribute__((__stdcall__)) DuplicateHandle(HANDLE,HANDLE,HANDLE,PHANDLE,DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) DuplicateToken(HANDLE,SECURITY_IMPERSONATION_LEVEL,PHANDLE);
 BOOL __attribute__((__stdcall__)) DuplicateTokenEx(HANDLE,DWORD,LPSECURITY_ATTRIBUTES,SECURITY_IMPERSONATION_LEVEL,TOKEN_TYPE,PHANDLE);
 BOOL __attribute__((__stdcall__)) EncryptFileA(LPCSTR);
 BOOL __attribute__((__stdcall__)) EncryptFileW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) EndUpdateResourceA(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) EndUpdateResourceW(HANDLE,BOOL);
 void __attribute__((__stdcall__)) EnterCriticalSection(LPCRITICAL_SECTION);
 BOOL __attribute__((__stdcall__)) EnumResourceLanguagesA(HMODULE,LPCSTR,LPCSTR,ENUMRESLANGPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceLanguagesW(HMODULE,LPCWSTR,LPCWSTR,ENUMRESLANGPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceNamesA(HMODULE,LPCSTR,ENUMRESNAMEPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceNamesW(HMODULE,LPCWSTR,ENUMRESNAMEPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceTypesA(HMODULE,ENUMRESTYPEPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceTypesW(HMODULE,ENUMRESTYPEPROCA,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EqualPrefixSid(PSID,PSID);
 BOOL __attribute__((__stdcall__)) EqualSid(PSID,PSID);
 DWORD __attribute__((__stdcall__)) EraseTape(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) EscapeCommFunction(HANDLE,DWORD);
__attribute__((noreturn)) void __attribute__((__stdcall__)) ExitProcess(UINT);
__attribute__((noreturn)) void __attribute__((__stdcall__)) ExitThread(DWORD);
 DWORD __attribute__((__stdcall__)) ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);
 void __attribute__((__stdcall__)) FatalAppExitA(UINT,LPCSTR);
 void __attribute__((__stdcall__)) FatalAppExitW(UINT,LPCWSTR);
 void __attribute__((__stdcall__)) FatalExit(int);
 BOOL __attribute__((__stdcall__)) FileEncryptionStatusA(LPCSTR,LPDWORD);
 BOOL __attribute__((__stdcall__)) FileEncryptionStatusW(LPCWSTR,LPDWORD);
 BOOL __attribute__((__stdcall__)) FileTimeToDosDateTime(const FILETIME *,LPWORD,LPWORD);
 BOOL __attribute__((__stdcall__)) FileTimeToLocalFileTime(const FILETIME *,LPFILETIME);
 BOOL __attribute__((__stdcall__)) FileTimeToSystemTime(const FILETIME *,LPSYSTEMTIME);





 ATOM __attribute__((__stdcall__)) FindAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) FindAtomW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) FindClose(HANDLE);
 BOOL __attribute__((__stdcall__)) FindCloseChangeNotification(HANDLE);
 HANDLE __attribute__((__stdcall__)) FindFirstChangeNotificationA(LPCSTR,BOOL,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstChangeNotificationW(LPCWSTR,BOOL,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstFileA(LPCSTR,LPWIN32_FIND_DATAA);
 HANDLE __attribute__((__stdcall__)) FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);
 HANDLE __attribute__((__stdcall__)) FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) FindFirstFreeAce(PACL,PVOID*);






 BOOL __attribute__((__stdcall__)) FindNextChangeNotification(HANDLE);
 BOOL __attribute__((__stdcall__)) FindNextFileA(HANDLE,LPWIN32_FIND_DATAA);
 BOOL __attribute__((__stdcall__)) FindNextFileW(HANDLE,LPWIN32_FIND_DATAW);
# 1361 "C:/upp/mingw/include/winbase.h" 3
 HRSRC __attribute__((__stdcall__)) FindResourceA(HMODULE,LPCSTR,LPCSTR);
 HRSRC __attribute__((__stdcall__)) FindResourceW(HINSTANCE,LPCWSTR,LPCWSTR);
 HRSRC __attribute__((__stdcall__)) FindResourceExA(HINSTANCE,LPCSTR,LPCSTR,WORD);
 HRSRC __attribute__((__stdcall__)) FindResourceExW(HINSTANCE,LPCWSTR,LPCWSTR,WORD);




 BOOL __attribute__((__stdcall__)) FlushFileBuffers(HANDLE);
 BOOL __attribute__((__stdcall__)) FlushInstructionCache(HANDLE,PCVOID,DWORD);
 BOOL __attribute__((__stdcall__)) FlushViewOfFile(PCVOID,DWORD);
 DWORD __attribute__((__stdcall__)) FormatMessageA(DWORD,PCVOID,DWORD,DWORD,LPSTR,DWORD,va_list*);
 DWORD __attribute__((__stdcall__)) FormatMessageW(DWORD,PCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list*);
 BOOL __attribute__((__stdcall__)) FreeEnvironmentStringsA(LPSTR);
 BOOL __attribute__((__stdcall__)) FreeEnvironmentStringsW(LPWSTR);
 BOOL __attribute__((__stdcall__)) FreeLibrary(HMODULE);
__attribute__((noreturn)) void __attribute__((__stdcall__)) FreeLibraryAndExitThread(HMODULE,DWORD);



 BOOL __attribute__((__stdcall__)) FreeResource(HGLOBAL);

 PVOID __attribute__((__stdcall__)) FreeSid(PSID);
 BOOL __attribute__((__stdcall__)) GetAce(PACL,DWORD,LPVOID*);
 BOOL __attribute__((__stdcall__)) GetAclInformation(PACL,PVOID,DWORD,ACL_INFORMATION_CLASS);
 UINT __attribute__((__stdcall__)) GetAtomNameA(ATOM,LPSTR,int);
 UINT __attribute__((__stdcall__)) GetAtomNameW(ATOM,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) GetBinaryTypeA(LPCSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetBinaryTypeW(LPCWSTR,PDWORD);
 LPSTR __attribute__((__stdcall__)) GetCommandLineA(void);
 LPWSTR __attribute__((__stdcall__)) GetCommandLineW(void);
 BOOL __attribute__((__stdcall__)) GetCommConfig(HANDLE,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommMask(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommModemStatus(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommProperties(HANDLE,LPCOMMPROP);
 BOOL __attribute__((__stdcall__)) GetCommState(HANDLE,LPDCB);
 BOOL __attribute__((__stdcall__)) GetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
 DWORD __attribute__((__stdcall__)) GetCompressedFileSizeA(LPCSTR,PDWORD);
 DWORD __attribute__((__stdcall__)) GetCompressedFileSizeW(LPCWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetComputerNameA(LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetComputerNameW(LPWSTR,PDWORD);







 DWORD __attribute__((__stdcall__)) GetCurrentDirectoryA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetCurrentDirectoryW(DWORD,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetCurrentHwProfileA(LPHW_PROFILE_INFOA);
 BOOL __attribute__((__stdcall__)) GetCurrentHwProfileW(LPHW_PROFILE_INFOW);
 HANDLE __attribute__((__stdcall__)) GetCurrentProcess(void);
 DWORD __attribute__((__stdcall__)) GetCurrentProcessId(void);
 HANDLE __attribute__((__stdcall__)) GetCurrentThread(void);



 DWORD __attribute__((__stdcall__)) GetCurrentThreadId(void);


 BOOL __attribute__((__stdcall__)) GetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDevicePowerState(HANDLE, BOOL*);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceA(LPCSTR,PDWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceW(LPCWSTR,PDWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceExA(LPCSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceExW(LPCWSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);




 UINT __attribute__((__stdcall__)) GetDriveTypeA(LPCSTR);
 UINT __attribute__((__stdcall__)) GetDriveTypeW(LPCWSTR);
 LPSTR __attribute__((__stdcall__)) GetEnvironmentStrings(void);
 LPSTR __attribute__((__stdcall__)) GetEnvironmentStringsA(void);
 LPWSTR __attribute__((__stdcall__)) GetEnvironmentStringsW(void);
 DWORD __attribute__((__stdcall__)) GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetExitCodeProcess(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetExitCodeThread(HANDLE,PDWORD);
 DWORD __attribute__((__stdcall__)) GetFileAttributesA(LPCSTR);
 DWORD __attribute__((__stdcall__)) GetFileAttributesW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,PVOID);
 BOOL __attribute__((__stdcall__)) GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,PVOID);
 BOOL __attribute__((__stdcall__)) GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);
 BOOL __attribute__((__stdcall__)) GetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetFileSize(HANDLE,PDWORD);



 BOOL __attribute__((__stdcall__)) GetFileTime(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetFileType(HANDLE);

 DWORD __attribute__((__stdcall__)) GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR*);
 DWORD __attribute__((__stdcall__)) GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR*);
 BOOL __attribute__((__stdcall__)) GetHandleInformation(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetLastError(void);
 DWORD __attribute__((__stdcall__)) GetLengthSid(PSID);
 void __attribute__((__stdcall__)) GetLocalTime(LPSYSTEMTIME);
 DWORD __attribute__((__stdcall__)) GetLogicalDrives(void);
 DWORD __attribute__((__stdcall__)) GetLogicalDriveStringsA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetLogicalDriveStringsW(DWORD,LPWSTR);




 BOOL __attribute__((__stdcall__)) GetMailslotInfo(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);
 HMODULE __attribute__((__stdcall__)) GetModuleHandleA(LPCSTR);
 HMODULE __attribute__((__stdcall__)) GetModuleHandleW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) GetNamedPipeHandleStateA(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetNamedPipeHandleStateW(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetNamedPipeInfo(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD);



 BOOL __attribute__((__stdcall__)) GetNumberOfEventLogRecords(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetOldestEventLogRecord(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetOverlappedResult(HANDLE,LPOVERLAPPED,PDWORD,BOOL);
 DWORD __attribute__((__stdcall__)) GetPriorityClass(HANDLE);
 BOOL __attribute__((__stdcall__)) GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 UINT __attribute__((__stdcall__)) GetPrivateProfileIntA(LPCSTR,LPCSTR,INT,LPCSTR);
 UINT __attribute__((__stdcall__)) GetPrivateProfileIntW(LPCWSTR,LPCWSTR,INT,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionA(LPCSTR,LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionW(LPCWSTR,LPWSTR,DWORD,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionNamesA(LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionNamesW(LPWSTR,DWORD,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD,LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetPrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) GetPrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
 FARPROC __attribute__((__stdcall__)) GetProcAddress(HINSTANCE,LPCSTR);
 BOOL __attribute__((__stdcall__)) GetProcessAffinityMask(HANDLE,PDWORD,PDWORD);



 HANDLE __attribute__((__stdcall__)) GetProcessHeap(void);
 DWORD __attribute__((__stdcall__)) GetProcessHeaps(DWORD,PHANDLE);






 BOOL __attribute__((__stdcall__)) GetProcessPriorityBoost(HANDLE,PBOOL);
 BOOL __attribute__((__stdcall__)) GetProcessShutdownParameters(PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetProcessTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetProcessVersion(DWORD);
 HWINSTA __attribute__((__stdcall__)) GetProcessWindowStation(void);
 BOOL __attribute__((__stdcall__)) GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);
 UINT __attribute__((__stdcall__)) GetProfileIntA(LPCSTR,LPCSTR,INT);
 UINT __attribute__((__stdcall__)) GetProfileIntW(LPCWSTR,LPCWSTR,INT);
 DWORD __attribute__((__stdcall__)) GetProfileSectionA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileSectionW(LPCWSTR,LPWSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetQueuedCompletionStatus(HANDLE,PDWORD,PULONG_PTR,LPOVERLAPPED*,DWORD);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR_CONTROL,PDWORD);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL*,LPBOOL);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID*,LPBOOL);
 DWORD __attribute__((__stdcall__)) GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID*,LPBOOL);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL*,LPBOOL);
 DWORD __attribute__((__stdcall__)) GetShortPathNameA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetShortPathNameW(LPCWSTR,LPWSTR,DWORD);
 PSID_IDENTIFIER_AUTHORITY __attribute__((__stdcall__)) GetSidIdentifierAuthority(PSID);
 DWORD __attribute__((__stdcall__)) GetSidLengthRequired(UCHAR);
 PDWORD __attribute__((__stdcall__)) GetSidSubAuthority(PSID,DWORD);
 PUCHAR __attribute__((__stdcall__)) GetSidSubAuthorityCount(PSID);
 void __attribute__((__stdcall__)) GetStartupInfoA(LPSTARTUPINFOA);
 void __attribute__((__stdcall__)) GetStartupInfoW(LPSTARTUPINFOW);
 HANDLE __attribute__((__stdcall__)) GetStdHandle(DWORD);
 UINT __attribute__((__stdcall__)) GetSystemDirectoryA(LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetSystemDirectoryW(LPWSTR,UINT);
 void __attribute__((__stdcall__)) GetSystemInfo(LPSYSTEM_INFO);
 BOOL __attribute__((__stdcall__)) GetSystemPowerStatus(LPSYSTEM_POWER_STATUS);



 void __attribute__((__stdcall__)) GetSystemTime(LPSYSTEMTIME);



 BOOL __attribute__((__stdcall__)) GetSystemTimeAdjustment(PDWORD,PDWORD,PBOOL);
 void __attribute__((__stdcall__)) GetSystemTimeAsFileTime(LPFILETIME);
# 1562 "C:/upp/mingw/include/winbase.h" 3
 DWORD __attribute__((__stdcall__)) GetTapeParameters(HANDLE,DWORD,PDWORD,PVOID);
 DWORD __attribute__((__stdcall__)) GetTapePosition(HANDLE,DWORD,PDWORD,PDWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetTapeStatus(HANDLE);
 UINT __attribute__((__stdcall__)) GetTempFileNameA(LPCSTR,LPCSTR,UINT,LPSTR);
 UINT __attribute__((__stdcall__)) GetTempFileNameW(LPCWSTR,LPCWSTR,UINT,LPWSTR);
 DWORD __attribute__((__stdcall__)) GetTempPathA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetTempPathW(DWORD,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetThreadContext(HANDLE,LPCONTEXT);



 int __attribute__((__stdcall__)) GetThreadPriority(HANDLE);
 BOOL __attribute__((__stdcall__)) GetThreadPriorityBoost(HANDLE,PBOOL);
 BOOL __attribute__((__stdcall__)) GetThreadSelectorEntry(HANDLE,DWORD,LPLDT_ENTRY);
 BOOL __attribute__((__stdcall__)) GetThreadTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetTickCount(void);
 DWORD __attribute__((__stdcall__)) GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);
 BOOL __attribute__((__stdcall__)) GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserNameA (LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserNameW(LPWSTR,PDWORD);
 DWORD __attribute__((__stdcall__)) GetVersion(void);
 BOOL __attribute__((__stdcall__)) GetVersionExA(LPOSVERSIONINFOA);
 BOOL __attribute__((__stdcall__)) GetVersionExW(LPOSVERSIONINFOW);
 BOOL __attribute__((__stdcall__)) GetVolumeInformationA(LPCSTR,LPSTR,DWORD,PDWORD,PDWORD,PDWORD,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetVolumeInformationW(LPCWSTR,LPWSTR,DWORD,PDWORD,PDWORD,PDWORD,LPWSTR,DWORD);
# 1597 "C:/upp/mingw/include/winbase.h" 3
 UINT __attribute__((__stdcall__)) GetWindowsDirectoryA(LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetWindowsDirectoryW(LPWSTR,UINT);
 DWORD __attribute__((__stdcall__)) GetWindowThreadProcessId(HWND,PDWORD);
 UINT __attribute__((__stdcall__)) GetWriteWatch(DWORD,PVOID,SIZE_T,PVOID*,PULONG_PTR,PULONG);
 ATOM __attribute__((__stdcall__)) GlobalAddAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) GlobalAddAtomW( LPCWSTR);
 HGLOBAL __attribute__((__stdcall__)) GlobalAlloc(UINT,DWORD);
 SIZE_T __attribute__((__stdcall__)) GlobalCompact(DWORD);
 ATOM __attribute__((__stdcall__)) GlobalDeleteAtom(ATOM);

 ATOM __attribute__((__stdcall__)) GlobalFindAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) GlobalFindAtomW(LPCWSTR);
 void __attribute__((__stdcall__)) GlobalFix(HGLOBAL);
 UINT __attribute__((__stdcall__)) GlobalFlags(HGLOBAL);
 HGLOBAL __attribute__((__stdcall__)) GlobalFree(HGLOBAL);
 UINT __attribute__((__stdcall__)) GlobalGetAtomNameA(ATOM,LPSTR,int);
 UINT __attribute__((__stdcall__)) GlobalGetAtomNameW(ATOM,LPWSTR,int);
 HGLOBAL __attribute__((__stdcall__)) GlobalHandle(PCVOID);
 LPVOID __attribute__((__stdcall__)) GlobalLock(HGLOBAL);
 void __attribute__((__stdcall__)) GlobalMemoryStatus(LPMEMORYSTATUS);



 HGLOBAL __attribute__((__stdcall__)) GlobalReAlloc(HGLOBAL,DWORD,UINT);
 DWORD __attribute__((__stdcall__)) GlobalSize(HGLOBAL);
 void __attribute__((__stdcall__)) GlobalUnfix(HGLOBAL);
 BOOL __attribute__((__stdcall__)) GlobalUnlock(HGLOBAL);
 BOOL __attribute__((__stdcall__)) GlobalUnWire(HGLOBAL);
 PVOID __attribute__((__stdcall__)) GlobalWire(HGLOBAL);

 PVOID __attribute__((__stdcall__)) HeapAlloc(HANDLE,DWORD,DWORD);
SIZE_T __attribute__((__stdcall__)) HeapCompact(HANDLE,DWORD);
 HANDLE __attribute__((__stdcall__)) HeapCreate(DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) HeapDestroy(HANDLE);
 BOOL __attribute__((__stdcall__)) HeapFree(HANDLE,DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) HeapLock(HANDLE);



 PVOID __attribute__((__stdcall__)) HeapReAlloc(HANDLE,DWORD,PVOID,DWORD);



 DWORD __attribute__((__stdcall__)) HeapSize(HANDLE,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) HeapUnlock(HANDLE);
 BOOL __attribute__((__stdcall__)) HeapValidate(HANDLE,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);
 BOOL __attribute__((__stdcall__)) ImpersonateLoggedOnUser(HANDLE);
 BOOL __attribute__((__stdcall__)) ImpersonateNamedPipeClient(HANDLE);
 BOOL __attribute__((__stdcall__)) ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL);
 BOOL __attribute__((__stdcall__)) InitAtomTable(DWORD);
 BOOL __attribute__((__stdcall__)) InitializeAcl(PACL,DWORD,DWORD);
 void __attribute__((__stdcall__)) InitializeCriticalSection(LPCRITICAL_SECTION);
 BOOL __attribute__((__stdcall__)) InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION,DWORD);
 DWORD __attribute__((__stdcall__)) SetCriticalSectionSpinCount(LPCRITICAL_SECTION,DWORD);
 BOOL __attribute__((__stdcall__)) InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR,DWORD);
 BOOL __attribute__((__stdcall__)) InitializeSid (PSID,PSID_IDENTIFIER_AUTHORITY,BYTE);
# 1663 "C:/upp/mingw/include/winbase.h" 3
LONG __attribute__((__stdcall__)) InterlockedCompareExchange(LPLONG,LONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedDecrement(LPLONG);
LONG __attribute__((__stdcall__)) InterlockedExchange(LPLONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedExchangeAdd(LPLONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedIncrement(LPLONG);







 BOOL __attribute__((__stdcall__)) IsBadCodePtr(FARPROC);
 BOOL __attribute__((__stdcall__)) IsBadHugeReadPtr(PCVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadHugeWritePtr(PVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadReadPtr(PCVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadStringPtrA(LPCSTR,UINT);
 BOOL __attribute__((__stdcall__)) IsBadStringPtrW(LPCWSTR,UINT);
 BOOL __attribute__((__stdcall__)) IsBadWritePtr(PVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsDebuggerPresent(void);



 BOOL __attribute__((__stdcall__)) IsProcessorFeaturePresent(DWORD);
 BOOL __attribute__((__stdcall__)) IsSystemResumeAutomatic(void);
 BOOL __attribute__((__stdcall__)) IsTextUnicode(PCVOID,int,LPINT);
 BOOL __attribute__((__stdcall__)) IsValidAcl(PACL);
 BOOL __attribute__((__stdcall__)) IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) IsValidSid(PSID);



 void __attribute__((__stdcall__)) LeaveCriticalSection(LPCRITICAL_SECTION);

 HINSTANCE __attribute__((__stdcall__)) LoadLibraryA(LPCSTR);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryExA(LPCSTR,HANDLE,DWORD);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryW(LPCWSTR);
 DWORD __attribute__((__stdcall__)) LoadModule(LPCSTR,PVOID);
 HGLOBAL __attribute__((__stdcall__)) LoadResource(HINSTANCE,HRSRC);
 HLOCAL __attribute__((__stdcall__)) LocalAlloc(UINT,SIZE_T);
 SIZE_T __attribute__((__stdcall__)) LocalCompact(UINT);
 HLOCAL LocalDiscard(HLOCAL);
 BOOL __attribute__((__stdcall__)) LocalFileTimeToFileTime(const FILETIME *,LPFILETIME);
 UINT __attribute__((__stdcall__)) LocalFlags(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalFree(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalHandle(LPCVOID);
 PVOID __attribute__((__stdcall__)) LocalLock(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalReAlloc(HLOCAL,SIZE_T,UINT);
 SIZE_T __attribute__((__stdcall__)) LocalShrink(HLOCAL,UINT);
 UINT __attribute__((__stdcall__)) LocalSize(HLOCAL);
 BOOL __attribute__((__stdcall__)) LocalUnlock(HLOCAL);
 BOOL __attribute__((__stdcall__)) LockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);
 PVOID __attribute__((__stdcall__)) LockResource(HGLOBAL);

 BOOL __attribute__((__stdcall__)) LogonUserA(LPSTR,LPSTR,LPSTR,DWORD,DWORD,PHANDLE);
 BOOL __attribute__((__stdcall__)) LogonUserW(LPWSTR,LPWSTR,LPWSTR,DWORD,DWORD,PHANDLE);
 BOOL __attribute__((__stdcall__)) LookupAccountNameA(LPCSTR,LPCSTR,PSID,PDWORD,LPSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountSidA(LPCSTR,PSID,LPSTR,PDWORD,LPSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountSidW(LPCWSTR,PSID,LPWSTR,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeDisplayNameA(LPCSTR,LPCSTR,LPSTR,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeDisplayNameW(LPCWSTR,LPCWSTR,LPWSTR,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeNameA(LPCSTR,PLUID,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeNameW(LPCWSTR,PLUID,LPWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeValueA(LPCSTR,LPCSTR,PLUID);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeValueW(LPCWSTR,LPCWSTR,PLUID);
 LPSTR __attribute__((__stdcall__)) lstrcatA(LPSTR,LPCSTR);
 LPWSTR __attribute__((__stdcall__)) lstrcatW(LPWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrcmpA(LPCSTR,LPCSTR);
 int __attribute__((__stdcall__)) lstrcmpiA(LPCSTR,LPCSTR);
 int __attribute__((__stdcall__)) lstrcmpiW( LPCWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrcmpW(LPCWSTR,LPCWSTR);
 LPSTR __attribute__((__stdcall__)) lstrcpyA(LPSTR,LPCSTR);
 LPSTR __attribute__((__stdcall__)) lstrcpynA(LPSTR,LPCSTR,int);
 LPWSTR __attribute__((__stdcall__)) lstrcpynW(LPWSTR,LPCWSTR,int);
 LPWSTR __attribute__((__stdcall__)) lstrcpyW(LPWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrlenA(LPCSTR);
 int __attribute__((__stdcall__)) lstrlenW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) MakeAbsoluteSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PDWORD,PACL,PDWORD,PACL,PDWORD,PSID,PDWORD,PSID,PDWORD);

 BOOL __attribute__((__stdcall__)) MakeSelfRelativeSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PDWORD);
 void __attribute__((__stdcall__)) MapGenericMask(PDWORD,PGENERIC_MAPPING);
 PVOID __attribute__((__stdcall__)) MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 PVOID __attribute__((__stdcall__)) MapViewOfFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) MoveFileA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) MoveFileExA(LPCSTR,LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) MoveFileExW(LPCWSTR,LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) MoveFileW(LPCWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) MulDiv(int,int,int);
 BOOL __attribute__((__stdcall__)) NotifyChangeEventLog(HANDLE,HANDLE);
 BOOL __attribute__((__stdcall__)) ObjectCloseAuditAlarmA(LPCSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectCloseAuditAlarmW(LPCWSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectDeleteAuditAlarmA(LPCSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectDeleteAuditAlarmW(LPCWSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectOpenAuditAlarmA(LPCSTR,PVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) ObjectOpenAuditAlarmW(LPCWSTR,PVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) ObjectPrivilegeAuditAlarmA(LPCSTR,PVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectPrivilegeAuditAlarmW(LPCWSTR,PVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
 HANDLE __attribute__((__stdcall__)) OpenBackupEventLogA(LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenBackupEventLogW(LPCWSTR,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventLogA (LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventLogW(LPCWSTR,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventW(DWORD,BOOL,LPCWSTR);
 HFILE __attribute__((__stdcall__)) OpenFile(LPCSTR,LPOFSTRUCT,UINT);
 HANDLE __attribute__((__stdcall__)) OpenFileMappingA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenFileMappingW(DWORD,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenMutexA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenMutexW(DWORD,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenProcess(DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) OpenProcessToken(HANDLE,DWORD,PHANDLE);
 HANDLE __attribute__((__stdcall__)) OpenSemaphoreA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenSemaphoreW(DWORD,BOOL,LPCWSTR);



 BOOL __attribute__((__stdcall__)) OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);
 HANDLE __attribute__((__stdcall__)) OpenWaitableTimerA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenWaitableTimerW(DWORD,BOOL,LPCWSTR);
 void __attribute__((__stdcall__)) OutputDebugStringA(LPCSTR);
 void __attribute__((__stdcall__)) OutputDebugStringW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) PeekNamedPipe(HANDLE,PVOID,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) PostQueuedCompletionStatus(HANDLE,DWORD,ULONG_PTR,LPOVERLAPPED);
 DWORD __attribute__((__stdcall__)) PrepareTape(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) PrivilegeCheck (HANDLE,PPRIVILEGE_SET,PBOOL);
 BOOL __attribute__((__stdcall__)) PrivilegedServiceAuditAlarmA(LPCSTR,LPCSTR,HANDLE,PPRIVILEGE_SET,BOOL);
 BOOL __attribute__((__stdcall__)) PrivilegedServiceAuditAlarmW(LPCWSTR,LPCWSTR,HANDLE,PPRIVILEGE_SET,BOOL);



 BOOL __attribute__((__stdcall__)) PulseEvent(HANDLE);
 BOOL __attribute__((__stdcall__)) PurgeComm(HANDLE,DWORD);



 DWORD __attribute__((__stdcall__)) QueryDosDeviceA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) QueryDosDeviceW(LPCWSTR,LPWSTR,DWORD);



 BOOL __attribute__((__stdcall__)) QueryPerformanceCounter(PLARGE_INTEGER);
 BOOL __attribute__((__stdcall__)) QueryPerformanceFrequency(PLARGE_INTEGER);
 DWORD __attribute__((__stdcall__)) QueueUserAPC(PAPCFUNC,HANDLE,ULONG_PTR);



 void __attribute__((__stdcall__)) RaiseException(DWORD,DWORD,DWORD,const DWORD*);
 BOOL __attribute__((__stdcall__)) ReadDirectoryChangesW(HANDLE,PVOID,DWORD,BOOL,DWORD,PDWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) ReadEventLogA(HANDLE,DWORD,DWORD,PVOID,DWORD,DWORD *,DWORD *);
 BOOL __attribute__((__stdcall__)) ReadEventLogW(HANDLE,DWORD,DWORD,PVOID,DWORD,DWORD *,DWORD *);
 BOOL __attribute__((__stdcall__)) ReadFile(HANDLE,PVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ReadFileEx(HANDLE,PVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) ReadFileScatter(HANDLE,FILE_SEGMENT_ELEMENT*,DWORD,LPDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ReadProcessMemory(HANDLE,PCVOID,PVOID,DWORD,PDWORD);
 HANDLE __attribute__((__stdcall__)) RegisterEventSourceA (LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) RegisterEventSourceW(LPCWSTR,LPCWSTR);







 BOOL __attribute__((__stdcall__)) ReleaseMutex(HANDLE);
 BOOL __attribute__((__stdcall__)) ReleaseSemaphore(HANDLE,LONG,LPLONG);
 BOOL __attribute__((__stdcall__)) RemoveDirectoryA(LPCSTR);
 BOOL __attribute__((__stdcall__)) RemoveDirectoryW(LPCWSTR);
# 1851 "C:/upp/mingw/include/winbase.h" 3
 BOOL __attribute__((__stdcall__)) ReportEventA(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCSTR*,PVOID);
 BOOL __attribute__((__stdcall__)) ReportEventW(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCWSTR*,PVOID);



 BOOL __attribute__((__stdcall__)) ResetEvent(HANDLE);

 UINT __attribute__((__stdcall__)) ResetWriteWatch(LPVOID,SIZE_T);



 DWORD __attribute__((__stdcall__)) ResumeThread(HANDLE);
 BOOL __attribute__((__stdcall__)) RevertToSelf(void);
 DWORD __attribute__((__stdcall__)) SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR*);
 DWORD __attribute__((__stdcall__)) SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR*);
 BOOL __attribute__((__stdcall__)) SetAclInformation(PACL,PVOID,DWORD,ACL_INFORMATION_CLASS);
 BOOL __attribute__((__stdcall__)) SetCommBreak(HANDLE);
 BOOL __attribute__((__stdcall__)) SetCommConfig(HANDLE,LPCOMMCONFIG,DWORD);
 BOOL __attribute__((__stdcall__)) SetCommMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetCommState(HANDLE,LPDCB);
 BOOL __attribute__((__stdcall__)) SetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) SetComputerNameA(LPCSTR);
 BOOL __attribute__((__stdcall__)) SetComputerNameW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) SetCurrentDirectoryA(LPCSTR);
 BOOL __attribute__((__stdcall__)) SetCurrentDirectoryW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,DWORD);
 BOOL __attribute__((__stdcall__)) SetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,DWORD);




 BOOL __attribute__((__stdcall__)) SetEndOfFile(HANDLE);
 BOOL __attribute__((__stdcall__)) SetEnvironmentVariableA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetEnvironmentVariableW(LPCWSTR,LPCWSTR);
 UINT __attribute__((__stdcall__)) SetErrorMode(UINT);



 BOOL __attribute__((__stdcall__)) SetEvent(HANDLE);

 void __attribute__((__stdcall__)) SetFileApisToANSI(void);
 void __attribute__((__stdcall__)) SetFileApisToOEM(void);
 BOOL __attribute__((__stdcall__)) SetFileAttributesA(LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) SetFileAttributesW(LPCWSTR,DWORD);
 DWORD __attribute__((__stdcall__)) SetFilePointer(HANDLE,LONG,PLONG,DWORD);
 BOOL __attribute__((__stdcall__)) SetFilePointerEx(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD);
 BOOL __attribute__((__stdcall__)) SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) SetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);




 BOOL __attribute__((__stdcall__)) SetFileTime(HANDLE,const FILETIME*,const FILETIME*,const FILETIME*);







 UINT __attribute__((__stdcall__)) SetHandleCount(UINT);
 BOOL __attribute__((__stdcall__)) SetHandleInformation(HANDLE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 void __attribute__((__stdcall__)) SetLastError(DWORD);
 void __attribute__((__stdcall__)) SetLastErrorEx(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetLocalTime(const SYSTEMTIME*);
 BOOL __attribute__((__stdcall__)) SetMailslotInfo(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetNamedPipeHandleState(HANDLE,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) SetPriorityClass(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetPrivateObjectSecurity(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,PGENERIC_MAPPING,HANDLE);
 BOOL __attribute__((__stdcall__)) SetProcessAffinityMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetProcessPriorityBoost(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) SetProcessShutdownParameters(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,SECURITY_DESCRIPTOR_CONTROL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
 BOOL __attribute__((__stdcall__)) SetStdHandle(DWORD,HANDLE);

 BOOL __attribute__((__stdcall__)) SetSystemPowerState(BOOL,BOOL);
 BOOL __attribute__((__stdcall__)) SetSystemTime(const SYSTEMTIME*);
 BOOL __attribute__((__stdcall__)) SetSystemTimeAdjustment(DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SetTapeParameters(HANDLE,DWORD,PVOID);
 DWORD __attribute__((__stdcall__)) SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SetThreadAffinityMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadContext(HANDLE,const CONTEXT*);



 DWORD __attribute__((__stdcall__)) SetThreadIdealProcessor(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadPriority(HANDLE,int);
 BOOL __attribute__((__stdcall__)) SetThreadPriorityBoost(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) SetThreadToken (PHANDLE,HANDLE);
 BOOL __attribute__((__stdcall__)) SetTimeZoneInformation(const TIME_ZONE_INFORMATION *);
 BOOL __attribute__((__stdcall__)) SetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD);
 LPTOP_LEVEL_EXCEPTION_FILTER __attribute__((__stdcall__)) SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER);
 BOOL __attribute__((__stdcall__)) SetupComm(HANDLE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetVolumeLabelA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetVolumeLabelW(LPCWSTR,LPCWSTR);




 BOOL __attribute__((__stdcall__)) SetWaitableTimer(HANDLE,const LARGE_INTEGER*,LONG,PTIMERAPCROUTINE,PVOID,BOOL);
 DWORD __attribute__((__stdcall__)) SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SizeofResource(HINSTANCE,HRSRC);
 void __attribute__((__stdcall__)) Sleep(DWORD);
 DWORD __attribute__((__stdcall__)) SleepEx(DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SuspendThread(HANDLE);
 void __attribute__((__stdcall__)) SwitchToFiber(PVOID);
 BOOL __attribute__((__stdcall__)) SwitchToThread(void);
 BOOL __attribute__((__stdcall__)) SystemTimeToFileTime(const SYSTEMTIME*,LPFILETIME);
 BOOL __attribute__((__stdcall__)) SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
 BOOL __attribute__((__stdcall__)) TerminateProcess(HANDLE,UINT);
 BOOL __attribute__((__stdcall__)) TerminateThread(HANDLE,DWORD);
 DWORD __attribute__((__stdcall__)) TlsAlloc(void);
 BOOL __attribute__((__stdcall__)) TlsFree(DWORD);
 PVOID __attribute__((__stdcall__)) TlsGetValue(DWORD);
 BOOL __attribute__((__stdcall__)) TlsSetValue(DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) TransactNamedPipe(HANDLE,PVOID,DWORD,PVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) TransmitCommChar(HANDLE,char);
 BOOL __attribute__((__stdcall__)) TryEnterCriticalSection(LPCRITICAL_SECTION);
 LONG __attribute__((__stdcall__)) UnhandledExceptionFilter(LPEXCEPTION_POINTERS);
 BOOL __attribute__((__stdcall__)) UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);


 BOOL __attribute__((__stdcall__)) UnmapViewOfFile(PVOID);




 BOOL __attribute__((__stdcall__)) UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) UpdateResourceW(HANDLE,LPCWSTR,LPCWSTR,WORD,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) VerifyVersionInfoA(LPOSVERSIONINFOEXA,DWORD,DWORDLONG);
 BOOL __attribute__((__stdcall__)) VerifyVersionInfoW(LPOSVERSIONINFOEXW,DWORD,DWORDLONG);
 PVOID __attribute__((__stdcall__)) VirtualAlloc(PVOID,DWORD,DWORD,DWORD);
 PVOID __attribute__((__stdcall__)) VirtualAllocEx(HANDLE,PVOID,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualFree(PVOID,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualFreeEx(HANDLE,PVOID,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualLock(PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualProtect(PVOID,DWORD,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) VirtualProtectEx(HANDLE,PVOID,DWORD,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) VirtualQuery(LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
 DWORD __attribute__((__stdcall__)) VirtualQueryEx(HANDLE,LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualUnlock(PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) WaitCommEvent(HANDLE,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WaitForDebugEvent(LPDEBUG_EVENT,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForMultipleObjects(DWORD,const HANDLE*,BOOL,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForMultipleObjectsEx(DWORD,const HANDLE*,BOOL,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) WaitForSingleObject(HANDLE,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForSingleObjectEx(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) WaitNamedPipeA(LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) WaitNamedPipeW(LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) WinLoadTrustProvider(GUID*);
 BOOL __attribute__((__stdcall__)) WriteFile(HANDLE,PCVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WriteFileEx(HANDLE,PCVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) WriteFileGather(HANDLE,FILE_SEGMENT_ELEMENT*,DWORD,LPDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileSectionA(LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileSectionW(LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WriteProcessMemory(HANDLE,LPVOID,LPCVOID,SIZE_T,SIZE_T*);
 BOOL __attribute__((__stdcall__)) WriteProfileSectionA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileSectionW(LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileStringA(LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR);
 DWORD __attribute__((__stdcall__)) WriteTapemark(HANDLE,DWORD,DWORD,BOOL);
# 2235 "C:/upp/mingw/include/winbase.h" 3
typedef STARTUPINFOA STARTUPINFO,*LPSTARTUPINFO;
typedef WIN32_FIND_DATAA WIN32_FIND_DATA,*PWIN32_FIND_DATA,*LPWIN32_FIND_DATA;
typedef HW_PROFILE_INFOA HW_PROFILE_INFO,*LPHW_PROFILE_INFO;
# 2433 "C:/upp/mingw/include/winbase.h" 3
}
# 51 "C:/upp/mingw/include/windows.h" 2 3

# 1 "C:/upp/mingw/include/wingdi.h" 1 3




       
# 6 "C:/upp/mingw/include/wingdi.h" 3



extern "C" {
# 1333 "C:/upp/mingw/include/wingdi.h" 3
typedef struct _ABC {
 int abcA;
 UINT abcB;
 int abcC;
} ABC,*LPABC;
typedef struct _ABCFLOAT {
 FLOAT abcfA;
 FLOAT abcfB;
 FLOAT abcfC;
} ABCFLOAT,*LPABCFLOAT;
typedef struct tagBITMAP {
 LONG bmType;
 LONG bmWidth;
 LONG bmHeight;
 LONG bmWidthBytes;
 WORD bmPlanes;
 WORD bmBitsPixel;
 LPVOID bmBits;
} BITMAP,*PBITMAP,*LPBITMAP;
typedef struct tagBITMAPCOREHEADER {
 DWORD bcSize;
 WORD bcWidth;
 WORD bcHeight;
 WORD bcPlanes;
 WORD bcBitCount;
} BITMAPCOREHEADER,*LPBITMAPCOREHEADER,*PBITMAPCOREHEADER;
#pragma pack(push,1)
typedef struct tagRGBTRIPLE {
 BYTE rgbtBlue;
 BYTE rgbtGreen;
 BYTE rgbtRed;
} RGBTRIPLE,*LPRGBTRIPLE;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct tagBITMAPFILEHEADER {
 WORD bfType;
 DWORD bfSize;
 WORD bfReserved1;
 WORD bfReserved2;
 DWORD bfOffBits;
} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;
#pragma pack(pop)
typedef struct _BITMAPCOREINFO {
 BITMAPCOREHEADER bmciHeader;
 RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO,*LPBITMAPCOREINFO,*PBITMAPCOREINFO;
typedef struct tagBITMAPINFOHEADER{
 DWORD biSize;
 LONG biWidth;
 LONG biHeight;
 WORD biPlanes;
 WORD biBitCount;
 DWORD biCompression;
 DWORD biSizeImage;
 LONG biXPelsPerMeter;
 LONG biYPelsPerMeter;
 DWORD biClrUsed;
 DWORD biClrImportant;
} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;
typedef struct tagRGBQUAD {
 BYTE rgbBlue;
 BYTE rgbGreen;
 BYTE rgbRed;
 BYTE rgbReserved;
} RGBQUAD,*LPRGBQUAD;
typedef struct tagBITMAPINFO {
 BITMAPINFOHEADER bmiHeader;
 RGBQUAD bmiColors[1];
} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;
typedef long FXPT16DOT16,*LPFXPT16DOT16;
typedef long FXPT2DOT30,*LPFXPT2DOT30;
typedef struct tagCIEXYZ {
 FXPT2DOT30 ciexyzX;
 FXPT2DOT30 ciexyzY;
 FXPT2DOT30 ciexyzZ;
} CIEXYZ,*LPCIEXYZ;
typedef struct tagCIEXYZTRIPLE {
 CIEXYZ ciexyzRed;
 CIEXYZ ciexyzGreen;
 CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE,*LPCIEXYZTRIPLE;
typedef struct {
 DWORD bV4Size;
 LONG bV4Width;
 LONG bV4Height;
 WORD bV4Planes;
 WORD bV4BitCount;
 DWORD bV4V4Compression;
 DWORD bV4SizeImage;
 LONG bV4XPelsPerMeter;
 LONG bV4YPelsPerMeter;
 DWORD bV4ClrUsed;
 DWORD bV4ClrImportant;
 DWORD bV4RedMask;
 DWORD bV4GreenMask;
 DWORD bV4BlueMask;
 DWORD bV4AlphaMask;
 DWORD bV4CSType;
 CIEXYZTRIPLE bV4Endpoints;
 DWORD bV4GammaRed;
 DWORD bV4GammaGreen;
 DWORD bV4GammaBlue;
} BITMAPV4HEADER,*LPBITMAPV4HEADER,*PBITMAPV4HEADER;
typedef struct {
 DWORD bV5Size;
 LONG bV5Width;
 LONG bV5Height;
 WORD bV5Planes;
 WORD bV5BitCount;
 DWORD bV5Compression;
 DWORD bV5SizeImage;
 LONG bV5XPelsPerMeter;
 LONG bV5YPelsPerMeter;
 DWORD bV5ClrUsed;
 DWORD bV5ClrImportant;
 DWORD bV5RedMask;
 DWORD bV5GreenMask;
 DWORD bV5BlueMask;
 DWORD bV5AlphaMask;
 DWORD bV5CSType;
 CIEXYZTRIPLE bV5Endpoints;
 DWORD bV5GammaRed;
 DWORD bV5GammaGreen;
 DWORD bV5GammaBlue;
 DWORD bV5Intent;
 DWORD bV5ProfileData;
 DWORD bV5ProfileSize;
 DWORD bV5Reserved;
} BITMAPV5HEADER,*LPBITMAPV5HEADER,*PBITMAPV5HEADER;
typedef struct tagFONTSIGNATURE {
 DWORD fsUsb[4];
 DWORD fsCsb[2];
} FONTSIGNATURE,*LPFONTSIGNATURE;
typedef struct {
 UINT ciCharset;
 UINT ciACP;
 FONTSIGNATURE fs;
} CHARSETINFO,*LPCHARSETINFO;
typedef struct tagCOLORADJUSTMENT {
 WORD caSize;
 WORD caFlags;
 WORD caIlluminantIndex;
 WORD caRedGamma;
 WORD caGreenGamma;
 WORD caBlueGamma;
 WORD caReferenceBlack;
 WORD caReferenceWhite;
 SHORT caContrast;
 SHORT caBrightness;
 SHORT caColorfulness;
 SHORT caRedGreenTint;
} COLORADJUSTMENT,*LPCOLORADJUSTMENT;
typedef struct _devicemodeA {
  BYTE dmDeviceName[32];
  WORD dmSpecVersion;
  WORD dmDriverVersion;
  WORD dmSize;
  WORD dmDriverExtra;
  DWORD dmFields;
  __extension__ union {
    __extension__ struct {
      short dmOrientation;
      short dmPaperSize;
      short dmPaperLength;
      short dmPaperWidth;
      short dmScale;
      short dmCopies;
      short dmDefaultSource;
      short dmPrintQuality;
    } ;
    POINTL dmPosition;
    DWORD dmDisplayOrientation;
    DWORD dmDisplayFixedOutput;
  } ;

  short dmColor;
  short dmDuplex;
  short dmYResolution;
  short dmTTOption;
  short dmCollate;
  BYTE dmFormName[32];
  WORD dmLogPixels;
  DWORD dmBitsPerPel;
  DWORD dmPelsWidth;
  DWORD dmPelsHeight;
  __extension__ union {
    DWORD dmDisplayFlags;
    DWORD dmNup;
  } ;
  DWORD dmDisplayFrequency;

  DWORD dmICMMethod;
  DWORD dmICMIntent;
  DWORD dmMediaType;
  DWORD dmDitherType;
  DWORD dmReserved1;
  DWORD dmReserved2;

  DWORD dmPanningWidth;
  DWORD dmPanningHeight;


} DEVMODEA,*LPDEVMODEA,*PDEVMODEA;
typedef struct _devicemodeW {
  WCHAR dmDeviceName[32];
  WORD dmSpecVersion;
  WORD dmDriverVersion;
  WORD dmSize;
  WORD dmDriverExtra;
  DWORD dmFields;
  __extension__ union {
    __extension__ struct {
      short dmOrientation;
      short dmPaperSize;
      short dmPaperLength;
      short dmPaperWidth;
      short dmScale;
      short dmCopies;
      short dmDefaultSource;
      short dmPrintQuality;
    } ;
    POINTL dmPosition;
    DWORD dmDisplayOrientation;
    DWORD dmDisplayFixedOutput;
  } ;

  short dmColor;
  short dmDuplex;
  short dmYResolution;
  short dmTTOption;
  short dmCollate;
  WCHAR dmFormName[32];
  WORD dmLogPixels;
  DWORD dmBitsPerPel;
  DWORD dmPelsWidth;
  DWORD dmPelsHeight;
  __extension__ union {
    DWORD dmDisplayFlags;
    DWORD dmNup;
  } ;
  DWORD dmDisplayFrequency;

  DWORD dmICMMethod;
  DWORD dmICMIntent;
  DWORD dmMediaType;
  DWORD dmDitherType;
  DWORD dmReserved1;
  DWORD dmReserved2;

  DWORD dmPanningWidth;
  DWORD dmPanningHeight;


} DEVMODEW,*LPDEVMODEW,*PDEVMODEW;
typedef struct tagDIBSECTION {
 BITMAP dsBm;
 BITMAPINFOHEADER dsBmih;
 DWORD dsBitfields[3];
 HANDLE dshSection;
 DWORD dsOffset;
} DIBSECTION;
typedef struct _DOCINFOA {
 int cbSize;
 LPCSTR lpszDocName;
 LPCSTR lpszOutput;
 LPCSTR lpszDatatype;
 DWORD fwType;
} DOCINFOA,*LPDOCINFOA;
typedef struct _DOCINFOW {
 int cbSize;
 LPCWSTR lpszDocName;
 LPCWSTR lpszOutput;
 LPCWSTR lpszDatatype;
 DWORD fwType;
} DOCINFOW,*LPDOCINFOW;
typedef struct tagEMR {
 DWORD iType;
 DWORD nSize;
} EMR,*PEMR;
typedef struct tagEMRANGLEARC {
 EMR emr;
 POINTL ptlCenter;
 DWORD nRadius;
 FLOAT eStartAngle;
 FLOAT eSweepAngle;
} EMRANGLEARC,*PEMRANGLEARC;
typedef struct tagEMRARC {
 EMR emr;
 RECTL rclBox;
 POINTL ptlStart;
 POINTL ptlEnd;
} EMRARC,*PEMRARC,EMRARCTO,*PEMRARCTO,EMRCHORD,*PEMRCHORD,EMRPIE,*PEMRPIE;
typedef struct _XFORM {
 FLOAT eM11;
 FLOAT eM12;
 FLOAT eM21;
 FLOAT eM22;
 FLOAT eDx;
 FLOAT eDy;
} XFORM,*PXFORM,*LPXFORM;
typedef struct tagEMRBITBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
} EMRBITBLT,*PEMRBITBLT;
typedef struct tagLOGBRUSH {
 UINT lbStyle;
 COLORREF lbColor;
 LONG lbHatch;
} LOGBRUSH,*PLOGBRUSH,*LPLOGBRUSH;
typedef LOGBRUSH PATTERN,*PPATTERN,*LPPATTERN;
typedef struct tagEMRCREATEBRUSHINDIRECT {
 EMR emr;
 DWORD ihBrush;
 LOGBRUSH lb;
} EMRCREATEBRUSHINDIRECT,*PEMRCREATEBRUSHINDIRECT;
typedef LONG LCSCSTYPE;
typedef LONG LCSGAMUTMATCH;
typedef struct tagLOGCOLORSPACEA {
 DWORD lcsSignature;
 DWORD lcsVersion;
 DWORD lcsSize;
 LCSCSTYPE lcsCSType;
 LCSGAMUTMATCH lcsIntent;
 CIEXYZTRIPLE lcsEndpoints;
 DWORD lcsGammaRed;
 DWORD lcsGammaGreen;
 DWORD lcsGammaBlue;
 CHAR lcsFilename[260];
} LOGCOLORSPACEA,*LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
 DWORD lcsSignature;
 DWORD lcsVersion;
 DWORD lcsSize;
 LCSCSTYPE lcsCSType;
 LCSGAMUTMATCH lcsIntent;
 CIEXYZTRIPLE lcsEndpoints;
 DWORD lcsGammaRed;
 DWORD lcsGammaGreen;
 DWORD lcsGammaBlue;
 WCHAR lcsFilename[260];
} LOGCOLORSPACEW,*LPLOGCOLORSPACEW;
typedef struct tagEMRCREATECOLORSPACE {
 EMR emr;
 DWORD ihCS;
 LOGCOLORSPACEW lcs;
} EMRCREATECOLORSPACE,*PEMRCREATECOLORSPACE;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
 EMR emr;
 DWORD ihBrush;
 DWORD iUsage;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
} EMRCREATEDIBPATTERNBRUSHPT,*PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRCREATEMONOBRUSH {
 EMR emr;
 DWORD ihBrush;
 DWORD iUsage;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
} EMRCREATEMONOBRUSH,*PEMRCREATEMONOBRUSH;
typedef struct tagPALETTEENTRY {
 BYTE peRed;
 BYTE peGreen;
 BYTE peBlue;
 BYTE peFlags;
} PALETTEENTRY,*LPPALETTEENTRY,*PPALETTEENTRY;
typedef struct tagLOGPALETTE {
 WORD palVersion;
 WORD palNumEntries;
 PALETTEENTRY palPalEntry[1];
} LOGPALETTE,*NPLOGPALETTE,*PLOGPALETTE,*LPLOGPALETTE;
typedef struct tagEMRCREATEPALETTE {
 EMR emr;
 DWORD ihPal;
 LOGPALETTE lgpl;
} EMRCREATEPALETTE,*PEMRCREATEPALETTE;
typedef struct tagLOGPEN {
 UINT lopnStyle;
 POINT lopnWidth;
 COLORREF lopnColor;
} LOGPEN,*PLOGPEN,*LPLOGPEN;
typedef struct tagEMRCREATEPEN {
 EMR emr;
 DWORD ihPen;
 LOGPEN lopn;
} EMRCREATEPEN,*PEMRCREATEPEN;
typedef struct tagEMRELLIPSE {
 EMR emr;
 RECTL rclBox;
} EMRELLIPSE,*PEMRELLIPSE,EMRRECTANGLE,*PEMRRECTANGLE;
typedef struct tagEMREOF {
 EMR emr;
 DWORD nPalEntries;
 DWORD offPalEntries;
 DWORD nSizeLast;
} EMREOF,*PEMREOF;
typedef struct tagEMREXCLUDECLIPRECT {
 EMR emr;
 RECTL rclClip;
} EMREXCLUDECLIPRECT,*PEMREXCLUDECLIPRECT,EMRINTERSECTCLIPRECT,*PEMRINTERSECTCLIPRECT;
typedef struct tagPANOSE {
 BYTE bFamilyType;
 BYTE bSerifStyle;
 BYTE bWeight;
 BYTE bProportion;
 BYTE bContrast;
 BYTE bStrokeVariation;
 BYTE bArmStyle;
 BYTE bLetterform;
 BYTE bMidline;
 BYTE bXHeight;
} PANOSE;
typedef struct tagLOGFONTA {
 LONG lfHeight;
 LONG lfWidth;
 LONG lfEscapement;
 LONG lfOrientation;
 LONG lfWeight;
 BYTE lfItalic;
 BYTE lfUnderline;
 BYTE lfStrikeOut;
 BYTE lfCharSet;
 BYTE lfOutPrecision;
 BYTE lfClipPrecision;
 BYTE lfQuality;
 BYTE lfPitchAndFamily;
 CHAR lfFaceName[32];
} LOGFONTA,*PLOGFONTA,*LPLOGFONTA;
typedef struct tagLOGFONTW {
 LONG lfHeight;
 LONG lfWidth;
 LONG lfEscapement;
 LONG lfOrientation;
 LONG lfWeight;
 BYTE lfItalic;
 BYTE lfUnderline;
 BYTE lfStrikeOut;
 BYTE lfCharSet;
 BYTE lfOutPrecision;
 BYTE lfClipPrecision;
 BYTE lfQuality;
 BYTE lfPitchAndFamily;
 WCHAR lfFaceName[32];
} LOGFONTW,*PLOGFONTW,*LPLOGFONTW;
typedef struct tagEXTLOGFONTA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
 DWORD elfVersion;
 DWORD elfStyleSize;
 DWORD elfMatch;
 DWORD elfReserved;
 BYTE elfVendorId[4];
 DWORD elfCulture;
 PANOSE elfPanose;
} EXTLOGFONTA,*PEXTLOGFONTA,*LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
 DWORD elfVersion;
 DWORD elfStyleSize;
 DWORD elfMatch;
 DWORD elfReserved;
 BYTE elfVendorId[4];
 DWORD elfCulture;
 PANOSE elfPanose;
} EXTLOGFONTW,*PEXTLOGFONTW,*LPEXTLOGFONTW;
typedef struct tagEMREXTCREATEFONTINDIRECTW {
 EMR emr;
 DWORD ihFont;
 EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW,*PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEXTLOGPEN {
 UINT elpPenStyle;
 UINT elpWidth;
 UINT elpBrushStyle;
 COLORREF elpColor;
 LONG elpHatch;
 DWORD elpNumEntries;
 DWORD elpStyleEntry[1];
} EXTLOGPEN,*PEXTLOGPEN,*LPEXTLOGPEN;
typedef struct tagEMREXTCREATEPEN {
 EMR emr;
 DWORD ihPen;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
 EXTLOGPEN elp;
} EMREXTCREATEPEN,*PEMREXTCREATEPEN;
typedef struct tagEMREXTFLOODFILL {
 EMR emr;
 POINTL ptlStart;
 COLORREF crColor;
 DWORD iMode;
} EMREXTFLOODFILL,*PEMREXTFLOODFILL;
typedef struct tagEMREXTSELECTCLIPRGN {
 EMR emr;
 DWORD cbRgnData;
 DWORD iMode;
 BYTE RgnData[1];
} EMREXTSELECTCLIPRGN,*PEMREXTSELECTCLIPRGN;
typedef struct tagEMRTEXT {
 POINTL ptlReference;
 DWORD nChars;
 DWORD offString;
 DWORD fOptions;
 RECTL rcl;
 DWORD offDx;
} EMRTEXT,*PEMRTEXT;
typedef struct tagEMREXTTEXTOUTA {
 EMR emr;
 RECTL rclBounds;
 DWORD iGraphicsMode;
 FLOAT exScale;
 FLOAT eyScale;
 EMRTEXT emrtext;
} EMREXTTEXTOUTA,*PEMREXTTEXTOUTA,EMREXTTEXTOUTW,*PEMREXTTEXTOUTW;
typedef struct tagEMRFILLPATH {
 EMR emr;
 RECTL rclBounds;
} EMRFILLPATH,*PEMRFILLPATH,EMRSTROKEANDFILLPATH,*PEMRSTROKEANDFILLPATH,EMRSTROKEPATH,*PEMRSTROKEPATH;
typedef struct tagEMRFILLRGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 DWORD ihBrush;
 BYTE RgnData[1];
} EMRFILLRGN,*PEMRFILLRGN;
typedef struct tagEMRFORMAT {
 DWORD dSignature;
 DWORD nVersion;
 DWORD cbData;
 DWORD offData;
} EMRFORMAT;
typedef struct tagEMRFRAMERGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 DWORD ihBrush;
 SIZEL szlStroke;
 BYTE RgnData[1];
} EMRFRAMERGN,*PEMRFRAMERGN;
typedef struct tagEMRGDICOMMENT {
 EMR emr;
 DWORD cbData;
 BYTE Data[1];
} EMRGDICOMMENT,*PEMRGDICOMMENT;
typedef struct tagEMRINVERTRGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 BYTE RgnData[1];
} EMRINVERTRGN,*PEMRINVERTRGN,EMRPAINTRGN,*PEMRPAINTRGN;
typedef struct tagEMRLINETO {
 EMR emr;
 POINTL ptl;
} EMRLINETO,*PEMRLINETO,EMRMOVETOEX,*PEMRMOVETOEX;
typedef struct tagEMRMASKBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG xMask;
 LONG yMask;
 DWORD iUsageMask;
 DWORD offBmiMask;
 DWORD cbBmiMask;
 DWORD offBitsMask;
 DWORD cbBitsMask;
} EMRMASKBLT,*PEMRMASKBLT;
typedef struct tagEMRMODIFYWORLDTRANSFORM {
 EMR emr;
 XFORM xform;
 DWORD iMode;
} EMRMODIFYWORLDTRANSFORM,*PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMROFFSETCLIPRGN {
 EMR emr;
 POINTL ptlOffset;
} EMROFFSETCLIPRGN,*PEMROFFSETCLIPRGN;
typedef struct tagEMRPLGBLT {
 EMR emr;
 RECTL rclBounds;
 POINTL aptlDest[3];
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG xMask;
 LONG yMask;
 DWORD iUsageMask;
 DWORD offBmiMask;
 DWORD cbBmiMask;
 DWORD offBitsMask;
 DWORD cbBitsMask;
} EMRPLGBLT,*PEMRPLGBLT;
typedef struct tagEMRPOLYDRAW {
 EMR emr;
 RECTL rclBounds;
 DWORD cptl;
 POINTL aptl[1];
 BYTE abTypes[1];
} EMRPOLYDRAW,*PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16 {
 EMR emr;
 RECTL rclBounds;
 DWORD cpts;
 POINTS apts[1];
 BYTE abTypes[1];
} EMRPOLYDRAW16,*PEMRPOLYDRAW16;
typedef struct tagEMRPOLYLINE {
 EMR emr;
 RECTL rclBounds;
 DWORD cptl;
 POINTL aptl[1];
} EMRPOLYLINE,*PEMRPOLYLINE,EMRPOLYBEZIER,*PEMRPOLYBEZIER,EMRPOLYGON,*PEMRPOLYGON,EMRPOLYBEZIERTO,*PEMRPOLYBEZIERTO,EMRPOLYLINETO,*PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16 {
 EMR emr;
 RECTL rclBounds;
 DWORD cpts;
 POINTL apts[1];
} EMRPOLYLINE16,*PEMRPOLYLINE16,EMRPOLYBEZIER16,*PEMRPOLYBEZIER16,EMRPOLYGON16,*PEMRPOLYGON16,EMRPOLYBEZIERTO16,*PEMRPOLYBEZIERTO16,EMRPOLYLINETO16,*PEMRPOLYLINETO16;
typedef struct tagEMRPOLYPOLYLINE {
 EMR emr;
 RECTL rclBounds;
 DWORD nPolys;
 DWORD cptl;
 DWORD aPolyCounts[1];
 POINTL aptl[1];
} EMRPOLYPOLYLINE,*PEMRPOLYPOLYLINE,EMRPOLYPOLYGON,*PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16 {
 EMR emr;
 RECTL rclBounds;
 DWORD nPolys;
 DWORD cpts;
 DWORD aPolyCounts[1];
 POINTS apts[1];
} EMRPOLYPOLYLINE16,*PEMRPOLYPOLYLINE16,EMRPOLYPOLYGON16,*PEMRPOLYPOLYGON16;
typedef struct tagEMRPOLYTEXTOUTA {
 EMR emr;
 RECTL rclBounds;
 DWORD iGraphicsMode;
 FLOAT exScale;
 FLOAT eyScale;
 LONG cStrings;
 EMRTEXT aemrtext[1];
} EMRPOLYTEXTOUTA,*PEMRPOLYTEXTOUTA,EMRPOLYTEXTOUTW,*PEMRPOLYTEXTOUTW;
typedef struct tagEMRRESIZEPALETTE {
 EMR emr;
 DWORD ihPal;
 DWORD cEntries;
} EMRRESIZEPALETTE,*PEMRRESIZEPALETTE;
typedef struct tagEMRRESTOREDC {
 EMR emr;
 LONG iRelative;
} EMRRESTOREDC,*PEMRRESTOREDC;
typedef struct tagEMRROUNDRECT {
 EMR emr;
 RECTL rclBox;
 SIZEL szlCorner;
} EMRROUNDRECT,*PEMRROUNDRECT;
typedef struct tagEMRSCALEVIEWPORTEXTEX {
 EMR emr;
 LONG xNum;
 LONG xDenom;
 LONG yNum;
 LONG yDenom;
} EMRSCALEVIEWPORTEXTEX,*PEMRSCALEVIEWPORTEXTEX,EMRSCALEWINDOWEXTEX,*PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSELECTCOLORSPACE {
 EMR emr;
 DWORD ihCS;
} EMRSELECTCOLORSPACE,*PEMRSELECTCOLORSPACE,EMRDELETECOLORSPACE,*PEMRDELETECOLORSPACE;
typedef struct tagEMRSELECTOBJECT {
 EMR emr;
 DWORD ihObject;
} EMRSELECTOBJECT,*PEMRSELECTOBJECT,EMRDELETEOBJECT,*PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE {
 EMR emr;
 DWORD ihPal;
} EMRSELECTPALETTE,*PEMRSELECTPALETTE;
typedef struct tagEMRSETARCDIRECTION {
 EMR emr;
 DWORD iArcDirection;
} EMRSETARCDIRECTION,*PEMRSETARCDIRECTION;
typedef struct tagEMRSETTEXTCOLOR {
 EMR emr;
 COLORREF crColor;
} EMRSETBKCOLOR,*PEMRSETBKCOLOR,EMRSETTEXTCOLOR,*PEMRSETTEXTCOLOR;
typedef struct tagEMRSETCOLORADJUSTMENT {
 EMR emr;
 COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT,*PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRSETDIBITSTODEVICE {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 DWORD iUsageSrc;
 DWORD iStartScan;
 DWORD cScans;
} EMRSETDIBITSTODEVICE,*PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSETMAPPERFLAGS {
 EMR emr;
 DWORD dwFlags;
} EMRSETMAPPERFLAGS,*PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETMITERLIMIT {
 EMR emr;
 FLOAT eMiterLimit;
} EMRSETMITERLIMIT,*PEMRSETMITERLIMIT;
typedef struct tagEMRSETPALETTEENTRIES {
 EMR emr;
 DWORD ihPal;
 DWORD iStart;
 DWORD cEntries;
 PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES,*PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETPIXELV {
 EMR emr;
 POINTL ptlPixel;
 COLORREF crColor;
} EMRSETPIXELV,*PEMRSETPIXELV;
typedef struct tagEMRSETVIEWPORTEXTEX {
 EMR emr;
 SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX,*PEMRSETVIEWPORTEXTEX,EMRSETWINDOWEXTEX,*PEMRSETWINDOWEXTEX;
typedef struct tagEMRSETVIEWPORTORGEX {
 EMR emr;
 POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX,*PEMRSETVIEWPORTORGEX,EMRSETWINDOWORGEX,*PEMRSETWINDOWORGEX,EMRSETBRUSHORGEX,*PEMRSETBRUSHORGEX;
typedef struct tagEMRSETWORLDTRANSFORM {
 EMR emr;
 XFORM xform;
} EMRSETWORLDTRANSFORM,*PEMRSETWORLDTRANSFORM;
typedef struct tagEMRSTRETCHBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG cxSrc;
 LONG cySrc;
} EMRSTRETCHBLT,*PEMRSTRETCHBLT;
typedef struct tagEMRSTRETCHDIBITS {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 DWORD iUsageSrc;
 DWORD dwRop;
 LONG cxDest;
 LONG cyDest;
} EMRSTRETCHDIBITS,*PEMRSTRETCHDIBITS;
typedef struct tagABORTPATH {
 EMR emr;
} EMRABORTPATH,*PEMRABORTPATH,EMRBEGINPATH,*PEMRBEGINPATH,EMRENDPATH,*PEMRENDPATH,EMRCLOSEFIGURE,*PEMRCLOSEFIGURE,EMRFLATTENPATH,*PEMRFLATTENPATH,EMRWIDENPATH,*PEMRWIDENPATH,EMRSETMETARGN,*PEMRSETMETARGN,EMRSAVEDC,*PEMRSAVEDC,EMRREALIZEPALETTE,*PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH {
 EMR emr;
 DWORD iMode;
} EMRSELECTCLIPPATH,*PEMRSELECTCLIPPATH,EMRSETBKMODE,*PEMRSETBKMODE,EMRSETMAPMODE,*PEMRSETMAPMODE,EMRSETPOLYFILLMODE,*PEMRSETPOLYFILLMODE,EMRSETROP2,*PEMRSETROP2,EMRSETSTRETCHBLTMODE,*PEMRSETSTRETCHBLTMODE,EMRSETTEXTALIGN,*PEMRSETTEXTALIGN,EMRENABLEICM,*PEMRENABLEICM;
#pragma pack(push,2)
typedef struct tagMETAHEADER {
 WORD mtType;
 WORD mtHeaderSize;
 WORD mtVersion;
 DWORD mtSize;
 WORD mtNoObjects;
 DWORD mtMaxRecord;
 WORD mtNoParameters;
} METAHEADER,*PMETAHEADER,*LPMETAHEADER;
#pragma pack(pop)
typedef struct tagENHMETAHEADER {
 DWORD iType;
 DWORD nSize;
 RECTL rclBounds;
 RECTL rclFrame;
 DWORD dSignature;
 DWORD nVersion;
 DWORD nBytes;
 DWORD nRecords;
 WORD nHandles;
 WORD sReserved;
 DWORD nDescription;
 DWORD offDescription;
 DWORD nPalEntries;
 SIZEL szlDevice;
 SIZEL szlMillimeters;

 DWORD cbPixelFormat;
 DWORD offPixelFormat;
 DWORD bOpenGL;




} ENHMETAHEADER,*LPENHMETAHEADER;
typedef struct tagMETARECORD {
 DWORD rdSize;
 WORD rdFunction;
 WORD rdParm[1];
} METARECORD,*PMETARECORD,*LPMETARECORD;
typedef struct tagENHMETARECORD {
 DWORD iType;
 DWORD nSize;
 DWORD dParm[1];
} ENHMETARECORD,*LPENHMETARECORD;
typedef struct tagHANDLETABLE {
 HGDIOBJ objectHandle[1];
} HANDLETABLE,*LPHANDLETABLE;
typedef struct tagTEXTMETRICA {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 BYTE tmFirstChar;
 BYTE tmLastChar;
 BYTE tmDefaultChar;
 BYTE tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
} TEXTMETRICA,*PTEXTMETRICA,*LPTEXTMETRICA;
typedef struct tagTEXTMETRICW {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 WCHAR tmFirstChar;
 WCHAR tmLastChar;
 WCHAR tmDefaultChar;
 WCHAR tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
} TEXTMETRICW,*PTEXTMETRICW,*LPTEXTMETRICW;
typedef struct _RGNDATAHEADER {
 DWORD dwSize;
 DWORD iType;
 DWORD nCount;
 DWORD nRgnSize;
 RECT rcBound;
} RGNDATAHEADER;
typedef struct _RGNDATA {
 RGNDATAHEADER rdh;
 char Buffer[1];
} RGNDATA,*PRGNDATA, *LPRGNDATA;


typedef struct tagGCP_RESULTSA {
 DWORD lStructSize;
 LPSTR lpOutString;
 UINT *lpOrder;
 INT *lpDx;
 INT *lpCaretPos;
 LPSTR lpClass;
 LPWSTR lpGlyphs;
 UINT nGlyphs;
 UINT nMaxFit;
} GCP_RESULTSA,*LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW {
 DWORD lStructSize;
 LPWSTR lpOutString;
 UINT *lpOrder;
 INT *lpDx;
 INT *lpCaretPos;
 LPWSTR lpClass;
 LPWSTR lpGlyphs;
 UINT nGlyphs;
 UINT nMaxFit;
} GCP_RESULTSW,*LPGCP_RESULTSW;
typedef struct _GLYPHMETRICS {
 UINT gmBlackBoxX;
 UINT gmBlackBoxY;
 POINT gmptGlyphOrigin;
 short gmCellIncX;
 short gmCellIncY;
} GLYPHMETRICS,*LPGLYPHMETRICS;
# 2306 "C:/upp/mingw/include/wingdi.h" 3
typedef struct tagKERNINGPAIR {
 WORD wFirst;
 WORD wSecond;
 int iKernAmount;
} KERNINGPAIR,*LPKERNINGPAIR;
typedef struct _FIXED {
 WORD fract;
 short value;
} FIXED;
typedef struct _MAT2 {
 FIXED eM11;
 FIXED eM12;
 FIXED eM21;
 FIXED eM22;
} MAT2,*LPMAT2;
typedef struct _OUTLINETEXTMETRICA {
 UINT otmSize;
 TEXTMETRICA otmTextMetrics;
 BYTE otmFiller;
 PANOSE otmPanoseNumber;
 UINT otmfsSelection;
 UINT otmfsType;
 int otmsCharSlopeRise;
 int otmsCharSlopeRun;
 int otmItalicAngle;
 UINT otmEMSquare;
 int otmAscent;
 int otmDescent;
 UINT otmLineGap;
 UINT otmsCapEmHeight;
 UINT otmsXHeight;
 RECT otmrcFontBox;
 int otmMacAscent;
 int otmMacDescent;
 UINT otmMacLineGap;
 UINT otmusMinimumPPEM;
 POINT otmptSubscriptSize;
 POINT otmptSubscriptOffset;
 POINT otmptSuperscriptSize;
 POINT otmptSuperscriptOffset;
 UINT otmsStrikeoutSize;
 int otmsStrikeoutPosition;
 int otmsUnderscoreSize;
 int otmsUnderscorePosition;
 PSTR otmpFamilyName;
 PSTR otmpFaceName;
 PSTR otmpStyleName;
 PSTR otmpFullName;
} OUTLINETEXTMETRICA,*POUTLINETEXTMETRICA,*LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
 UINT otmSize;
 TEXTMETRICW otmTextMetrics;
 BYTE otmFiller;
 PANOSE otmPanoseNumber;
 UINT otmfsSelection;
 UINT otmfsType;
 int otmsCharSlopeRise;
 int otmsCharSlopeRun;
 int otmItalicAngle;
 UINT otmEMSquare;
 int otmAscent;
 int otmDescent;
 UINT otmLineGap;
 UINT otmsCapEmHeight;
 UINT otmsXHeight;
 RECT otmrcFontBox;
 int otmMacAscent;
 int otmMacDescent;
 UINT otmMacLineGap;
 UINT otmusMinimumPPEM;
 POINT otmptSubscriptSize;
 POINT otmptSubscriptOffset;
 POINT otmptSuperscriptSize;
 POINT otmptSuperscriptOffset;
 UINT otmsStrikeoutSize;
 int otmsStrikeoutPosition;
 int otmsUnderscoreSize;
 int otmsUnderscorePosition;
 PSTR otmpFamilyName;
 PSTR otmpFaceName;
 PSTR otmpStyleName;
 PSTR otmpFullName;
} OUTLINETEXTMETRICW,*POUTLINETEXTMETRICW,*LPOUTLINETEXTMETRICW;
typedef struct _RASTERIZER_STATUS {
 short nSize;
 short wFlags;
 short nLanguageID;
} RASTERIZER_STATUS,*LPRASTERIZER_STATUS;
typedef struct _POLYTEXTA {
 int x;
 int y;
 UINT n;
 LPCSTR lpstr;
 UINT uiFlags;
 RECT rcl;
 int *pdx;
} POLYTEXTA, *PPOLYTEXTA, *LPPOLYTEXTA;
typedef struct _POLYTEXTW {
 int x;
 int y;
 UINT n;
 LPCWSTR lpstr;
 UINT uiFlags;
 RECT rcl;
 int *pdx;
} POLYTEXTW, *PPOLYTEXTW, *LPPOLYTEXTW;
typedef struct tagPIXELFORMATDESCRIPTOR {
 WORD nSize;
 WORD nVersion;
 DWORD dwFlags;
 BYTE iPixelType;
 BYTE cColorBits;
 BYTE cRedBits;
 BYTE cRedShift;
 BYTE cGreenBits;
 BYTE cGreenShift;
 BYTE cBlueBits;
 BYTE cBlueShift;
 BYTE cAlphaBits;
 BYTE cAlphaShift;
 BYTE cAccumBits;
 BYTE cAccumRedBits;
 BYTE cAccumGreenBits;
 BYTE cAccumBlueBits;
 BYTE cAccumAlphaBits;
 BYTE cDepthBits;
 BYTE cStencilBits;
 BYTE cAuxBuffers;
 BYTE iLayerType;
 BYTE bReserved;
 DWORD dwLayerMask;
 DWORD dwVisibleMask;
 DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR,*PPIXELFORMATDESCRIPTOR,*LPPIXELFORMATDESCRIPTOR;
typedef struct tagMETAFILEPICT {
 LONG mm;
 LONG xExt;
 LONG yExt;
 HMETAFILE hMF;
} METAFILEPICT,*LPMETAFILEPICT;
typedef struct tagLOCALESIGNATURE {
 DWORD lsUsb[4];
 DWORD lsCsbDefault[2];
 DWORD lsCsbSupported[2];
} LOCALESIGNATURE,*PLOCALESIGNATURE,*LPLOCALESIGNATURE;
typedef LONG LCSTYPE;
#pragma pack(push,4)
typedef struct tagNEWTEXTMETRICA {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 BYTE tmFirstChar;
 BYTE tmLastChar;
 BYTE tmDefaultChar;
 BYTE tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
 DWORD ntmFlags;
 UINT ntmSizeEM;
 UINT ntmCellHeight;
 UINT ntmAvgWidth;
} NEWTEXTMETRICA,*PNEWTEXTMETRICA,*LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 WCHAR tmFirstChar;
 WCHAR tmLastChar;
 WCHAR tmDefaultChar;
 WCHAR tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
 DWORD ntmFlags;
 UINT ntmSizeEM;
 UINT ntmCellHeight;
 UINT ntmAvgWidth;
} NEWTEXTMETRICW,*PNEWTEXTMETRICW,*LPNEWTEXTMETRICW;
#pragma pack(pop)
typedef struct tagNEWTEXTMETRICEXA {
 NEWTEXTMETRICA ntmTm;
 FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW {
 NEWTEXTMETRICW ntmTm;
 FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXW;
typedef struct tagPELARRAY {
 LONG paXCount;
 LONG paYCount;
 LONG paXExt;
 LONG paYExt;
 BYTE paRGBs;
} PELARRAY,*PPELARRAY,*LPPELARRAY;
typedef struct tagENUMLOGFONTA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
} ENUMLOGFONTA,*LPENUMLOGFONTA;
typedef struct tagENUMLOGFONTW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
} ENUMLOGFONTW,*LPENUMLOGFONTW;
typedef struct tagENUMLOGFONTEXA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
 BYTE elfScript[32];
} ENUMLOGFONTEXA,*LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
 WCHAR elfScript[32];
} ENUMLOGFONTEXW,*LPENUMLOGFONTEXW;
typedef struct tagPOINTFX {
 FIXED x;
 FIXED y;
} POINTFX,*LPPOINTFX;
typedef struct tagTTPOLYCURVE {
 WORD wType;
 WORD cpfx;
 POINTFX apfx[1];
} TTPOLYCURVE,*LPTTPOLYCURVE;
typedef struct tagTTPOLYGONHEADER {
 DWORD cb;
 DWORD dwType;
 POINTFX pfxStart;
} TTPOLYGONHEADER,*LPTTPOLYGONHEADER;
typedef struct _POINTFLOAT {
 FLOAT x;
 FLOAT y;
} POINTFLOAT,*PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
 FLOAT gmfBlackBoxX;
 FLOAT gmfBlackBoxY;
 POINTFLOAT gmfptGlyphOrigin;
 FLOAT gmfCellIncX;
 FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT,*PGLYPHMETRICSFLOAT,*LPGLYPHMETRICSFLOAT;
typedef struct tagLAYERPLANEDESCRIPTOR {
 WORD nSize;
 WORD nVersion;
 DWORD dwFlags;
 BYTE iPixelType;
 BYTE cColorBits;
 BYTE cRedBits;
 BYTE cRedShift;
 BYTE cGreenBits;
 BYTE cGreenShift;
 BYTE cBlueBits;
 BYTE cBlueShift;
 BYTE cAlphaBits;
 BYTE cAlphaShift;
 BYTE cAccumBits;
 BYTE cAccumRedBits;
 BYTE cAccumGreenBits;
 BYTE cAccumBlueBits;
 BYTE cAccumAlphaBits;
 BYTE cDepthBits;
 BYTE cStencilBits;
 BYTE cAuxBuffers;
 BYTE iLayerPlane;
 BYTE bReserved;
 COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR,*PLAYERPLANEDESCRIPTOR,*LPLAYERPLANEDESCRIPTOR;
typedef struct _BLENDFUNCTION {
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
} BLENDFUNCTION,*PBLENDFUNCTION,*LPBLENDFUNCTION;

typedef struct _DESIGNVECTOR {
 DWORD dvReserved;
 DWORD dvNumAxes;
 LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;
# 2618 "C:/upp/mingw/include/wingdi.h" 3
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {
 LONG x;
 LONG y;
 COLOR16 Red;
 COLOR16 Green;
 COLOR16 Blue;
 COLOR16 Alpha;
} TRIVERTEX, *PTRIVERTEX, *LPTRIVERTEX;
typedef struct _GRADIENT_TRIANGLE {
 ULONG Vertex1;
 ULONG Vertex2;
 ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT {
 ULONG UpperLeft;
 ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;
typedef struct _DISPLAY_DEVICEA {
  DWORD cb;
  CHAR DeviceName[32];
  CHAR DeviceString[128];
  DWORD StateFlags;
  CHAR DeviceID[128];
  CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
  DWORD cb;
  WCHAR DeviceName[32];
  WCHAR DeviceString[128];
  DWORD StateFlags;
  WCHAR DeviceID[128];
  WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;

typedef BOOL (__attribute__((__stdcall__)) *ABORTPROC)(HDC,int);
typedef int (__attribute__((__stdcall__)) *MFENUMPROC)(HDC,HANDLETABLE*,METARECORD*,int,LPARAM);
typedef int (__attribute__((__stdcall__)) *ENHMFENUMPROC)(HDC,HANDLETABLE*,ENHMETARECORD*,int,LPARAM);
typedef int (__attribute__((__stdcall__)) *OLDFONTENUMPROCA)(const LOGFONTA*,const TEXTMETRICA*,DWORD,LPARAM);
typedef int (__attribute__((__stdcall__)) *OLDFONTENUMPROCW)(const LOGFONTW*,const TEXTMETRICW*,DWORD,LPARAM);
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;
typedef int (__attribute__((__stdcall__)) *ICMENUMPROCA)(LPSTR,LPARAM);
typedef int (__attribute__((__stdcall__)) *ICMENUMPROCW)(LPWSTR,LPARAM);
typedef void (__attribute__((__stdcall__)) *GOBJENUMPROC)(LPVOID,LPARAM);
typedef void (__attribute__((__stdcall__)) *LINEDDAPROC)(int,int,LPARAM);
typedef UINT (__attribute__((__stdcall__)) *LPFNDEVMODE)(HWND,HMODULE,LPDEVMODEA,LPSTR,LPSTR,LPDEVMODEA,LPSTR,UINT);
typedef DWORD (__attribute__((__stdcall__)) *LPFNDEVCAPS)(LPSTR,LPSTR,UINT,LPSTR,LPDEVMODEA);
# 2684 "C:/upp/mingw/include/wingdi.h" 3
 int __attribute__((__stdcall__)) AbortDoc(HDC);
 BOOL __attribute__((__stdcall__)) AbortPath(HDC);
 int __attribute__((__stdcall__)) AddFontResourceA(LPCSTR);
 int __attribute__((__stdcall__)) AddFontResourceW(LPCWSTR);





 BOOL __attribute__((__stdcall__)) AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
 BOOL __attribute__((__stdcall__)) AnimatePalette(HPALETTE,UINT,UINT,const PALETTEENTRY*);
 BOOL __attribute__((__stdcall__)) Arc(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) ArcTo(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) BeginPath(HDC);
 BOOL __attribute__((__stdcall__)) BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
 BOOL __attribute__((__stdcall__)) CancelDC(HDC);
 BOOL __attribute__((__stdcall__)) CheckColorsInGamut(HDC,PVOID,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) Chord(HDC,int,int,int,int,int,int,int,int);
 int __attribute__((__stdcall__)) ChoosePixelFormat(HDC,const PIXELFORMATDESCRIPTOR*);
 HENHMETAFILE __attribute__((__stdcall__)) CloseEnhMetaFile(HDC);
 BOOL __attribute__((__stdcall__)) CloseFigure(HDC);
 HMETAFILE __attribute__((__stdcall__)) CloseMetaFile(HDC);




 int __attribute__((__stdcall__)) CombineRgn(HRGN,HRGN,HRGN,int);
 BOOL __attribute__((__stdcall__)) CombineTransform(LPXFORM,const XFORM*,const XFORM*);
 HENHMETAFILE __attribute__((__stdcall__)) CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
 HENHMETAFILE __attribute__((__stdcall__)) CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
 HMETAFILE __attribute__((__stdcall__)) CopyMetaFileA(HMETAFILE,LPCSTR);
 HMETAFILE __attribute__((__stdcall__)) CopyMetaFileW(HMETAFILE,LPCWSTR);
 HBITMAP __attribute__((__stdcall__)) CreateBitmap(int,int,UINT,UINT,PCVOID);
 HBITMAP __attribute__((__stdcall__)) CreateBitmapIndirect(const BITMAP*);
 HBRUSH __attribute__((__stdcall__)) CreateBrushIndirect(const LOGBRUSH*);
 HCOLORSPACE __attribute__((__stdcall__)) CreateColorSpaceA(LPLOGCOLORSPACEA);
 HCOLORSPACE __attribute__((__stdcall__)) CreateColorSpaceW(LPLOGCOLORSPACEW);
 HBITMAP __attribute__((__stdcall__)) CreateCompatibleBitmap(HDC,int,int);
 HDC __attribute__((__stdcall__)) CreateCompatibleDC(HDC);
 HDC __attribute__((__stdcall__)) CreateDCA(LPCSTR,LPCSTR,LPCSTR,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR,const DEVMODEW*);
 HBITMAP __attribute__((__stdcall__)) CreateDIBitmap(HDC,const BITMAPINFOHEADER*,DWORD,PCVOID,const BITMAPINFO*,UINT);
 HBRUSH __attribute__((__stdcall__)) CreateDIBPatternBrush(HGLOBAL,UINT);
 HBRUSH __attribute__((__stdcall__)) CreateDIBPatternBrushPt(PCVOID,UINT);
 HBITMAP __attribute__((__stdcall__)) CreateDIBSection(HDC,const BITMAPINFO*,UINT,void**,HANDLE,DWORD);
 HBITMAP __attribute__((__stdcall__)) CreateDiscardableBitmap(HDC,int,int);
 HRGN __attribute__((__stdcall__)) CreateEllipticRgn(int,int,int,int);
 HRGN __attribute__((__stdcall__)) CreateEllipticRgnIndirect(LPCRECT);
 HDC __attribute__((__stdcall__)) CreateEnhMetaFileA(HDC,LPCSTR,LPCRECT,LPCSTR);
 HDC __attribute__((__stdcall__)) CreateEnhMetaFileW(HDC,LPCWSTR,LPCRECT,LPCWSTR);
 HFONT __attribute__((__stdcall__)) CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
 HFONT __attribute__((__stdcall__)) CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
 HFONT __attribute__((__stdcall__)) CreateFontIndirectA(const LOGFONTA*);
 HFONT __attribute__((__stdcall__)) CreateFontIndirectW(const LOGFONTW*);
 HPALETTE __attribute__((__stdcall__)) CreateHalftonePalette(HDC);
 HBRUSH __attribute__((__stdcall__)) CreateHatchBrush(int,COLORREF);
 HDC __attribute__((__stdcall__)) CreateICA(LPCSTR,LPCSTR,LPCSTR,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) CreateICW(LPCWSTR,LPCWSTR,LPCWSTR,const DEVMODEW*);
 HDC __attribute__((__stdcall__)) CreateMetaFileA(LPCSTR);
 HDC __attribute__((__stdcall__)) CreateMetaFileW(LPCWSTR);
 HPALETTE __attribute__((__stdcall__)) CreatePalette(const LOGPALETTE*);
 HBRUSH __attribute__((__stdcall__)) CreatePatternBrush(HBITMAP);
 HPEN __attribute__((__stdcall__)) CreatePen(int,int,COLORREF);
 HPEN __attribute__((__stdcall__)) CreatePenIndirect(const LOGPEN*);
 HRGN __attribute__((__stdcall__)) CreatePolygonRgn(const POINT*,int,int);
 HRGN __attribute__((__stdcall__)) CreatePolyPolygonRgn(const POINT*,const INT*,int,int);
 HRGN __attribute__((__stdcall__)) CreateRectRgn(int,int,int,int);
 HRGN __attribute__((__stdcall__)) CreateRectRgnIndirect(LPCRECT);
 HRGN __attribute__((__stdcall__)) CreateRoundRectRgn(int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
 HBRUSH __attribute__((__stdcall__)) CreateSolidBrush(COLORREF);
 BOOL __attribute__((__stdcall__)) DeleteColorSpace(HCOLORSPACE);
 BOOL __attribute__((__stdcall__)) DeleteDC(HDC);
 BOOL __attribute__((__stdcall__)) DeleteEnhMetaFile(HENHMETAFILE);
 BOOL __attribute__((__stdcall__)) DeleteMetaFile(HMETAFILE);
 BOOL __attribute__((__stdcall__)) DeleteObject(HGDIOBJ);
 int __attribute__((__stdcall__)) DescribePixelFormat(HDC,int,UINT,LPPIXELFORMATDESCRIPTOR);
 DWORD __attribute__((__stdcall__)) DeviceCapabilitiesA(LPCSTR,LPCSTR,WORD,LPSTR,const DEVMODEA*);
 DWORD __attribute__((__stdcall__)) DeviceCapabilitiesW(LPCWSTR,LPCWSTR,WORD,LPWSTR,const DEVMODEW*);
 BOOL __attribute__((__stdcall__)) DPtoLP(HDC,LPPOINT,int);
 int __attribute__((__stdcall__)) DrawEscape(HDC,int,int,LPCSTR);
 BOOL __attribute__((__stdcall__)) Ellipse(HDC,int,int,int,int);
 int __attribute__((__stdcall__)) EndDoc(HDC);
 int __attribute__((__stdcall__)) EndPage(HDC);
 BOOL __attribute__((__stdcall__)) EndPath(HDC);
 BOOL __attribute__((__stdcall__)) EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMFENUMPROC,PVOID,LPCRECT);
 int __attribute__((__stdcall__)) EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
 int __attribute__((__stdcall__)) EnumFontFamiliesExA(HDC,PLOGFONTA,FONTENUMPROCA,LPARAM,DWORD);
 int __attribute__((__stdcall__)) EnumFontFamiliesExW(HDC,PLOGFONTW,FONTENUMPROCW,LPARAM,DWORD);
 int __attribute__((__stdcall__)) EnumFontsA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumFontsW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
 int __attribute__((__stdcall__)) EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumMetaFile(HDC,HMETAFILE,MFENUMPROC,LPARAM);
 int __attribute__((__stdcall__)) EnumObjects(HDC,int,GOBJENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EqualRgn(HRGN,HRGN);
 int __attribute__((__stdcall__)) Escape(HDC,int,int,LPCSTR,PVOID);
 int __attribute__((__stdcall__)) ExcludeClipRect(HDC,int,int,int,int);
 int __attribute__((__stdcall__)) ExcludeUpdateRgn(HDC,HWND);
 HPEN __attribute__((__stdcall__)) ExtCreatePen(DWORD,DWORD,const LOGBRUSH*,DWORD,const DWORD*);
 HRGN __attribute__((__stdcall__)) ExtCreateRegion(const XFORM*,DWORD,const RGNDATA*);
 int __attribute__((__stdcall__)) ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
 BOOL __attribute__((__stdcall__)) ExtFloodFill(HDC,int,int,COLORREF,UINT);
 int __attribute__((__stdcall__)) ExtSelectClipRgn(HDC,HRGN,int);
 BOOL __attribute__((__stdcall__)) ExtTextOutA(HDC,int,int,UINT,LPCRECT,LPCSTR,UINT,const INT*);
 BOOL __attribute__((__stdcall__)) ExtTextOutW(HDC,int,int,UINT,LPCRECT,LPCWSTR,UINT,const INT*);
 BOOL __attribute__((__stdcall__)) FillPath(HDC);
 int __attribute__((__stdcall__)) FillRect(HDC,LPCRECT,HBRUSH);
 int __attribute__((__stdcall__)) FillRgn(HDC,HRGN,HBRUSH);
 BOOL __attribute__((__stdcall__)) FixBrushOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) FlattenPath(HDC);
 BOOL __attribute__((__stdcall__)) FloodFill(HDC,int,int,COLORREF);
 BOOL __attribute__((__stdcall__)) GdiComment(HDC,UINT,const BYTE*);
 BOOL __attribute__((__stdcall__)) GdiFlush(void);
 DWORD __attribute__((__stdcall__)) GdiGetBatchLimit(void);
 DWORD __attribute__((__stdcall__)) GdiSetBatchLimit(DWORD);
 int __attribute__((__stdcall__)) GetArcDirection(HDC);
 BOOL __attribute__((__stdcall__)) GetAspectRatioFilterEx(HDC,LPSIZE);
 LONG __attribute__((__stdcall__)) GetBitmapBits(HBITMAP,LONG,PVOID);
 BOOL __attribute__((__stdcall__)) GetBitmapDimensionEx(HBITMAP,LPSIZE);
 COLORREF __attribute__((__stdcall__)) GetBkColor(HDC);
 int __attribute__((__stdcall__)) GetBkMode(HDC);
 UINT __attribute__((__stdcall__)) GetBoundsRect(HDC,LPRECT,UINT);
 BOOL __attribute__((__stdcall__)) GetBrushOrgEx(HDC,LPPOINT);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
 DWORD __attribute__((__stdcall__)) GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTSA,DWORD);
 DWORD __attribute__((__stdcall__)) GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD);
 BOOL __attribute__((__stdcall__)) GetCharWidth32A(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidth32W(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthA(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthW(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
 BOOL __attribute__((__stdcall__)) GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
 int __attribute__((__stdcall__)) GetClipBox(HDC,LPRECT);
 int __attribute__((__stdcall__)) GetClipRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
 HANDLE __attribute__((__stdcall__)) GetColorSpace(HDC);
 HGDIOBJ __attribute__((__stdcall__)) GetCurrentObject(HDC,UINT);
 BOOL __attribute__((__stdcall__)) GetCurrentPositionEx(HDC,LPPOINT);
 HCURSOR __attribute__((__stdcall__)) GetCursor(void);




 BOOL __attribute__((__stdcall__)) GetDCOrgEx(HDC,LPPOINT);
 int __attribute__((__stdcall__)) GetDeviceCaps(HDC,int);
 BOOL __attribute__((__stdcall__)) GetDeviceGammaRamp(HDC,PVOID);
 UINT __attribute__((__stdcall__)) GetDIBColorTable(HDC,UINT,UINT,RGBQUAD*);
 int __attribute__((__stdcall__)) GetDIBits(HDC,HBITMAP,UINT,UINT,PVOID,LPBITMAPINFO,UINT);
 HENHMETAFILE __attribute__((__stdcall__)) GetEnhMetaFileA(LPCSTR);
 HENHMETAFILE __attribute__((__stdcall__)) GetEnhMetaFileW(LPCWSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileBits(HENHMETAFILE,UINT,LPBYTE);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER);
 UINT __attribute__((__stdcall__)) GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY);
 UINT __attribute__((__stdcall__)) GetEnhMetaFilePixelFormat(HENHMETAFILE,DWORD,const PIXELFORMATDESCRIPTOR*);
 DWORD __attribute__((__stdcall__)) GetFontData(HDC,DWORD,DWORD,PVOID,DWORD);
 DWORD __attribute__((__stdcall__)) GetFontLanguageInfo(HDC);
 DWORD __attribute__((__stdcall__)) GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,const MAT2*);
 DWORD __attribute__((__stdcall__)) GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,const MAT2*);
 int __attribute__((__stdcall__)) GetGraphicsMode(HDC);
 BOOL __attribute__((__stdcall__)) GetICMProfileA(HDC,LPDWORD,LPSTR);
 BOOL __attribute__((__stdcall__)) GetICMProfileW(HDC,LPDWORD,LPWSTR);
 DWORD __attribute__((__stdcall__)) GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
 DWORD __attribute__((__stdcall__)) GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
 BOOL __attribute__((__stdcall__)) GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
 BOOL __attribute__((__stdcall__)) GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
 int __attribute__((__stdcall__)) GetMapMode(HDC);
 HMETAFILE __attribute__((__stdcall__)) GetMetaFileA(LPCSTR);
 HMETAFILE __attribute__((__stdcall__)) GetMetaFileW(LPCWSTR);
 UINT __attribute__((__stdcall__)) GetMetaFileBitsEx(HMETAFILE,UINT,PVOID);
 int __attribute__((__stdcall__)) GetMetaRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) GetMiterLimit(HDC,PFLOAT);
 COLORREF __attribute__((__stdcall__)) GetNearestColor(HDC,COLORREF);
 UINT __attribute__((__stdcall__)) GetNearestPaletteIndex(HPALETTE,COLORREF);
 int __attribute__((__stdcall__)) GetObjectA(HGDIOBJ,int,PVOID);
 int __attribute__((__stdcall__)) GetObjectW(HGDIOBJ,int,PVOID);
 DWORD __attribute__((__stdcall__)) GetObjectType(HGDIOBJ);
 UINT __attribute__((__stdcall__)) GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRICA);
 UINT __attribute__((__stdcall__)) GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRICW);
 UINT __attribute__((__stdcall__)) GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
 int __attribute__((__stdcall__)) GetPath(HDC,LPPOINT,PBYTE,int);
 COLORREF __attribute__((__stdcall__)) GetPixel(HDC,int,int);
 int __attribute__((__stdcall__)) GetPixelFormat(HDC);
 int __attribute__((__stdcall__)) GetPolyFillMode(HDC);
 BOOL __attribute__((__stdcall__)) GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
 int __attribute__((__stdcall__)) GetRandomRgn (HDC,HRGN,INT);
 DWORD __attribute__((__stdcall__)) GetRegionData(HRGN,DWORD,LPRGNDATA);
 int __attribute__((__stdcall__)) GetRgnBox(HRGN,LPRECT);
 int __attribute__((__stdcall__)) GetROP2(HDC);
 HGDIOBJ __attribute__((__stdcall__)) GetStockObject(int);
 int __attribute__((__stdcall__)) GetStretchBltMode(HDC);
 UINT __attribute__((__stdcall__)) GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
 UINT __attribute__((__stdcall__)) GetSystemPaletteUse(HDC);
 UINT __attribute__((__stdcall__)) GetTextAlign(HDC);
 int __attribute__((__stdcall__)) GetTextCharacterExtra(HDC);
 int __attribute__((__stdcall__)) GetTextCharset(HDC);
 int __attribute__((__stdcall__)) GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
 COLORREF __attribute__((__stdcall__)) GetTextColor(HDC);
 BOOL __attribute__((__stdcall__)) GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
 BOOL __attribute__((__stdcall__)) GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);







 BOOL __attribute__((__stdcall__)) GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);

 int __attribute__((__stdcall__)) GetTextFaceA(HDC,int,LPSTR);
 int __attribute__((__stdcall__)) GetTextFaceW(HDC,int,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetTextMetricsA(HDC,LPTEXTMETRICA);
 BOOL __attribute__((__stdcall__)) GetTextMetricsW(HDC,LPTEXTMETRICW);
 BOOL __attribute__((__stdcall__)) GetViewportExtEx(HDC,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetViewportOrgEx(HDC,LPPOINT);
 BOOL __attribute__((__stdcall__)) GetWindowExtEx(HDC,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetWindowOrgEx(HDC,LPPOINT);
 UINT __attribute__((__stdcall__)) GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
 BOOL __attribute__((__stdcall__)) GetWorldTransform(HDC,LPXFORM);
 int __attribute__((__stdcall__)) IntersectClipRect(HDC,int,int,int,int);
 BOOL __attribute__((__stdcall__)) InvertRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) LineDDA(int,int,int,int,LINEDDAPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) LineTo(HDC,int,int);
 BOOL __attribute__((__stdcall__)) LPtoDP(HDC,LPPOINT,int);
 BOOL __attribute__((__stdcall__)) MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
 BOOL __attribute__((__stdcall__)) ModifyWorldTransform(HDC,const XFORM*,DWORD);
 BOOL __attribute__((__stdcall__)) MoveToEx(HDC,int,int,LPPOINT);
 int __attribute__((__stdcall__)) OffsetClipRgn(HDC,int,int);
 int __attribute__((__stdcall__)) OffsetRgn(HRGN,int,int);
 BOOL __attribute__((__stdcall__)) OffsetViewportOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) OffsetWindowOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) PaintRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) PatBlt(HDC,int,int,int,int,DWORD);
 HRGN __attribute__((__stdcall__)) PathToRegion(HDC);
 BOOL __attribute__((__stdcall__)) Pie(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) PlayEnhMetaFile(HDC,HENHMETAFILE,LPCRECT);
 BOOL __attribute__((__stdcall__)) PlayEnhMetaFileRecord(HDC,LPHANDLETABLE,const ENHMETARECORD*,UINT);
 BOOL __attribute__((__stdcall__)) PlayMetaFile(HDC,HMETAFILE);
 BOOL __attribute__((__stdcall__)) PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
 BOOL __attribute__((__stdcall__)) PlgBlt(HDC,const POINT*,HDC,int,int,int,int,HBITMAP,int,int);
 BOOL __attribute__((__stdcall__)) PolyBezier(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyBezierTo(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyDraw(HDC,const POINT*,const BYTE*,int);
 BOOL __attribute__((__stdcall__)) Polygon(HDC,const POINT*,int);
 BOOL __attribute__((__stdcall__)) Polyline(HDC,const POINT*,int);
 BOOL __attribute__((__stdcall__)) PolylineTo(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyPolygon(HDC,const POINT*,const INT*,int);
 BOOL __attribute__((__stdcall__)) PolyPolyline(HDC,const POINT*,const DWORD*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyTextOutA(HDC,const POLYTEXTA*,int);
 BOOL __attribute__((__stdcall__)) PolyTextOutW(HDC,const POLYTEXTW*,int);
 BOOL __attribute__((__stdcall__)) PtInRegion(HRGN,int,int);
 BOOL __attribute__((__stdcall__)) PtVisible(HDC,int,int);
 UINT __attribute__((__stdcall__)) RealizePalette(HDC);
 BOOL __attribute__((__stdcall__)) Rectangle(HDC,int,int,int,int);
 BOOL __attribute__((__stdcall__)) RectInRegion(HRGN,LPCRECT);
 BOOL __attribute__((__stdcall__)) RectVisible(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) RemoveFontResourceA(LPCSTR);
 BOOL __attribute__((__stdcall__)) RemoveFontResourceW(LPCWSTR);





 HDC __attribute__((__stdcall__)) ResetDCA(HDC,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) ResetDCW(HDC,const DEVMODEW*);
 BOOL __attribute__((__stdcall__)) ResizePalette(HPALETTE,UINT);
 BOOL __attribute__((__stdcall__)) RestoreDC(HDC,int);
 BOOL __attribute__((__stdcall__)) RoundRect(HDC,int,int,int,int,int,int);
 int __attribute__((__stdcall__)) SaveDC(HDC);
 BOOL __attribute__((__stdcall__)) ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SelectClipPath(HDC,int);
 int __attribute__((__stdcall__)) SelectClipRgn(HDC,HRGN);
 HGDIOBJ __attribute__((__stdcall__)) SelectObject(HDC,HGDIOBJ);
 HPALETTE __attribute__((__stdcall__)) SelectPalette(HDC,HPALETTE,BOOL);
 int __attribute__((__stdcall__)) SetAbortProc(HDC,ABORTPROC);
 int __attribute__((__stdcall__)) SetArcDirection(HDC,int);
 LONG __attribute__((__stdcall__)) SetBitmapBits(HBITMAP,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
 COLORREF __attribute__((__stdcall__)) SetBkColor(HDC,COLORREF);
 int __attribute__((__stdcall__)) SetBkMode(HDC,int);
 UINT __attribute__((__stdcall__)) SetBoundsRect(HDC,LPCRECT,UINT);
 BOOL __attribute__((__stdcall__)) SetBrushOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) SetColorAdjustment(HDC,const COLORADJUSTMENT*);
 BOOL __attribute__((__stdcall__)) SetColorSpace(HDC,HCOLORSPACE);




 BOOL __attribute__((__stdcall__)) SetDeviceGammaRamp(HDC,PVOID);
 UINT __attribute__((__stdcall__)) SetDIBColorTable(HDC,UINT,UINT,const RGBQUAD*);
 int __attribute__((__stdcall__)) SetDIBits(HDC,HBITMAP,UINT,UINT,PCVOID,const BITMAPINFO*,UINT);
 int __attribute__((__stdcall__)) SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,const BITMAPINFO*,UINT);
 HENHMETAFILE __attribute__((__stdcall__)) SetEnhMetaFileBits(UINT,const BYTE*);
 int __attribute__((__stdcall__)) SetGraphicsMode(HDC,int);
 int __attribute__((__stdcall__)) SetICMMode(HDC,int);
 BOOL __attribute__((__stdcall__)) SetICMProfileA(HDC,LPSTR);
 BOOL __attribute__((__stdcall__)) SetICMProfileW(HDC,LPWSTR);
 int __attribute__((__stdcall__)) SetMapMode(HDC,int);
 DWORD __attribute__((__stdcall__)) SetMapperFlags(HDC,DWORD);
 HMETAFILE __attribute__((__stdcall__)) SetMetaFileBitsEx(UINT,const BYTE *);
 int __attribute__((__stdcall__)) SetMetaRgn(HDC);
 BOOL __attribute__((__stdcall__)) SetMiterLimit(HDC,FLOAT,PFLOAT);
 UINT __attribute__((__stdcall__)) SetPaletteEntries(HPALETTE,UINT,UINT,const PALETTEENTRY*);
 COLORREF __attribute__((__stdcall__)) SetPixel(HDC,int,int,COLORREF);
 BOOL __attribute__((__stdcall__)) SetPixelFormat(HDC,int,const PIXELFORMATDESCRIPTOR*);
 BOOL __attribute__((__stdcall__)) SetPixelV(HDC,int,int,COLORREF);
 int __attribute__((__stdcall__)) SetPolyFillMode(HDC,int);
 BOOL __attribute__((__stdcall__)) SetRectRgn(HRGN,int,int,int,int);
 int __attribute__((__stdcall__)) SetROP2(HDC,int);
 int __attribute__((__stdcall__)) SetStretchBltMode(HDC,int);
 UINT __attribute__((__stdcall__)) SetSystemPaletteUse(HDC,UINT);
 UINT __attribute__((__stdcall__)) SetTextAlign(HDC,UINT);
 int __attribute__((__stdcall__)) SetTextCharacterExtra(HDC,int);
 COLORREF __attribute__((__stdcall__)) SetTextColor(HDC,COLORREF);
 BOOL __attribute__((__stdcall__)) SetTextJustification(HDC,int,int);
 BOOL __attribute__((__stdcall__)) SetViewportExtEx(HDC,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SetViewportOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) SetWindowExtEx(HDC,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SetWindowOrgEx(HDC,int,int,LPPOINT);
 HENHMETAFILE __attribute__((__stdcall__)) SetWinMetaFileBits(UINT,const BYTE*,HDC,const METAFILEPICT*);
 BOOL __attribute__((__stdcall__)) SetWorldTransform(HDC,const XFORM *);
 int __attribute__((__stdcall__)) StartDocA(HDC,const DOCINFOA*);
 int __attribute__((__stdcall__)) StartDocW(HDC,const DOCINFOW*);
 int __attribute__((__stdcall__)) StartPage(HDC);
 BOOL __attribute__((__stdcall__)) StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
 int __attribute__((__stdcall__)) StretchDIBits(HDC,int,int,int,int,int,int,int,int,const void *,const BITMAPINFO *,UINT,DWORD);
 BOOL __attribute__((__stdcall__)) StrokeAndFillPath(HDC);
 BOOL __attribute__((__stdcall__)) StrokePath(HDC);
 BOOL __attribute__((__stdcall__)) SwapBuffers(HDC);
 BOOL __attribute__((__stdcall__)) TextOutA(HDC,int,int,LPCSTR,int);
 BOOL __attribute__((__stdcall__)) TextOutW(HDC,int,int,LPCWSTR,int);
 BOOL __attribute__((__stdcall__)) TranslateCharsetInfo(PDWORD,LPCHARSETINFO,DWORD);
 BOOL __attribute__((__stdcall__)) UnrealizeObject(HGDIOBJ);
 BOOL __attribute__((__stdcall__)) UpdateColors(HDC);
 BOOL __attribute__((__stdcall__)) UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
 BOOL __attribute__((__stdcall__)) UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) WidenPath(HDC);
 BOOL __attribute__((__stdcall__)) wglCopyContext(HGLRC,HGLRC,UINT);
 HGLRC __attribute__((__stdcall__)) wglCreateContext(HDC);
 HGLRC __attribute__((__stdcall__)) wglCreateLayerContext(HDC,int);
 BOOL __attribute__((__stdcall__)) wglDeleteContext(HGLRC);
 BOOL __attribute__((__stdcall__)) wglDescribeLayerPlane(HDC,int,int,UINT,LPLAYERPLANEDESCRIPTOR);
 HGLRC __attribute__((__stdcall__)) wglGetCurrentContext(void);
 HDC __attribute__((__stdcall__)) wglGetCurrentDC(void);
 int __attribute__((__stdcall__)) wglGetLayerPaletteEntries(HDC,int,int,int,COLORREF*);
 PROC __attribute__((__stdcall__)) wglGetProcAddress(LPCSTR);
 BOOL __attribute__((__stdcall__)) wglMakeCurrent(HDC,HGLRC);
 BOOL __attribute__((__stdcall__)) wglRealizeLayerPalette(HDC,int,BOOL);
 int __attribute__((__stdcall__)) wglSetLayerPaletteEntries(HDC,int,int,int,const COLORREF*);
 BOOL __attribute__((__stdcall__)) wglShareLists(HGLRC,HGLRC);
 BOOL __attribute__((__stdcall__)) wglSwapLayerBuffers(HDC,UINT);
 BOOL __attribute__((__stdcall__)) wglUseFontBitmapsA(HDC,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) wglUseFontBitmapsW(HDC,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) wglUseFontOutlinesA(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
 BOOL __attribute__((__stdcall__)) wglUseFontOutlinesW(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
# 3144 "C:/upp/mingw/include/wingdi.h" 3
typedef BYTE BCHAR;
typedef DOCINFOA DOCINFO, *LPDOCINFO;
typedef LOGFONTA LOGFONT,*PLOGFONT,*LPLOGFONT;
typedef TEXTMETRICA TEXTMETRIC,*PTEXTMETRIC,*LPTEXTMETRIC;


typedef DEVMODEA DEVMODE,*PDEVMODE,*LPDEVMODE;





typedef EXTLOGFONTA EXTLOGFONT,*PEXTLOGFONT,*LPEXTLOGFONT;
typedef GCP_RESULTSA GCP_RESULTS,*LPGCP_RESULTS;
typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC,*POUTLINETEXTMETRIC,*LPOUTLINETEXTMETRIC;
typedef POLYTEXTA POLYTEXT,*PPOLYTEXT,*LPPOLYTEXT;
typedef LOGCOLORSPACEA LOGCOLORSPACE,*LPLOGCOLORSPACE;
typedef NEWTEXTMETRICA NEWTEXTMETRIC,*PNEWTEXTMETRIC,*LPNEWTEXTMETRIC;
typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
typedef ENUMLOGFONTA ENUMLOGFONT,*LPENUMLOGFONT;
typedef ENUMLOGFONTEXA ENUMLOGFONTEX,*LPENUMLOGFONTEX;
typedef DISPLAY_DEVICEA DISPLAY_DEVICE, *PDISPLAY_DEVICE, *LPDISPLAY_DEVICE;
# 3224 "C:/upp/mingw/include/wingdi.h" 3
}
# 53 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winuser.h" 1 3



       
# 5 "C:/upp/mingw/include/winuser.h" 3



extern "C" {
# 2462 "C:/upp/mingw/include/winuser.h" 3
typedef BOOL(__attribute__((__stdcall__)) *DLGPROC)(HWND,UINT,WPARAM,LPARAM);
typedef void(__attribute__((__stdcall__)) *TIMERPROC)(HWND,UINT,UINT,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *GRAYSTRINGPROC)(HDC,LPARAM,int);
typedef LRESULT(__attribute__((__stdcall__)) *HOOKPROC)(int,WPARAM,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCA)(HWND,LPCSTR,HANDLE);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCW)(HWND,LPCWSTR,HANDLE);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCEXA)(HWND,LPSTR,HANDLE,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCEXW)(HWND,LPWSTR,HANDLE,DWORD);
typedef int(__attribute__((__stdcall__)) *EDITWORDBREAKPROCA)(LPSTR,int,int,int);
typedef int(__attribute__((__stdcall__)) *EDITWORDBREAKPROCW)(LPWSTR,int,int,int);
typedef LRESULT(__attribute__((__stdcall__)) *WNDPROC)(HWND,UINT,WPARAM,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *DRAWSTATEPROC)(HDC,LPARAM,WPARAM,int,int);
typedef BOOL(__attribute__((__stdcall__)) *WNDENUMPROC)(HWND,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *ENUMWINDOWSPROC)(HWND,LPARAM);
typedef BOOL(__attribute__((__stdcall__))* MONITORENUMPROC)(HMONITOR,HDC,LPRECT,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *NAMEENUMPROCA)(LPSTR,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *NAMEENUMPROCW)(LPWSTR,LPARAM);
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef void(__attribute__((__stdcall__)) *SENDASYNCPROC)(HWND,UINT,DWORD,LRESULT);
typedef struct HHOOK__{int i;}*HHOOK;
typedef struct HDWP__{int i;}*HDWP;
typedef struct HDEVNOTIFY__{int i;}*HDEVNOTIFY;
typedef struct tagACCEL {
 BYTE fVirt;
 WORD key;
 WORD cmd;
} ACCEL,*LPACCEL;
typedef struct tagACCESSTIMEOUT {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;
typedef struct tagANIMATIONINFO {
 UINT cbSize;
 int iMinAnimate;
} ANIMATIONINFO,*LPANIMATIONINFO;
typedef struct tagCREATESTRUCTA {
 LPVOID lpCreateParams;
 HINSTANCE hInstance;
 HMENU hMenu;
 HWND hwndParent;
 int cy;
 int cx;
 int y;
 int x;
 LONG style;
 LPCSTR lpszName;
 LPCSTR lpszClass;
 DWORD dwExStyle;
} CREATESTRUCTA,*LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
 LPVOID lpCreateParams;
 HINSTANCE hInstance;
 HMENU hMenu;
 HWND hwndParent;
 int cy;
 int cx;
 int y;
 int x;
 LONG style;
 LPCWSTR lpszName;
 LPCWSTR lpszClass;
 DWORD dwExStyle;
} CREATESTRUCTW,*LPCREATESTRUCTW;
typedef struct tagCBT_CREATEWNDA {
 LPCREATESTRUCTA lpcs;
 HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
typedef struct tagCBT_CREATEWNDW {
 LPCREATESTRUCTW lpcs;
 HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
typedef struct tagCBTACTIVATESTRUCT {
 BOOL fMouse;
 HWND hWndActive;
} CBTACTIVATESTRUCT,*LPCBTACTIVATESTRUCT;
typedef struct tagCLIENTCREATESTRUCT {
 HANDLE hWindowMenu;
 UINT idFirstChild;
} CLIENTCREATESTRUCT,*LPCLIENTCREATESTRUCT;
typedef struct tagCOMPAREITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 HWND hwndItem;
 UINT itemID1;
 DWORD itemData1;
 UINT itemID2;
 DWORD itemData2;
 DWORD dwLocaleId;
} COMPAREITEMSTRUCT,*LPCOMPAREITEMSTRUCT;
typedef struct tagCOPYDATASTRUCT {
 DWORD dwData;
 DWORD cbData;
 PVOID lpData;
} COPYDATASTRUCT,*PCOPYDATASTRUCT;
typedef struct tagCURSORSHAPE {
 int xHotSpot;
 int yHotSpot;
 int cx;
 int cy;
 int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE,*LPCURSORSHAPE;
typedef struct tagCWPRETSTRUCT {
 LRESULT lResult;
 LPARAM lParam;
 WPARAM wParam;
 DWORD message;
 HWND hwnd;
} CWPRETSTRUCT;
typedef struct tagCWPSTRUCT {
 LPARAM lParam;
 WPARAM wParam;
 UINT message;
 HWND hwnd;
} CWPSTRUCT,*PCWPSTRUCT;
typedef struct tagDEBUGHOOKINFO {
 DWORD idThread;
 DWORD idThreadInstaller;
 LPARAM lParam;
 WPARAM wParam;
 int code;
} DEBUGHOOKINFO,*PDEBUGHOOKINFO,*LPDEBUGHOOKINFO;
typedef struct tagDELETEITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 HWND hwndItem;
 UINT itemData;
} DELETEITEMSTRUCT,*PDELETEITEMSTRUCT,*LPDELETEITEMSTRUCT;
#pragma pack(push,2)
typedef struct {
 DWORD style;
 DWORD dwExtendedStyle;
 short x;
 short y;
 short cx;
 short cy;
 WORD id;
} DLGITEMTEMPLATE,*LPDLGITEMTEMPLATE;
typedef struct {
 DWORD style;
 DWORD dwExtendedStyle;
 WORD cdit;
 short x;
 short y;
 short cx;
 short cy;
} DLGTEMPLATE,*LPDLGTEMPLATE,*LPDLGTEMPLATEA,*LPDLGTEMPLATEW;
typedef const DLGTEMPLATE *LPCDLGTEMPLATE;
#pragma pack(pop)
typedef struct tagDRAWITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 UINT itemAction;
 UINT itemState;
 HWND hwndItem;
 HDC hDC;
 RECT rcItem;
 DWORD itemData;
} DRAWITEMSTRUCT,*LPDRAWITEMSTRUCT,*PDRAWITEMSTRUCT;
typedef struct {
 UINT cbSize;
 int iTabLength;
 int iLeftMargin;
 int iRightMargin;
 UINT uiLengthDrawn;
} DRAWTEXTPARAMS,*LPDRAWTEXTPARAMS;
typedef struct tagPAINTSTRUCT {
 HDC hdc;
 BOOL fErase;
 RECT rcPaint;
 BOOL fRestore;
 BOOL fIncUpdate;
 BYTE rgbReserved[32];
} PAINTSTRUCT,*LPPAINTSTRUCT;
typedef struct tagMSG {
 HWND hwnd;
 UINT message;
 WPARAM wParam;
 LPARAM lParam;
 DWORD time;
 POINT pt;
} MSG,*LPMSG,*PMSG;
typedef struct _ICONINFO {
 BOOL fIcon;
 DWORD xHotspot;
 DWORD yHotspot;
 HBITMAP hbmMask;
 HBITMAP hbmColor;
} ICONINFO,*PICONINFO;
typedef struct tagNMHDR {
 HWND hwndFrom;
 UINT idFrom;
 UINT code;
} NMHDR,*LPNMHDR;
typedef struct _WNDCLASSA {
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCSTR lpszMenuName;
 LPCSTR lpszClassName;
} WNDCLASSA,*LPWNDCLASSA,*PWNDCLASSA;
typedef struct _WNDCLASSW {
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCWSTR lpszMenuName;
 LPCWSTR lpszClassName;
} WNDCLASSW,*LPWNDCLASSW,*PWNDCLASSW;
typedef struct _WNDCLASSEXA {
 UINT cbSize;
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCSTR lpszMenuName;
 LPCSTR lpszClassName;
 HICON hIconSm;
} WNDCLASSEXA,*LPWNDCLASSEXA,*PWNDCLASSEXA;
typedef struct _WNDCLASSEXW {
 UINT cbSize;
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCWSTR lpszMenuName;
 LPCWSTR lpszClassName;
 HICON hIconSm;
} WNDCLASSEXW,*LPWNDCLASSEXW,*PWNDCLASSEXW;
typedef struct tagMENUITEMINFOA {
 UINT cbSize;
 UINT fMask;
 UINT fType;
 UINT fState;
 UINT wID;
 HMENU hSubMenu;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 LPSTR dwTypeData;
 UINT cch;



} MENUITEMINFOA,*LPMENUITEMINFOA;
typedef const MENUITEMINFOA *LPCMENUITEMINFOA;
typedef struct tagMENUITEMINFOW {
 UINT cbSize;
 UINT fMask;
 UINT fType;
 UINT fState;
 UINT wID;
 HMENU hSubMenu;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 LPWSTR dwTypeData;
 UINT cch;



} MENUITEMINFOW,*LPMENUITEMINFOW;
typedef const MENUITEMINFOW *LPCMENUITEMINFOW;
typedef struct tagSCROLLINFO {
 UINT cbSize;
 UINT fMask;
 int nMin;
 int nMax;
 UINT nPage;
 int nPos;
 int nTrackPos;
} SCROLLINFO,*LPSCROLLINFO;
typedef const SCROLLINFO *LPCSCROLLINFO;
typedef struct _WINDOWPLACEMENT {
 UINT length;
 UINT flags;
 UINT showCmd;
 POINT ptMinPosition;
 POINT ptMaxPosition;
 RECT rcNormalPosition;
} WINDOWPLACEMENT,*LPWINDOWPLACEMENT,*PWINDOWPLACEMENT;
typedef struct {
 WORD versionNumber;
 WORD offset;
} MENUITEMTEMPLATEHEADER;
typedef struct {
 WORD mtOption;
 WORD mtID;
 WCHAR mtString[1];
} MENUITEMTEMPLATE;
typedef void MENUTEMPLATE,MENUTEMPLATEA,MENUTEMPLATEW,*LPMENUTEMPLATEA,*LPMENUTEMPLATEW,*LPMENUTEMPLATE;
typedef struct tagHELPINFO {
 UINT cbSize;
 int iContextType;
 int iCtrlId;
 HANDLE hItemHandle;
 DWORD dwContextId;
 POINT MousePos;
} HELPINFO,*LPHELPINFO;
typedef void(__attribute__((__stdcall__)) *MSGBOXCALLBACK)(LPHELPINFO);
typedef struct {
 UINT cbSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCSTR lpszText;
 LPCSTR lpszCaption;
 DWORD dwStyle;
 LPCSTR lpszIcon;
 DWORD dwContextHelpId;
 MSGBOXCALLBACK lpfnMsgBoxCallback;
 DWORD dwLanguageId;
} MSGBOXPARAMSA,*PMSGBOXPARAMSA,*LPMSGBOXPARAMSA;
typedef struct {
 UINT cbSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCWSTR lpszText;
 LPCWSTR lpszCaption;
 DWORD dwStyle;
 LPCWSTR lpszIcon;
 DWORD dwContextHelpId;
 MSGBOXCALLBACK lpfnMsgBoxCallback;
 DWORD dwLanguageId;
} MSGBOXPARAMSW,*PMSGBOXPARAMSW,*LPMSGBOXPARAMSW;
typedef struct tagUSEROBJECTFLAGS {
 BOOL fInherit;
 BOOL fReserved;
 DWORD dwFlags;
} USEROBJECTFLAGS;
typedef struct tagFILTERKEYS {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iWaitMSec;
 DWORD iDelayMSec;
 DWORD iRepeatMSec;
 DWORD iBounceMSec;
} FILTERKEYS;
typedef struct tagHIGHCONTRASTA {
 UINT cbSize;
 DWORD dwFlags;
 LPSTR lpszDefaultScheme;
} HIGHCONTRASTA,*LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW {
 UINT cbSize;
 DWORD dwFlags;
 LPWSTR lpszDefaultScheme;
} HIGHCONTRASTW,*LPHIGHCONTRASTW;

typedef struct tagICONMETRICSA {
 UINT cbSize;
 int iHorzSpacing;
 int iVertSpacing;
 int iTitleWrap;
 LOGFONTA lfFont;
} ICONMETRICSA,*LPICONMETRICSA;
typedef struct tagICONMETRICSW {
 UINT cbSize;
 int iHorzSpacing;
 int iVertSpacing;
 int iTitleWrap;
 LOGFONTW lfFont;
} ICONMETRICSW,*LPICONMETRICSW;

typedef struct tagMINIMIZEDMETRICS {
 UINT cbSize;
 int iWidth;
 int iHorzGap;
 int iVertGap;
 int iArrange;
} MINIMIZEDMETRICS,*LPMINIMIZEDMETRICS;
typedef struct tagMOUSEKEYS{
 UINT cbSize;
 DWORD dwFlags;
 DWORD iMaxSpeed;
 DWORD iTimeToMaxSpeed;
 DWORD iCtrlSpeed;
 DWORD dwReserved1;
 DWORD dwReserved2;
} MOUSEKEYS,*LPMOUSEKEYS;

typedef struct tagNONCLIENTMETRICSA {
 UINT cbSize;
 int iBorderWidth;
 int iScrollWidth;
 int iScrollHeight;
 int iCaptionWidth;
 int iCaptionHeight;
 LOGFONTA lfCaptionFont;
 int iSmCaptionWidth;
 int iSmCaptionHeight;
 LOGFONTA lfSmCaptionFont;
 int iMenuWidth;
 int iMenuHeight;
 LOGFONTA lfMenuFont;
 LOGFONTA lfStatusFont;
 LOGFONTA lfMessageFont;
} NONCLIENTMETRICSA,*LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW {
 UINT cbSize;
 int iBorderWidth;
 int iScrollWidth;
 int iScrollHeight;
 int iCaptionWidth;
 int iCaptionHeight;
 LOGFONTW lfCaptionFont;
 int iSmCaptionWidth;
 int iSmCaptionHeight;
 LOGFONTW lfSmCaptionFont;
 int iMenuWidth;
 int iMenuHeight;
 LOGFONTW lfMenuFont;
 LOGFONTW lfStatusFont;
 LOGFONTW lfMessageFont;
} NONCLIENTMETRICSW,*LPNONCLIENTMETRICSW;

typedef struct tagSERIALKEYSA {
 UINT cbSize;
 DWORD dwFlags;
 LPSTR lpszActivePort;
 LPSTR lpszPort;
 UINT iBaudRate;
 UINT iPortState;
 UINT iActive;
} SERIALKEYSA,*LPSERIALKEYSA;
typedef struct tagSERIALKEYSW {
 UINT cbSize;
 DWORD dwFlags;
 LPWSTR lpszActivePort;
 LPWSTR lpszPort;
 UINT iBaudRate;
 UINT iPortState;
 UINT iActive;
} SERIALKEYSW,*LPSERIALKEYSW;
typedef struct tagSOUNDSENTRYA {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iFSTextEffect;
 DWORD iFSTextEffectMSec;
 DWORD iFSTextEffectColorBits;
 DWORD iFSGrafEffect;
 DWORD iFSGrafEffectMSec;
 DWORD iFSGrafEffectColor;
 DWORD iWindowsEffect;
 DWORD iWindowsEffectMSec;
 LPSTR lpszWindowsEffectDLL;
 DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA,*LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iFSTextEffect;
 DWORD iFSTextEffectMSec;
 DWORD iFSTextEffectColorBits;
 DWORD iFSGrafEffect;
 DWORD iFSGrafEffectMSec;
 DWORD iFSGrafEffectColor;
 DWORD iWindowsEffect;
 DWORD iWindowsEffectMSec;
 LPWSTR lpszWindowsEffectDLL;
 DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW,*LPSOUNDSENTRYW;
typedef struct tagSTICKYKEYS {
 DWORD cbSize;
 DWORD dwFlags;
} STICKYKEYS,*LPSTICKYKEYS;
typedef struct tagTOGGLEKEYS {
 DWORD cbSize;
 DWORD dwFlags;
} TOGGLEKEYS;
typedef struct tagMOUSEHOOKSTRUCT {
 POINT pt;
 HWND hwnd;
 UINT wHitTestCode;
 DWORD dwExtraInfo;
} MOUSEHOOKSTRUCT,*LPMOUSEHOOKSTRUCT,*PMOUSEHOOKSTRUCT;
typedef struct tagTRACKMOUSEEVENT {
 DWORD cbSize;
 DWORD dwFlags;
 HWND hwndTrack;
 DWORD dwHoverTime;
} TRACKMOUSEEVENT,*LPTRACKMOUSEEVENT;
typedef struct tagTPMPARAMS {
 UINT cbSize;
 RECT rcExclude;
} TPMPARAMS,*LPTPMPARAMS;
typedef struct tagEVENTMSG {
 UINT message;
 UINT paramL;
 UINT paramH;
 DWORD time;
 HWND hwnd;
} EVENTMSG,*PEVENTMSGMSG,*LPEVENTMSGMSG,*PEVENTMSG,*LPEVENTMSG;
typedef struct _WINDOWPOS {
 HWND hwnd;
 HWND hwndInsertAfter;
 int x;
 int y;
 int cx;
 int cy;
 UINT flags;
} WINDOWPOS,*PWINDOWPOS,*LPWINDOWPOS;
typedef struct tagNCCALCSIZE_PARAMS {
 RECT rgrc[3];
 PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
typedef struct tagMDICREATESTRUCTA {
 LPCSTR szClass;
 LPCSTR szTitle;
 HANDLE hOwner;
 int x;
 int y;
 int cx;
 int cy;
 DWORD style;
 LPARAM lParam;
} MDICREATESTRUCTA,*LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
 LPCWSTR szClass;
 LPCWSTR szTitle;
 HANDLE hOwner;
 int x;
 int y;
 int cx;
 int cy;
 DWORD style;
 LPARAM lParam;
} MDICREATESTRUCTW,*LPMDICREATESTRUCTW;
typedef struct tagMINMAXINFO {
 POINT ptReserved;
 POINT ptMaxSize;
 POINT ptMaxPosition;
 POINT ptMinTrackSize;
 POINT ptMaxTrackSize;
} MINMAXINFO,*PMINMAXINFO,*LPMINMAXINFO;
typedef struct tagMDINEXTMENU {
 HMENU hmenuIn;
 HMENU hmenuNext;
 HWND hwndNext;
} MDINEXTMENU,*PMDINEXTMENU,*LPMDINEXTMENU;
typedef struct tagMEASUREITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 UINT itemWidth;
 UINT itemHeight;
 DWORD itemData;
} MEASUREITEMSTRUCT,*PMEASUREITEMSTRUCT,*LPMEASUREITEMSTRUCT;
typedef struct tagDROPSTRUCT {
 HWND hwndSource;
 HWND hwndSink;
 DWORD wFmt;
 DWORD dwData;
 POINT ptDrop;
 DWORD dwControlData;
} DROPSTRUCT,*PDROPSTRUCT,*LPDROPSTRUCT;
typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
 DWORD mkSize;
 CHAR mkKeylist;
 CHAR szKeyphrase[1];
} MULTIKEYHELPA,*PMULTIKEYHELPA,*LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
 DWORD mkSize;
 WCHAR mkKeylist;
 WCHAR szKeyphrase[1];
} MULTIKEYHELPW,*PMULTIKEYHELPW,*LPMULTIKEYHELPW;
typedef struct tagHELPWININFOA {
 int wStructSize;
 int x;
 int y;
 int dx;
 int dy;
 int wMax;
 CHAR rgchMember[2];
} HELPWININFOA,*PHELPWININFOA,*LPHELPWININFOA;
typedef struct tagHELPWININFOW {
 int wStructSize;
 int x;
 int y;
 int dx;
 int dy;
 int wMax;
 WCHAR rgchMember[2];
} HELPWININFOW,*PHELPWININFOW,*LPHELPWININFOW;
typedef struct tagSTYLESTRUCT {
 DWORD styleOld;
 DWORD styleNew;
} STYLESTRUCT,*LPSTYLESTRUCT;
typedef struct tagALTTABINFO {
 DWORD cbSize;
 int cItems;
 int cColumns;
 int cRows;
 int iColFocus;
 int iRowFocus;
 int cxItem;
 int cyItem;
 POINT ptStart;
} ALTTABINFO,*PALTTABINFO,*LPALTTABINFO;
typedef struct tagCOMBOBOXINFO {
 DWORD cbSize;
 RECT rcItem;
 RECT rcButton;
 DWORD stateButton;
 HWND hwndCombo;
 HWND hwndItem;
 HWND hwndList;
} COMBOBOXINFO,*PCOMBOBOXINFO,*LPCOMBOBOXINFO;
typedef struct tagCURSORINFO {
 DWORD cbSize;
 DWORD flags;
 HCURSOR hCursor;
 POINT ptScreenPos;
} CURSORINFO,*PCURSORINFO,*LPCURSORINFO;
typedef struct tagMENUBARINFO {
 DWORD cbSize;
 RECT rcBar;
 HMENU hMenu;
 HWND hwndMenu;
 BOOL fBarFocused:1;
 BOOL fFocused:1;
} MENUBARINFO,*PMENUBARINFO;
typedef struct tagMENUINFO {
 DWORD cbSize;
 DWORD fMask;
 DWORD dwStyle;
 UINT cyMax;
 HBRUSH hbrBack;
 DWORD dwContextHelpID;
 ULONG_PTR dwMenuData;
} MENUINFO,*LPMENUINFO;
typedef MENUINFO const *LPCMENUINFO;

typedef struct tagSCROLLBARINFO {
 DWORD cbSize;
 RECT rcScrollBar;
 int dxyLineButton;
 int xyThumbTop;
 int xyThumbBottom;
 int reserved;
 DWORD rgstate[5 +1];
} SCROLLBARINFO,*PSCROLLBARINFO,*LPSCROLLBARINFO;
# 3136 "C:/upp/mingw/include/winuser.h" 3
typedef struct tagWINDOWINFO {
 DWORD cbSize;
 RECT rcWindow;
 RECT rcClient;
 DWORD dwStyle;
 DWORD dwExStyle;
 DWORD dwWindowStatus;
 UINT cxWindowBorders;
 UINT cyWindowBorders;
 ATOM atomWindowType;
 WORD wCreatorVersion;
} WINDOWINFO,*PWINDOWINFO,*LPWINDOWINFO;
typedef struct tagLASTINPUTINFO {
 UINT cbSize;
 DWORD dwTime;
} LASTINPUTINFO,*PLASTINPUTINFO;
typedef struct tagMONITORINFO {
 DWORD cbSize;
 RECT rcMonitor;
 RECT rcWork;
 DWORD dwFlags;
} MONITORINFO,*LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;
# 3184 "C:/upp/mingw/include/winuser.h" 3
typedef struct tagKBDLLHOOKSTRUCT {
 DWORD vkCode;
 DWORD scanCode;
 DWORD flags;
 DWORD time;
 DWORD dwExtraInfo;
} KBDLLHOOKSTRUCT,*LPKBDLLHOOKSTRUCT,*PKBDLLHOOKSTRUCT;
# 3344 "C:/upp/mingw/include/winuser.h" 3
typedef struct {
 POINT pt;
 DWORD mouseData;
 DWORD flags;
 DWORD time;
 ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
# 3371 "C:/upp/mingw/include/winuser.h" 3
 HKL __attribute__((__stdcall__)) ActivateKeyboardLayout(HKL,UINT);
 BOOL __attribute__((__stdcall__)) AdjustWindowRect(LPRECT,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);



 BOOL __attribute__((__stdcall__)) AnyPopup(void);
 BOOL __attribute__((__stdcall__)) AppendMenuA(HMENU,UINT,UINT_PTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) AppendMenuW(HMENU,UINT,UINT_PTR,LPCWSTR);
 UINT __attribute__((__stdcall__)) ArrangeIconicWindows(HWND);
 BOOL __attribute__((__stdcall__)) AttachThreadInput(DWORD,DWORD,BOOL);
 HDWP __attribute__((__stdcall__)) BeginDeferWindowPos(int);
 HDC __attribute__((__stdcall__)) BeginPaint(HWND,LPPAINTSTRUCT);
 BOOL __attribute__((__stdcall__)) BringWindowToTop(HWND);
 long __attribute__((__stdcall__)) BroadcastSystemMessage(DWORD,LPDWORD,UINT,WPARAM,LPARAM);

 long __attribute__((__stdcall__)) BroadcastSystemMessageA(DWORD,LPDWORD,UINT,WPARAM,LPARAM);
 long __attribute__((__stdcall__)) BroadcastSystemMessageW(DWORD,LPDWORD,UINT,WPARAM,LPARAM);





 BOOL __attribute__((__stdcall__)) CallMsgFilterA(LPMSG,INT);
 BOOL __attribute__((__stdcall__)) CallMsgFilterW(LPMSG,INT);
 LRESULT __attribute__((__stdcall__)) CallNextHookEx(HHOOK,int,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) CallWindowProcA(WNDPROC,HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) CallWindowProcW(WNDPROC,HWND,UINT,WPARAM,LPARAM);
 WORD __attribute__((__stdcall__)) CascadeWindows(HWND,UINT,LPCRECT,UINT,const HWND*);
 BOOL __attribute__((__stdcall__)) ChangeClipboardChain(HWND,HWND);

 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsA(PDEVMODEA,DWORD);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsW(PDEVMODEW,DWORD);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsExA(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsExW(LPCWSTR,LPDEVMODEW,HWND,DWORD,LPVOID);

 BOOL __attribute__((__stdcall__)) ChangeMenuA(HMENU,UINT,LPCSTR,UINT,UINT);
 BOOL __attribute__((__stdcall__)) ChangeMenuW(HMENU,UINT,LPCWSTR,UINT,UINT);
 LPSTR __attribute__((__stdcall__)) CharLowerA(LPSTR);
 LPWSTR __attribute__((__stdcall__)) CharLowerW(LPWSTR);
 DWORD __attribute__((__stdcall__)) CharLowerBuffA(LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) CharLowerBuffW(LPWSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharNextA(LPCSTR);
 LPWSTR __attribute__((__stdcall__)) CharNextW(LPCWSTR);
 LPSTR __attribute__((__stdcall__)) CharNextExA(WORD,LPCSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharPrevA(LPCSTR,LPCSTR);
 LPWSTR __attribute__((__stdcall__)) CharPrevW(LPCWSTR,LPCWSTR);
 LPSTR __attribute__((__stdcall__)) CharPrevExA(WORD,LPCSTR,LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CharToOemA(LPCSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) CharToOemW(LPCWSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) CharToOemBuffA(LPCSTR,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CharToOemBuffW(LPCWSTR,LPSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharUpperA(LPSTR);
 LPWSTR __attribute__((__stdcall__)) CharUpperW(LPWSTR);
 DWORD __attribute__((__stdcall__)) CharUpperBuffA(LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) CharUpperBuffW(LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CheckDlgButton(HWND,int,UINT);
 DWORD __attribute__((__stdcall__)) CheckMenuItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) CheckMenuRadioItem(HMENU,UINT,UINT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) CheckRadioButton(HWND,int,int,int);
 HWND __attribute__((__stdcall__)) ChildWindowFromPoint(HWND,POINT);
 HWND __attribute__((__stdcall__)) ChildWindowFromPointEx(HWND,POINT,UINT);
 BOOL __attribute__((__stdcall__)) ClientToScreen(HWND,LPPOINT);
 BOOL __attribute__((__stdcall__)) ClipCursor(LPCRECT);
 BOOL __attribute__((__stdcall__)) CloseClipboard(void);
 BOOL __attribute__((__stdcall__)) CloseDesktop(HDESK);
 BOOL __attribute__((__stdcall__)) CloseWindow(HWND);
 BOOL __attribute__((__stdcall__)) CloseWindowStation(HWINSTA);
 int __attribute__((__stdcall__)) CopyAcceleratorTableA(HACCEL,LPACCEL,int);
 int __attribute__((__stdcall__)) CopyAcceleratorTableW(HACCEL,LPACCEL,int);

 HICON __attribute__((__stdcall__)) CopyIcon(HICON);
 HANDLE __attribute__((__stdcall__)) CopyImage(HANDLE,UINT,int,int,UINT);
 BOOL __attribute__((__stdcall__)) CopyRect(LPRECT,LPCRECT);
 int __attribute__((__stdcall__)) CountClipboardFormats(void);
 HACCEL __attribute__((__stdcall__)) CreateAcceleratorTableA(LPACCEL,int);
 HACCEL __attribute__((__stdcall__)) CreateAcceleratorTableW(LPACCEL,int);
 BOOL __attribute__((__stdcall__)) CreateCaret(HWND,HBITMAP,int,int);
 HCURSOR __attribute__((__stdcall__)) CreateCursor(HINSTANCE,int,int,int,int,PCVOID,PCVOID);

 HDESK __attribute__((__stdcall__)) CreateDesktopA(LPCSTR,LPCSTR,LPDEVMODEA,DWORD,ACCESS_MASK,LPSECURITY_ATTRIBUTES);
 HDESK __attribute__((__stdcall__)) CreateDesktopW(LPCWSTR,LPCWSTR,LPDEVMODEW,DWORD,ACCESS_MASK,LPSECURITY_ATTRIBUTES);





 HWND __attribute__((__stdcall__)) CreateDialogIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
 HICON __attribute__((__stdcall__)) CreateIcon(HINSTANCE,int,int,BYTE,BYTE,const BYTE*,const BYTE*);
 HICON __attribute__((__stdcall__)) CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
 HICON __attribute__((__stdcall__)) CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
 HICON __attribute__((__stdcall__)) CreateIconIndirect(PICONINFO);
 HWND __attribute__((__stdcall__)) CreateMDIWindowA(LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
 HWND __attribute__((__stdcall__)) CreateMDIWindowW(LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
 HMENU __attribute__((__stdcall__)) CreateMenu(void);
 HMENU __attribute__((__stdcall__)) CreatePopupMenu(void);


 HWND __attribute__((__stdcall__)) CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
 HWND __attribute__((__stdcall__)) CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
 HWINSTA __attribute__((__stdcall__)) CreateWindowStationA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HWINSTA __attribute__((__stdcall__)) CreateWindowStationW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 LRESULT __attribute__((__stdcall__)) DefDlgProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefDlgProcW(HWND,UINT,WPARAM,LPARAM);
 HDWP __attribute__((__stdcall__)) DeferWindowPos(HDWP,HWND,HWND,int,int,int,int,UINT);
 LRESULT __attribute__((__stdcall__)) DefFrameProcA(HWND,HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefFrameProcW(HWND,HWND,UINT,WPARAM,LPARAM);

 LRESULT __attribute__((__stdcall__)) DefMDIChildProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefMDIChildProcW(HWND,UINT,WPARAM,LPARAM);



 LRESULT __attribute__((__stdcall__)) DefWindowProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefWindowProcW(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) DeleteMenu(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DeregisterShellHookWindow(HWND);
 BOOL __attribute__((__stdcall__)) DestroyAcceleratorTable(HACCEL);
 BOOL __attribute__((__stdcall__)) DestroyCaret(void);
 BOOL __attribute__((__stdcall__)) DestroyCursor(HCURSOR);
 BOOL __attribute__((__stdcall__)) DestroyIcon(HICON);
 BOOL __attribute__((__stdcall__)) DestroyMenu(HMENU);
 BOOL __attribute__((__stdcall__)) DestroyWindow(HWND);




 int __attribute__((__stdcall__)) DialogBoxIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 int __attribute__((__stdcall__)) DialogBoxIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);




 int __attribute__((__stdcall__)) DialogBoxParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
 int __attribute__((__stdcall__)) DialogBoxParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);

 LONG __attribute__((__stdcall__)) DispatchMessageA(const MSG*);
 LONG __attribute__((__stdcall__)) DispatchMessageW(const MSG*);
 int __attribute__((__stdcall__)) DlgDirListA(HWND,LPSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListW(HWND,LPWSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListComboBoxA(HWND,LPSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListComboBoxW(HWND,LPWSTR,int,int,UINT);
 BOOL __attribute__((__stdcall__)) DlgDirSelectComboBoxExA(HWND,LPSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectComboBoxExW(HWND,LPWSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectExA(HWND,LPSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectExW(HWND,LPWSTR,int,int);
 BOOL __attribute__((__stdcall__)) DragDetect(HWND,POINT);
 DWORD __attribute__((__stdcall__)) DragObject(HWND,HWND,UINT,DWORD,HCURSOR);
 BOOL __attribute__((__stdcall__)) DrawAnimatedRects(HWND,int,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) DrawCaption(HWND,HDC,LPCRECT,UINT);
 BOOL __attribute__((__stdcall__)) DrawEdge(HDC,LPRECT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DrawFocusRect(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) DrawFrameControl(HDC,LPRECT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DrawIcon(HDC,int,int,HICON);
 BOOL __attribute__((__stdcall__)) DrawIconEx(HDC,int,int,HICON,int,int,UINT,HBRUSH,UINT);
 BOOL __attribute__((__stdcall__)) DrawMenuBar(HWND);
 BOOL __attribute__((__stdcall__)) DrawStateA(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
 BOOL __attribute__((__stdcall__)) DrawStateW(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
 int __attribute__((__stdcall__)) DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);
 int __attribute__((__stdcall__)) DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);
 int __attribute__((__stdcall__)) DrawTextExA(HDC,LPSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
 int __attribute__((__stdcall__)) DrawTextExW(HDC,LPWSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
 BOOL __attribute__((__stdcall__)) EmptyClipboard(void);
 BOOL __attribute__((__stdcall__)) EnableMenuItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) EnableScrollBar(HWND,UINT,UINT);
 BOOL __attribute__((__stdcall__)) EnableWindow(HWND,BOOL);
 BOOL __attribute__((__stdcall__)) EndDeferWindowPos(HDWP);
 BOOL __attribute__((__stdcall__)) EndDialog(HWND,int);
 BOOL __attribute__((__stdcall__)) EndMenu(void);
 BOOL __attribute__((__stdcall__)) EndPaint(HWND,const PAINTSTRUCT*);



 BOOL __attribute__((__stdcall__)) EnumChildWindows(HWND,ENUMWINDOWSPROC,LPARAM);
 UINT __attribute__((__stdcall__)) EnumClipboardFormats(UINT);
 BOOL __attribute__((__stdcall__)) EnumDesktopsA(HWINSTA,DESKTOPENUMPROCA,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDesktopsW(HWINSTA,DESKTOPENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDesktopWindows(HDESK,ENUMWINDOWSPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDisplayMonitors(HDC,LPCRECT,MONITORENUMPROC,LPARAM);

 BOOL __attribute__((__stdcall__)) EnumDisplaySettingsA(LPCSTR,DWORD,PDEVMODEA);
 BOOL __attribute__((__stdcall__)) EnumDisplaySettingsW(LPCWSTR,DWORD,PDEVMODEW);




 BOOL __attribute__((__stdcall__)) EnumDisplayDevicesA(LPCSTR,DWORD,PDISPLAY_DEVICEA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumDisplayDevicesW(LPCWSTR,DWORD,PDISPLAY_DEVICEW,DWORD);

 int __attribute__((__stdcall__)) EnumPropsA(HWND,PROPENUMPROCA);
 int __attribute__((__stdcall__)) EnumPropsW(HWND,PROPENUMPROCW);
 int __attribute__((__stdcall__)) EnumPropsExA(HWND,PROPENUMPROCEXA,LPARAM);
 int __attribute__((__stdcall__)) EnumPropsExW(HWND,PROPENUMPROCEXW,LPARAM);

 BOOL __attribute__((__stdcall__)) EnumThreadWindows(DWORD,WNDENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindows(WNDENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindowStationsA(WINSTAENUMPROCA,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindowStationsW(WINSTAENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EqualRect(LPCRECT,LPCRECT);

 BOOL __attribute__((__stdcall__)) ExitWindowsEx(UINT,DWORD);
 HWND __attribute__((__stdcall__)) FindWindowA(LPCSTR,LPCSTR);
 HWND __attribute__((__stdcall__)) FindWindowExA(HWND,HWND,LPCSTR,LPCSTR);
 HWND __attribute__((__stdcall__)) FindWindowExW(HWND,HWND,LPCWSTR,LPCWSTR);
 HWND __attribute__((__stdcall__)) FindWindowW(LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) FlashWindow(HWND,BOOL);



int __attribute__((__stdcall__)) FrameRect(HDC,LPCRECT,HBRUSH);
 BOOL __attribute__((__stdcall__)) FrameRgn(HDC,HRGN,HBRUSH,int,int);
 HWND __attribute__((__stdcall__)) GetActiveWindow(void);
 HWND __attribute__((__stdcall__)) GetAncestor(HWND,UINT);
 SHORT __attribute__((__stdcall__)) GetAsyncKeyState(int);
 HWND __attribute__((__stdcall__)) GetCapture(void);
 UINT __attribute__((__stdcall__)) GetCaretBlinkTime(void);
 BOOL __attribute__((__stdcall__)) GetCaretPos(LPPOINT);
 BOOL __attribute__((__stdcall__)) GetClassInfoA(HINSTANCE,LPCSTR,LPWNDCLASSA);
 BOOL __attribute__((__stdcall__)) GetClassInfoExA(HINSTANCE,LPCSTR,LPWNDCLASSEXA);
 BOOL __attribute__((__stdcall__)) GetClassInfoW(HINSTANCE,LPCWSTR,LPWNDCLASSW);
 BOOL __attribute__((__stdcall__)) GetClassInfoExW(HINSTANCE,LPCWSTR,LPWNDCLASSEXW);
 DWORD __attribute__((__stdcall__)) GetClassLongA(HWND,int);
 DWORD __attribute__((__stdcall__)) GetClassLongW(HWND,int);







 int __attribute__((__stdcall__)) GetClassNameA(HWND,LPSTR,int);
 int __attribute__((__stdcall__)) GetClassNameW(HWND,LPWSTR,int);
 WORD __attribute__((__stdcall__)) GetClassWord(HWND,int);
 BOOL __attribute__((__stdcall__)) GetClientRect(HWND,LPRECT);
 HANDLE __attribute__((__stdcall__)) GetClipboardData(UINT);
 int __attribute__((__stdcall__)) GetClipboardFormatNameA(UINT,LPSTR,int);
 int __attribute__((__stdcall__)) GetClipboardFormatNameW(UINT,LPWSTR,int);
 HWND __attribute__((__stdcall__)) GetClipboardOwner(void);



HWND __attribute__((__stdcall__)) GetClipboardViewer(void);
 BOOL __attribute__((__stdcall__)) GetClipCursor(LPRECT);
 BOOL __attribute__((__stdcall__)) GetCursorPos(LPPOINT);
 HDC __attribute__((__stdcall__)) GetDC(HWND);
 HDC __attribute__((__stdcall__)) GetDCEx(HWND,HRGN,DWORD);
 HWND __attribute__((__stdcall__)) GetDesktopWindow(void);
 long __attribute__((__stdcall__)) GetDialogBaseUnits(void);
 int __attribute__((__stdcall__)) GetDlgCtrlID(HWND);
 HWND __attribute__((__stdcall__)) GetDlgItem(HWND,int);
 UINT __attribute__((__stdcall__)) GetDlgItemInt(HWND,int,PBOOL,BOOL);
 UINT __attribute__((__stdcall__)) GetDlgItemTextA(HWND,int,LPSTR,int);
 UINT __attribute__((__stdcall__)) GetDlgItemTextW(HWND,int,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetDoubleClickTime(void);
 HWND __attribute__((__stdcall__)) GetFocus(void);
 HWND __attribute__((__stdcall__)) GetForegroundWindow(void);



 BOOL __attribute__((__stdcall__)) GetIconInfo(HICON,PICONINFO);
 BOOL __attribute__((__stdcall__)) GetInputState(void);
 UINT __attribute__((__stdcall__)) GetKBCodePage(void);
 HKL __attribute__((__stdcall__)) GetKeyboardLayout(DWORD);
 UINT __attribute__((__stdcall__)) GetKeyboardLayoutList(int,HKL*);
 BOOL __attribute__((__stdcall__)) GetKeyboardLayoutNameA(LPSTR);
 BOOL __attribute__((__stdcall__)) GetKeyboardLayoutNameW(LPWSTR);
 BOOL __attribute__((__stdcall__)) GetKeyboardState(PBYTE);
 int __attribute__((__stdcall__)) GetKeyboardType(int);
 int __attribute__((__stdcall__)) GetKeyNameTextA(LONG,LPSTR,int);
 int __attribute__((__stdcall__)) GetKeyNameTextW(LONG,LPWSTR,int);
 SHORT __attribute__((__stdcall__)) GetKeyState(int);
 HWND __attribute__((__stdcall__)) GetLastActivePopup(HWND);
 HMENU __attribute__((__stdcall__)) GetMenu(HWND);
 LONG __attribute__((__stdcall__)) GetMenuCheckMarkDimensions(void);
 DWORD __attribute__((__stdcall__)) GetMenuContextHelpId(HMENU);
 UINT __attribute__((__stdcall__)) GetMenuDefaultItem(HMENU,UINT,UINT);
 int __attribute__((__stdcall__)) GetMenuItemCount(HMENU);
 UINT __attribute__((__stdcall__)) GetMenuItemID(HMENU,int);
 BOOL __attribute__((__stdcall__)) GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFOW);
 BOOL __attribute__((__stdcall__)) GetMenuItemRect(HWND,HMENU,UINT,LPRECT);
 UINT __attribute__((__stdcall__)) GetMenuState(HMENU,UINT,UINT);
 int __attribute__((__stdcall__)) GetMenuStringA(HMENU,UINT,LPSTR,int,UINT);
 int __attribute__((__stdcall__)) GetMenuStringW(HMENU,UINT,LPWSTR,int,UINT);
 BOOL __attribute__((__stdcall__)) GetMessageA(LPMSG,HWND,UINT,UINT);
 BOOL __attribute__((__stdcall__)) GetMessageW(LPMSG,HWND,UINT,UINT);
 LONG __attribute__((__stdcall__)) GetMessageExtraInfo(void);
 DWORD __attribute__((__stdcall__)) GetMessagePos(void);
 LONG __attribute__((__stdcall__)) GetMessageTime(void);



 HWND __attribute__((__stdcall__)) GetNextDlgGroupItem(HWND,HWND,BOOL);
 HWND __attribute__((__stdcall__)) GetNextDlgTabItem(HWND,HWND,BOOL);

 HWND __attribute__((__stdcall__)) GetOpenClipboardWindow(void);
 HWND __attribute__((__stdcall__)) GetParent(HWND);
 int __attribute__((__stdcall__)) GetPriorityClipboardFormat(UINT*,int);
 HANDLE __attribute__((__stdcall__)) GetPropA(HWND,LPCSTR);
 HANDLE __attribute__((__stdcall__)) GetPropW(HWND,LPCWSTR);
# 3682 "C:/upp/mingw/include/winuser.h" 3
 DWORD __attribute__((__stdcall__)) GetQueueStatus(UINT);
 BOOL __attribute__((__stdcall__)) GetScrollInfo(HWND,int,LPSCROLLINFO);
 int __attribute__((__stdcall__)) GetScrollPos(HWND,int);
 BOOL __attribute__((__stdcall__)) GetScrollRange(HWND,int,LPINT,LPINT);



 HMENU __attribute__((__stdcall__)) GetSubMenu(HMENU,int);
 DWORD __attribute__((__stdcall__)) GetSysColor(int);
 HBRUSH __attribute__((__stdcall__)) GetSysColorBrush(int);

 HMENU __attribute__((__stdcall__)) GetSystemMenu(HWND,BOOL);
 int __attribute__((__stdcall__)) GetSystemMetrics(int);
 DWORD __attribute__((__stdcall__)) GetTabbedTextExtentA(HDC,LPCSTR,int,int,LPINT);
 DWORD __attribute__((__stdcall__)) GetTabbedTextExtentW(HDC,LPCWSTR,int,int,LPINT);
 LONG __attribute__((__stdcall__)) GetWindowLongA(HWND,int);
 LONG __attribute__((__stdcall__)) GetWindowLongW(HWND,int);







 HDESK __attribute__((__stdcall__)) GetThreadDesktop(DWORD);
 HWND __attribute__((__stdcall__)) GetTopWindow(HWND);
 BOOL __attribute__((__stdcall__)) GetUpdateRect(HWND,LPRECT,BOOL);
 int __attribute__((__stdcall__)) GetUpdateRgn(HWND,HRGN,BOOL);
 BOOL __attribute__((__stdcall__)) GetUserObjectInformationA(HANDLE,int,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserObjectInformationW(HANDLE,int,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 HWND __attribute__((__stdcall__)) GetWindow(HWND,UINT);
 DWORD __attribute__((__stdcall__)) GetWindowContextHelpId(HWND);
 HDC __attribute__((__stdcall__)) GetWindowDC(HWND);
 BOOL __attribute__((__stdcall__)) GetWindowPlacement(HWND,WINDOWPLACEMENT*);
 BOOL __attribute__((__stdcall__)) GetWindowRect(HWND,LPRECT);
 int __attribute__((__stdcall__)) GetWindowRgn(HWND,HRGN);

 int __attribute__((__stdcall__)) GetWindowTextA(HWND,LPSTR,int);
 int __attribute__((__stdcall__)) GetWindowTextLengthA(HWND);
 int __attribute__((__stdcall__)) GetWindowTextLengthW(HWND);
 int __attribute__((__stdcall__)) GetWindowTextW(HWND,LPWSTR,int);
 WORD __attribute__((__stdcall__)) GetWindowWord(HWND,int);
 BOOL __attribute__((__stdcall__)) GetAltTabInfoA(HWND,int,PALTTABINFO,LPSTR,UINT);
 BOOL __attribute__((__stdcall__)) GetAltTabInfoW(HWND,int,PALTTABINFO,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) GetComboBoxInfo(HWND,PCOMBOBOXINFO);
 BOOL __attribute__((__stdcall__)) GetCursorInfo(PCURSORINFO);



 BOOL __attribute__((__stdcall__)) GetLastInputInfo(PLASTINPUTINFO);
 DWORD __attribute__((__stdcall__)) GetListBoxInfo(HWND);
 BOOL __attribute__((__stdcall__)) GetMenuBarInfo(HWND,LONG,LONG,PMENUBARINFO);
 BOOL __attribute__((__stdcall__)) GetMenuInfo(HMENU,LPMENUINFO);



 BOOL __attribute__((__stdcall__)) GetScrollBarInfo(HWND,LONG,PSCROLLBARINFO);



 BOOL __attribute__((__stdcall__)) GetWindowInfo(HWND,PWINDOWINFO);
 BOOL __attribute__((__stdcall__)) GetMonitorInfoA(HMONITOR,LPMONITORINFO);
 BOOL __attribute__((__stdcall__)) GetMonitorInfoW(HMONITOR,LPMONITORINFO);
 UINT __attribute__((__stdcall__)) GetWindowModuleFileNameA(HWND,LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetWindowModuleFileNameW(HWND,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) GrayStringA(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) GrayStringW(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) HideCaret(HWND);
 BOOL __attribute__((__stdcall__)) HiliteMenuItem(HWND,HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) InflateRect(LPRECT,int,int);
 BOOL __attribute__((__stdcall__)) InSendMessage(void);



 BOOL __attribute__((__stdcall__)) InsertMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) InsertMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
 BOOL __attribute__((__stdcall__)) InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFOW);
 INT __attribute__((__stdcall__)) InternalGetWindowText(HWND,LPWSTR,INT);
 BOOL __attribute__((__stdcall__)) IntersectRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) InvalidateRect(HWND,LPCRECT,BOOL);
 BOOL __attribute__((__stdcall__)) InvalidateRgn(HWND,HRGN,BOOL);
 BOOL __attribute__((__stdcall__)) InvertRect(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) IsCharAlphaA(CHAR ch);
 BOOL __attribute__((__stdcall__)) IsCharAlphaNumericA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharAlphaNumericW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharAlphaW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharLowerA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharLowerW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharUpperA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharUpperW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsChild(HWND,HWND);
 BOOL __attribute__((__stdcall__)) IsClipboardFormatAvailable(UINT);
 BOOL __attribute__((__stdcall__)) IsDialogMessageA(HWND,LPMSG);
 BOOL __attribute__((__stdcall__)) IsDialogMessageW(HWND,LPMSG);
 UINT __attribute__((__stdcall__)) IsDlgButtonChecked(HWND,int);






 BOOL __attribute__((__stdcall__)) IsIconic(HWND);
 BOOL __attribute__((__stdcall__)) IsMenu(HMENU);
 BOOL __attribute__((__stdcall__)) IsRectEmpty(LPCRECT);
 BOOL __attribute__((__stdcall__)) IsWindow(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowEnabled(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowUnicode(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowVisible(HWND);



 BOOL __attribute__((__stdcall__)) IsZoomed(HWND);
 void __attribute__((__stdcall__)) keybd_event(BYTE,BYTE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) KillTimer(HWND,UINT);
 HACCEL __attribute__((__stdcall__)) LoadAcceleratorsA(HINSTANCE,LPCSTR);
 HACCEL __attribute__((__stdcall__)) LoadAcceleratorsW(HINSTANCE,LPCWSTR);
 HBITMAP __attribute__((__stdcall__)) LoadBitmapA(HINSTANCE,LPCSTR);
 HBITMAP __attribute__((__stdcall__)) LoadBitmapW(HINSTANCE,LPCWSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorA(HINSTANCE,LPCSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorFromFileA(LPCSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorFromFileW(LPCWSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorW(HINSTANCE,LPCWSTR);
 HICON __attribute__((__stdcall__)) LoadIconA(HINSTANCE,LPCSTR);
 HICON __attribute__((__stdcall__)) LoadIconW(HINSTANCE,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);
 HANDLE __attribute__((__stdcall__)) LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);
 HKL __attribute__((__stdcall__)) LoadKeyboardLayoutA(LPCSTR,UINT);
 HKL __attribute__((__stdcall__)) LoadKeyboardLayoutW(LPCWSTR,UINT);
 HMENU __attribute__((__stdcall__)) LoadMenuA(HINSTANCE,LPCSTR);
 HMENU __attribute__((__stdcall__)) LoadMenuIndirectA(const MENUTEMPLATE*);
 HMENU __attribute__((__stdcall__)) LoadMenuIndirectW(const MENUTEMPLATE*);
 HMENU __attribute__((__stdcall__)) LoadMenuW(HINSTANCE,LPCWSTR);
 int __attribute__((__stdcall__)) LoadStringA(HINSTANCE,UINT,LPSTR,int);
 int __attribute__((__stdcall__)) LoadStringW(HINSTANCE,UINT,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) LockWindowUpdate(HWND);



 int __attribute__((__stdcall__)) LookupIconIdFromDirectory(PBYTE,BOOL);
 int __attribute__((__stdcall__)) LookupIconIdFromDirectoryEx(PBYTE,BOOL,int,int,UINT);
 BOOL __attribute__((__stdcall__)) MapDialogRect(HWND,LPRECT);
 UINT __attribute__((__stdcall__)) MapVirtualKeyA(UINT,UINT);
 UINT __attribute__((__stdcall__)) MapVirtualKeyExA(UINT,UINT,HKL);
 UINT __attribute__((__stdcall__)) MapVirtualKeyExW(UINT,UINT,HKL);
 UINT __attribute__((__stdcall__)) MapVirtualKeyW(UINT,UINT);
 int __attribute__((__stdcall__)) MapWindowPoints(HWND,HWND,LPPOINT,UINT);
 int __attribute__((__stdcall__)) MenuItemFromPoint(HWND,HMENU,POINT);
 BOOL __attribute__((__stdcall__)) MessageBeep(UINT);
 int __attribute__((__stdcall__)) MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);
 int __attribute__((__stdcall__)) MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);
 int __attribute__((__stdcall__)) MessageBoxExA(HWND,LPCSTR,LPCSTR,UINT,WORD);
 int __attribute__((__stdcall__)) MessageBoxExW(HWND,LPCWSTR,LPCWSTR,UINT,WORD);
 int __attribute__((__stdcall__)) MessageBoxIndirectA(const MSGBOXPARAMSA*);
 int __attribute__((__stdcall__)) MessageBoxIndirectW(const MSGBOXPARAMSW*);
 BOOL __attribute__((__stdcall__)) ModifyMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) ModifyMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);





 void __attribute__((__stdcall__)) mouse_event(DWORD,DWORD,DWORD,DWORD,ULONG_PTR);
 BOOL __attribute__((__stdcall__)) MoveWindow(HWND,int,int,int,int,BOOL);
 DWORD __attribute__((__stdcall__)) MsgWaitForMultipleObjects(DWORD,const HANDLE*,BOOL,DWORD,DWORD);
 DWORD __attribute__((__stdcall__)) MsgWaitForMultipleObjectsEx(DWORD,const HANDLE*,DWORD,DWORD,DWORD);



 DWORD __attribute__((__stdcall__)) OemKeyScan(WORD);
 BOOL __attribute__((__stdcall__)) OemToCharA(LPCSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) OemToCharBuffA(LPCSTR,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) OemToCharBuffW(LPCSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) OemToCharW(LPCSTR,LPWSTR);
 BOOL __attribute__((__stdcall__)) OffsetRect(LPRECT,int,int);
 BOOL __attribute__((__stdcall__)) OpenClipboard(HWND);
 HDESK __attribute__((__stdcall__)) OpenDesktopA(LPSTR,DWORD,BOOL,DWORD);
 HDESK __attribute__((__stdcall__)) OpenDesktopW(LPWSTR,DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) OpenIcon(HWND);
 HDESK __attribute__((__stdcall__)) OpenInputDesktop(DWORD,BOOL,DWORD);
 HWINSTA __attribute__((__stdcall__)) OpenWindowStationA(LPSTR,BOOL,DWORD);
 HWINSTA __attribute__((__stdcall__)) OpenWindowStationW(LPWSTR,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) PaintDesktop(HDC);
 BOOL __attribute__((__stdcall__)) PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) PeekMessageW(LPMSG,HWND,UINT,UINT,UINT);


 BOOL __attribute__((__stdcall__)) PostMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) PostMessageW(HWND,UINT,WPARAM,LPARAM);
 void __attribute__((__stdcall__)) PostQuitMessage(int);
 BOOL __attribute__((__stdcall__)) PostThreadMessageA(DWORD,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) PostThreadMessageW(DWORD,UINT,WPARAM,LPARAM);



 BOOL __attribute__((__stdcall__)) PtInRect(LPCRECT,POINT);
 HWND __attribute__((__stdcall__)) RealChildWindowFromPoint(HWND,POINT);
 UINT __attribute__((__stdcall__)) RealGetWindowClassA(HWND,LPSTR,UINT);
 UINT __attribute__((__stdcall__)) RealGetWindowClassW(HWND,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) RedrawWindow(HWND,LPCRECT,HRGN,UINT);
 ATOM __attribute__((__stdcall__)) RegisterClassA(const WNDCLASSA*);
 ATOM __attribute__((__stdcall__)) RegisterClassW(const WNDCLASSW*);
 ATOM __attribute__((__stdcall__)) RegisterClassExA(const WNDCLASSEXA*);
 ATOM __attribute__((__stdcall__)) RegisterClassExW(const WNDCLASSEXW*);
 UINT __attribute__((__stdcall__)) RegisterClipboardFormatA(LPCSTR);
 UINT __attribute__((__stdcall__)) RegisterClipboardFormatW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) RegisterHotKey(HWND,int,UINT,UINT);



 UINT __attribute__((__stdcall__)) RegisterWindowMessageA(LPCSTR);
 UINT __attribute__((__stdcall__)) RegisterWindowMessageW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) ReleaseCapture(void);
 int __attribute__((__stdcall__)) ReleaseDC(HWND,HDC);
 BOOL __attribute__((__stdcall__)) RemoveMenu(HMENU,UINT,UINT);
 HANDLE __attribute__((__stdcall__)) RemovePropA(HWND,LPCSTR);
 HANDLE __attribute__((__stdcall__)) RemovePropW(HWND,LPCWSTR);
 BOOL __attribute__((__stdcall__)) ReplyMessage(LRESULT);
 BOOL __attribute__((__stdcall__)) ScreenToClient(HWND,LPPOINT);
 BOOL __attribute__((__stdcall__)) ScrollDC(HDC,int,int,LPCRECT,LPCRECT,HRGN,LPRECT);
 BOOL __attribute__((__stdcall__)) ScrollWindow(HWND,int,int,LPCRECT,LPCRECT);
 int __attribute__((__stdcall__)) ScrollWindowEx(HWND,int,int,LPCRECT,LPCRECT,HRGN,LPRECT,UINT);
 LONG __attribute__((__stdcall__)) SendDlgItemMessageA(HWND,int,UINT,WPARAM,LPARAM);
 LONG __attribute__((__stdcall__)) SendDlgItemMessageW(HWND,int,UINT,WPARAM,LPARAM);



 LRESULT __attribute__((__stdcall__)) SendMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendMessageCallbackA(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
 BOOL __attribute__((__stdcall__)) SendMessageCallbackW(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,PDWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,PDWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageW(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendNotifyMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendNotifyMessageW(HWND,UINT,WPARAM,LPARAM);
 HWND __attribute__((__stdcall__)) SetActiveWindow(HWND);
 HWND __attribute__((__stdcall__)) SetCapture(HWND hWnd);
 BOOL __attribute__((__stdcall__)) SetCaretBlinkTime(UINT);
 BOOL __attribute__((__stdcall__)) SetCaretPos(int,int);
 DWORD __attribute__((__stdcall__)) SetClassLongA(HWND,int,LONG);
 DWORD __attribute__((__stdcall__)) SetClassLongW(HWND,int,LONG);







 WORD __attribute__((__stdcall__)) SetClassWord(HWND,int,WORD);
 HANDLE __attribute__((__stdcall__)) SetClipboardData(UINT,HANDLE);
 HWND __attribute__((__stdcall__)) SetClipboardViewer(HWND);
 HCURSOR __attribute__((__stdcall__)) SetCursor(HCURSOR);
 BOOL __attribute__((__stdcall__)) SetCursorPos(int,int);
 void __attribute__((__stdcall__)) SetDebugErrorLevel(DWORD);
 BOOL __attribute__((__stdcall__)) SetDlgItemInt(HWND,int,UINT,BOOL);
 BOOL __attribute__((__stdcall__)) SetDlgItemTextA(HWND,int,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetDlgItemTextW(HWND,int,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetDoubleClickTime(UINT);
 HWND __attribute__((__stdcall__)) SetFocus(HWND);
 BOOL __attribute__((__stdcall__)) SetForegroundWindow(HWND);
 BOOL __attribute__((__stdcall__)) SetKeyboardState(PBYTE);
 BOOL __attribute__((__stdcall__)) SetMenu(HWND,HMENU);
 BOOL __attribute__((__stdcall__)) SetMenuContextHelpId(HMENU,DWORD);
 BOOL __attribute__((__stdcall__)) SetMenuDefaultItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) SetMenuInfo(HMENU,LPCMENUINFO);
 BOOL __attribute__((__stdcall__)) SetMenuItemBitmaps(HMENU,UINT,UINT,HBITMAP,HBITMAP);
 BOOL __attribute__((__stdcall__)) SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) SetMenuItemInfoW( HMENU,UINT,BOOL,LPCMENUITEMINFOW);
 LPARAM __attribute__((__stdcall__)) SetMessageExtraInfo(LPARAM);
 BOOL __attribute__((__stdcall__)) SetMessageQueue(int);
 HWND __attribute__((__stdcall__)) SetParent(HWND,HWND);



 BOOL __attribute__((__stdcall__)) SetProcessWindowStation(HWINSTA);
 BOOL __attribute__((__stdcall__)) SetPropA(HWND,LPCSTR,HANDLE);
 BOOL __attribute__((__stdcall__)) SetPropW(HWND,LPCWSTR,HANDLE);
 BOOL __attribute__((__stdcall__)) SetRect(LPRECT,int,int,int,int);
 BOOL __attribute__((__stdcall__)) SetRectEmpty(LPRECT);
 int __attribute__((__stdcall__)) SetScrollInfo(HWND,int,LPCSCROLLINFO,BOOL);
 int __attribute__((__stdcall__)) SetScrollPos(HWND,int,int,BOOL);
 BOOL __attribute__((__stdcall__)) SetScrollRange(HWND,int,int,int,BOOL);
 BOOL __attribute__((__stdcall__)) SetSysColors(int,const INT *,const COLORREF *);

 BOOL __attribute__((__stdcall__)) SetSystemCursor(HCURSOR,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadDesktop(HDESK);
 UINT __attribute__((__stdcall__)) SetTimer(HWND,UINT,UINT,TIMERPROC);
 BOOL __attribute__((__stdcall__)) SetUserObjectInformationA(HANDLE,int,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) SetUserObjectInformationW(HANDLE,int,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) SetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR);



 BOOL __attribute__((__stdcall__)) SetWindowContextHelpId(HWND,DWORD);
 LONG __attribute__((__stdcall__)) SetWindowLongA(HWND,int,LONG);
 LONG __attribute__((__stdcall__)) SetWindowLongW(HWND,int,LONG);







 BOOL __attribute__((__stdcall__)) SetWindowPlacement(HWND hWnd,const WINDOWPLACEMENT*);
 BOOL __attribute__((__stdcall__)) SetWindowPos(HWND,HWND,int,int,int,int,UINT);
 int __attribute__((__stdcall__)) SetWindowRgn(HWND,HRGN,BOOL);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookA(int,HOOKPROC);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookW(int,HOOKPROC);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookExA(int,HOOKPROC,HINSTANCE,DWORD);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookExW(int,HOOKPROC,HINSTANCE,DWORD);
 BOOL __attribute__((__stdcall__)) SetWindowTextA(HWND,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetWindowTextW(HWND,LPCWSTR);
 WORD __attribute__((__stdcall__)) SetWindowWord(HWND,int,WORD);
 BOOL __attribute__((__stdcall__)) ShowCaret(HWND);
 int __attribute__((__stdcall__)) ShowCursor(BOOL);
 BOOL __attribute__((__stdcall__)) ShowOwnedPopups(HWND,BOOL);
 BOOL __attribute__((__stdcall__)) ShowScrollBar(HWND,int,BOOL);
 BOOL __attribute__((__stdcall__)) ShowWindow(HWND,int);
 BOOL __attribute__((__stdcall__)) ShowWindowAsync(HWND,int);
 BOOL __attribute__((__stdcall__)) SubtractRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) SwapMouseButton(BOOL);
 BOOL __attribute__((__stdcall__)) SwitchDesktop(HDESK);



 BOOL __attribute__((__stdcall__)) SystemParametersInfoA(UINT,UINT,PVOID,UINT);
 BOOL __attribute__((__stdcall__)) SystemParametersInfoW(UINT,UINT,PVOID,UINT);
 LONG __attribute__((__stdcall__)) TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
 LONG __attribute__((__stdcall__)) TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
 WORD __attribute__((__stdcall__)) TileWindows(HWND,UINT,LPCRECT,UINT,const HWND *);
 int __attribute__((__stdcall__)) ToAscii(UINT,UINT,PBYTE,LPWORD,UINT);
 int __attribute__((__stdcall__)) ToAsciiEx(UINT,UINT,PBYTE,LPWORD,UINT,HKL);
 int __attribute__((__stdcall__)) ToUnicode(UINT,UINT,PBYTE,LPWSTR,int,UINT);
 int __attribute__((__stdcall__)) ToUnicodeEx(UINT,UINT,PBYTE,LPWSTR,int,UINT,HKL);
 BOOL __attribute__((__stdcall__)) TrackMouseEvent(LPTRACKMOUSEEVENT);
 BOOL __attribute__((__stdcall__)) TrackPopupMenu(HMENU,UINT,int,int,int,HWND,LPCRECT);
 BOOL __attribute__((__stdcall__)) TrackPopupMenuEx(HMENU,UINT,int,int,HWND,LPTPMPARAMS);
 int __attribute__((__stdcall__)) TranslateAcceleratorA(HWND,HACCEL,LPMSG);
 int __attribute__((__stdcall__)) TranslateAcceleratorW(HWND,HACCEL,LPMSG);
 BOOL __attribute__((__stdcall__)) TranslateMDISysAccel(HWND,LPMSG);
 BOOL __attribute__((__stdcall__)) TranslateMessage(const MSG*);
 BOOL __attribute__((__stdcall__)) UnhookWindowsHook(int,HOOKPROC);
 BOOL __attribute__((__stdcall__)) UnhookWindowsHookEx(HHOOK);



 BOOL __attribute__((__stdcall__)) UnionRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) UnloadKeyboardLayout(HKL);
 BOOL __attribute__((__stdcall__)) UnregisterClassA(LPCSTR,HINSTANCE);
 BOOL __attribute__((__stdcall__)) UnregisterClassW(LPCWSTR,HINSTANCE);



 BOOL __attribute__((__stdcall__)) UnregisterHotKey(HWND,int);
 BOOL __attribute__((__stdcall__)) UpdateWindow(HWND);



 BOOL __attribute__((__stdcall__)) ValidateRect(HWND,LPCRECT);
 BOOL __attribute__((__stdcall__)) ValidateRgn(HWND,HRGN);
 SHORT __attribute__((__stdcall__)) VkKeyScanA(CHAR);
 SHORT __attribute__((__stdcall__)) VkKeyScanExA(CHAR,HKL);
 SHORT __attribute__((__stdcall__)) VkKeyScanExW(WCHAR,HKL);
 SHORT __attribute__((__stdcall__)) VkKeyScanW(WCHAR);
 DWORD __attribute__((__stdcall__)) WaitForInputIdle(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) WaitMessage(void);
 HWND __attribute__((__stdcall__)) WindowFromDC(HDC hDC);
 HWND __attribute__((__stdcall__)) WindowFromPoint(POINT);
 UINT __attribute__((__stdcall__)) WinExec(LPCSTR,UINT);
 BOOL __attribute__((__stdcall__)) WinHelpA(HWND,LPCSTR,UINT,DWORD);
 BOOL __attribute__((__stdcall__)) WinHelpW(HWND,LPCWSTR,UINT,DWORD);
 int __attribute__((__cdecl__)) wsprintfA(LPSTR,LPCSTR,...);
 int __attribute__((__cdecl__)) wsprintfW(LPWSTR,LPCWSTR,...);
 int __attribute__((__stdcall__)) wvsprintfA(LPSTR,LPCSTR,va_list arglist);
 int __attribute__((__stdcall__)) wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);
# 4249 "C:/upp/mingw/include/winuser.h" 3
typedef WNDCLASSA WNDCLASS,*LPWNDCLASS,*PWNDCLASS;
typedef WNDCLASSEXA WNDCLASSEX,*LPWNDCLASSEX,*PWNDCLASSEX;
typedef MENUITEMINFOA MENUITEMINFO,*LPMENUITEMINFO;
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
typedef MSGBOXPARAMSA MSGBOXPARAMS,*PMSGBOXPARAMS,*LPMSGBOXPARAMS;
typedef HIGHCONTRASTA HIGHCONTRAST,*LPHIGHCONTRAST;
typedef SERIALKEYSA SERIALKEYS,*LPSERIALKEYS;
typedef SOUNDSENTRYA SOUNDSENTRY,*LPSOUNDSENTRY;
typedef CREATESTRUCTA CREATESTRUCT, *LPCREATESTRUCT;
typedef CBT_CREATEWNDA CBT_CREATEWND, *LPCBT_CREATEWND;
typedef MDICREATESTRUCTA MDICREATESTRUCT,*LPMDICREATESTRUCT;
typedef MULTIKEYHELPA MULTIKEYHELP,*PMULTIKEYHELP,*LPMULTIKEYHELP;
typedef MONITORINFOEXA MONITORINFOEX, *LPMONITORINFOEX;
# 4396 "C:/upp/mingw/include/winuser.h" 3
typedef ICONMETRICSA ICONMETRICS,*LPICONMETRICS;
typedef NONCLIENTMETRICSA NONCLIENTMETRICS,*LPNONCLIENTMETRICS;
# 4409 "C:/upp/mingw/include/winuser.h" 3
}
# 56 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winnls.h" 1 3



       
# 5 "C:/upp/mingw/include/winnls.h" 3
# 16 "C:/upp/mingw/include/winnls.h" 3
extern "C" {
# 454 "C:/upp/mingw/include/winnls.h" 3
typedef DWORD LCTYPE;
typedef DWORD CALTYPE;
typedef DWORD CALID;
typedef DWORD LGRPID;
typedef DWORD GEOID;
typedef DWORD GEOTYPE;
typedef DWORD GEOCLASS;
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *GEO_ENUMPROC)(GEOID);

enum NLS_FUNCTION {
 COMPARE_STRING = 0x0001
};
typedef enum NLS_FUNCTION NLS_FUNCTION;
enum SYSGEOCLASS {
 GEOCLASS_NATION = 16,
 GEOCLASS_REGION = 14
};
enum SYSGEOTYPE {
 GEO_NATION = 0x0001,
 GEO_LATITUDE = 0x0002,
 GEO_LONGITUDE = 0x0003,
 GEO_ISO2 = 0x0004,
 GEO_ISO3 = 0x0005,
 GEO_RFC1766 = 0x0006,
 GEO_LCID = 0x0007,
 GEO_FRIENDLYNAME = 0x0008,
 GEO_OFFICIALNAME = 0x0009,
 GEO_TIMEZONES = 0x000a,
 GEO_OFFICIALLANGUAGES = 0x000a
};

typedef struct _cpinfo {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
} CPINFO,*LPCPINFO;
typedef struct _cpinfoexA {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
 WCHAR UnicodeDefaultChar;
 UINT CodePage;
 CHAR CodePageName[260];
} CPINFOEXA,*LPCPINFOEXA;
typedef struct _cpinfoexW {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
 WCHAR UnicodeDefaultChar;
 UINT CodePage;
 WCHAR CodePageName[260];
} CPINFOEXW,*LPCPINFOEXW;
typedef struct _currencyfmtA {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPSTR lpDecimalSep;
 LPSTR lpThousandSep;
 UINT NegativeOrder;
 UINT PositiveOrder;
 LPSTR lpCurrencySymbol;
} CURRENCYFMTA,*LPCURRENCYFMTA;
typedef struct _currencyfmtW {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPWSTR lpDecimalSep;
 LPWSTR lpThousandSep;
 UINT NegativeOrder;
 UINT PositiveOrder;
 LPWSTR lpCurrencySymbol;
} CURRENCYFMTW,*LPCURRENCYFMTW;
typedef struct nlsversioninfo {
 DWORD dwNLSVersionInfoSize;
 DWORD dwNLSVersion;
 DWORD dwDefinedVersion;
} NLSVERSIONINFO,*LPNLSVERSIONINFO;
typedef struct _numberfmtA {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPSTR lpDecimalSep;
 LPSTR lpThousandSep;
 UINT NegativeOrder;
} NUMBERFMTA,*LPNUMBERFMTA;
typedef struct _numberfmtW {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPWSTR lpDecimalSep;
 LPWSTR lpThousandSep;
 UINT NegativeOrder;
} NUMBERFMTW,*LPNUMBERFMTW;

 int __attribute__((__stdcall__)) CompareStringA(LCID,DWORD,LPCSTR,int,LPCSTR,int);
 int __attribute__((__stdcall__)) CompareStringW(LCID,DWORD,LPCWSTR,int,LPCWSTR,int);
 LCID __attribute__((__stdcall__)) ConvertDefaultLocale(LCID);
 BOOL __attribute__((__stdcall__)) EnumCalendarInfoA(CALINFO_ENUMPROCA,LCID,CALID,CALTYPE);
 BOOL __attribute__((__stdcall__)) EnumCalendarInfoW(CALINFO_ENUMPROCW,LCID,CALID,CALTYPE);
 BOOL __attribute__((__stdcall__)) EnumDateFormatsA(DATEFMT_ENUMPROCA,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumDateFormatsW(DATEFMT_ENUMPROCW,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemCodePagesA(CODEPAGE_ENUMPROCA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemCodePagesW(CODEPAGE_ENUMPROCW,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemGeoID(GEOCLASS,GEOID,GEO_ENUMPROC);
 BOOL __attribute__((__stdcall__)) EnumSystemLocalesA(LOCALE_ENUMPROCA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemLocalesW(LOCALE_ENUMPROCW,DWORD);
 BOOL __attribute__((__stdcall__)) EnumTimeFormatsA(TIMEFMT_ENUMPROCA,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumTimeFormatsW(TIMEFMT_ENUMPROCW,LCID,DWORD);
 int __attribute__((__stdcall__)) FoldStringA(DWORD,LPCSTR,int,LPSTR,int);
 int __attribute__((__stdcall__)) FoldStringW(DWORD,LPCWSTR,int,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetACP(void);
 int __attribute__((__stdcall__)) GetCalendarInfoA(LCID,CALID,CALTYPE,LPSTR,int,LPDWORD);
 int __attribute__((__stdcall__)) GetCalendarInfoW(LCID,CALID,CALTYPE,LPWSTR,int,LPDWORD);
 BOOL __attribute__((__stdcall__)) GetCPInfo(UINT,LPCPINFO);
 BOOL __attribute__((__stdcall__)) GetCPInfoExA(UINT,DWORD,LPCPINFOEXA);
 BOOL __attribute__((__stdcall__)) GetCPInfoExW(UINT,DWORD,LPCPINFOEXW);
 int __attribute__((__stdcall__)) GetCurrencyFormatA(LCID,DWORD,LPCSTR,const CURRENCYFMTA*,LPSTR,int);
 int __attribute__((__stdcall__)) GetCurrencyFormatW(LCID,DWORD,LPCWSTR,const CURRENCYFMTW*,LPWSTR,int);
 int __attribute__((__stdcall__)) GetDateFormatA(LCID,DWORD,const SYSTEMTIME*,LPCSTR,LPSTR,int);
 int __attribute__((__stdcall__)) GetDateFormatW(LCID,DWORD,const SYSTEMTIME*,LPCWSTR,LPWSTR,int);
 int __attribute__((__stdcall__)) GetGeoInfoA(GEOID,GEOTYPE,LPSTR,int,LANGID);
 int __attribute__((__stdcall__)) GetGeoInfoW(GEOID,GEOTYPE,LPWSTR,int,LANGID);
 int __attribute__((__stdcall__)) GetLocaleInfoA(LCID,LCTYPE,LPSTR,int);
 int __attribute__((__stdcall__)) GetLocaleInfoW(LCID,LCTYPE,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) GetNLSVersion(NLS_FUNCTION,LCID,LPNLSVERSIONINFO);
 int __attribute__((__stdcall__)) GetNumberFormatA(LCID,DWORD,LPCSTR,const NUMBERFMTA*,LPSTR,int);
 int __attribute__((__stdcall__)) GetNumberFormatW(LCID,DWORD,LPCWSTR,const NUMBERFMTW*,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetOEMCP(void);
 BOOL __attribute__((__stdcall__)) GetStringTypeA(LCID,DWORD,LPCSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeW(DWORD,LPCWSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeExA(LCID,DWORD,LPCSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeExW(LCID,DWORD,LPCWSTR,int,LPWORD);
 LANGID __attribute__((__stdcall__)) GetSystemDefaultLangID(void);
 LCID __attribute__((__stdcall__)) GetSystemDefaultLCID(void);
 LCID __attribute__((__stdcall__)) GetThreadLocale(void);
 int __attribute__((__stdcall__)) GetTimeFormatA(LCID,DWORD,const SYSTEMTIME*,LPCSTR,LPSTR,int);
 int __attribute__((__stdcall__)) GetTimeFormatW(LCID,DWORD,const SYSTEMTIME*,LPCWSTR,LPWSTR,int);
 LANGID __attribute__((__stdcall__)) GetUserDefaultLangID(void);
 LCID __attribute__((__stdcall__)) GetUserDefaultLCID(void);
 GEOID __attribute__((__stdcall__)) GetUserGeoID(GEOCLASS);
 BOOL __attribute__((__stdcall__)) IsDBCSLeadByte(BYTE);
 BOOL __attribute__((__stdcall__)) IsDBCSLeadByteEx(UINT,BYTE);
 BOOL __attribute__((__stdcall__)) IsNLSDefinedString(NLS_FUNCTION,DWORD,LPNLSVERSIONINFO,LPCWSTR,int);
 BOOL __attribute__((__stdcall__)) IsValidCodePage(UINT);
 BOOL __attribute__((__stdcall__)) IsValidLocale(LCID,DWORD);
 int __attribute__((__stdcall__)) LCMapStringA(LCID,DWORD,LPCSTR,int,LPSTR,int);
 int __attribute__((__stdcall__)) LCMapStringW(LCID,DWORD,LPCWSTR,int,LPWSTR,int);
 int __attribute__((__stdcall__)) MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);
 int __attribute__((__stdcall__)) SetCalendarInfoA(LCID,CALID,CALTYPE,LPCSTR);
 int __attribute__((__stdcall__)) SetCalendarInfoW(LCID,CALID,CALTYPE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetLocaleInfoA(LCID,LCTYPE,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetLocaleInfoW(LCID,LCTYPE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetThreadLocale(LCID);
 BOOL __attribute__((__stdcall__)) SetUserGeoID(GEOID);
 int __attribute__((__stdcall__)) WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);
# 698 "C:/upp/mingw/include/winnls.h" 3
typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
# 732 "C:/upp/mingw/include/winnls.h" 3
}
# 59 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winver.h" 1 3



       
# 5 "C:/upp/mingw/include/winver.h" 3



extern "C" {
# 85 "C:/upp/mingw/include/winver.h" 3
typedef struct tagVS_FIXEDFILEINFO {
 DWORD dwSignature;
 DWORD dwStrucVersion;
 DWORD dwFileVersionMS;
 DWORD dwFileVersionLS;
 DWORD dwProductVersionMS;
 DWORD dwProductVersionLS;
 DWORD dwFileFlagsMask;
 DWORD dwFileFlags;
 DWORD dwFileOS;
 DWORD dwFileType;
 DWORD dwFileSubtype;
 DWORD dwFileDateMS;
 DWORD dwFileDateLS;
} VS_FIXEDFILEINFO;
DWORD __attribute__((__stdcall__)) VerFindFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,PUINT,LPSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerFindFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT,LPWSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerInstallFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerInstallFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
DWORD __attribute__((__stdcall__)) GetFileVersionInfoSizeA(LPCSTR,PDWORD);
DWORD __attribute__((__stdcall__)) GetFileVersionInfoSizeW(LPCWSTR,PDWORD);
BOOL __attribute__((__stdcall__)) GetFileVersionInfoA(LPCSTR,DWORD,DWORD,PVOID);
BOOL __attribute__((__stdcall__)) GetFileVersionInfoW(LPCWSTR,DWORD,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) VerLanguageNameA(DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) VerLanguageNameW(DWORD,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) VerQueryValueA(const LPVOID,LPSTR,LPVOID*,PUINT);
BOOL __attribute__((__stdcall__)) VerQueryValueW(const LPVOID,LPWSTR,LPVOID*,PUINT);
# 131 "C:/upp/mingw/include/winver.h" 3
}
# 62 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winnetwk.h" 1 3



       
# 5 "C:/upp/mingw/include/winnetwk.h" 3



extern "C" {
# 160 "C:/upp/mingw/include/winnetwk.h" 3
typedef struct _NETRESOURCEA {
 DWORD dwScope;
 DWORD dwType;
 DWORD dwDisplayType;
 DWORD dwUsage;
 LPSTR lpLocalName;
 LPSTR lpRemoteName;
 LPSTR lpComment ;
 LPSTR lpProvider;
}NETRESOURCEA,*LPNETRESOURCEA;
typedef struct _NETRESOURCEW {
 DWORD dwScope;
 DWORD dwType;
 DWORD dwDisplayType;
 DWORD dwUsage;
 LPWSTR lpLocalName;
 LPWSTR lpRemoteName;
 LPWSTR lpComment ;
 LPWSTR lpProvider;
}NETRESOURCEW,*LPNETRESOURCEW;
typedef struct _CONNECTDLGSTRUCTA{
 DWORD cbStructure;
 HWND hwndOwner;
 LPNETRESOURCEA lpConnRes;
 DWORD dwFlags;
 DWORD dwDevNum;
} CONNECTDLGSTRUCTA,*LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
 DWORD cbStructure;
 HWND hwndOwner;
 LPNETRESOURCEW lpConnRes;
 DWORD dwFlags;
 DWORD dwDevNum;
} CONNECTDLGSTRUCTW,*LPCONNECTDLGSTRUCTW;
typedef struct _DISCDLGSTRUCTA{
 DWORD cbStructure;
 HWND hwndOwner;
 LPSTR lpLocalName;
 LPSTR lpRemoteName;
 DWORD dwFlags;
} DISCDLGSTRUCTA,*LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
 DWORD cbStructure;
 HWND hwndOwner;
 LPWSTR lpLocalName;
 LPWSTR lpRemoteName;
 DWORD dwFlags;
} DISCDLGSTRUCTW,*LPDISCDLGSTRUCTW;
typedef struct _UNIVERSAL_NAME_INFOA { LPSTR lpUniversalName; }UNIVERSAL_NAME_INFOA,*LPUNIVERSAL_NAME_INFOA;
typedef struct _UNIVERSAL_NAME_INFOW { LPWSTR lpUniversalName; }UNIVERSAL_NAME_INFOW,*LPUNIVERSAL_NAME_INFOW;
typedef struct _REMOTE_NAME_INFOA {
 LPSTR lpUniversalName;
 LPSTR lpConnectionName;
 LPSTR lpRemainingPath;
}REMOTE_NAME_INFOA,*LPREMOTE_NAME_INFOA;
typedef struct _REMOTE_NAME_INFOW {
 LPWSTR lpUniversalName;
 LPWSTR lpConnectionName;
 LPWSTR lpRemainingPath;
}REMOTE_NAME_INFOW,*LPREMOTE_NAME_INFOW;
typedef struct _NETINFOSTRUCT{
 DWORD cbStructure;
 DWORD dwProviderVersion;
 DWORD dwStatus;
 DWORD dwCharacteristics;
 DWORD dwHandle;
 WORD wNetType;
 DWORD dwPrinters;
 DWORD dwDrives;
} NETINFOSTRUCT,*LPNETINFOSTRUCT;
typedef UINT(__attribute__((__stdcall__)) *PFNGETPROFILEPATHA)(LPCSTR,LPSTR,UINT);
typedef UINT(__attribute__((__stdcall__)) *PFNGETPROFILEPATHW)(LPCWSTR,LPWSTR,UINT);
typedef UINT(__attribute__((__stdcall__)) *PFNRECONCILEPROFILEA)(LPCSTR,LPCSTR,DWORD);
typedef UINT(__attribute__((__stdcall__)) *PFNRECONCILEPROFILEW)(LPCWSTR,LPCWSTR,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PFNPROCESSPOLICIESA)(HWND,LPCSTR,LPCSTR,LPCSTR,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PFNPROCESSPOLICIESW)(HWND,LPCWSTR,LPCWSTR,LPCWSTR,DWORD);
typedef struct _NETCONNECTINFOSTRUCT{
 DWORD cbStructure;
 DWORD dwFlags;
 DWORD dwSpeed;
 DWORD dwDelay;
 DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,*LPNETCONNECTINFOSTRUCT;

DWORD __attribute__((__stdcall__)) WNetAddConnectionA(LPCSTR,LPCSTR,LPCSTR);
DWORD __attribute__((__stdcall__)) WNetAddConnectionW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD __attribute__((__stdcall__)) WNetAddConnection2A(LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection2W(LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection3A(HWND,LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection3W(HWND,LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetCancelConnectionA(LPCSTR,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnectionW(LPCWSTR,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnection2A(LPCSTR,DWORD,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnection2W(LPCWSTR,DWORD,BOOL);
DWORD __attribute__((__stdcall__)) WNetGetConnectionA(LPCSTR,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetConnectionW(LPCWSTR,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetUseConnectionA(HWND,LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD,LPSTR,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) WNetUseConnectionW(HWND,LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD,LPWSTR,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) WNetSetConnectionA(LPCSTR,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) WNetSetConnectionW(LPCWSTR,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog(HWND,DWORD);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog(HWND,DWORD);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog1A(LPDISCDLGSTRUCTA);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog1W(LPDISCDLGSTRUCTW);
DWORD __attribute__((__stdcall__)) WNetOpenEnumA(DWORD,DWORD,DWORD,LPNETRESOURCEA,LPHANDLE);
DWORD __attribute__((__stdcall__)) WNetOpenEnumW(DWORD,DWORD,DWORD,LPNETRESOURCEW,LPHANDLE);
DWORD __attribute__((__stdcall__)) WNetEnumResourceA(HANDLE,PDWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetEnumResourceW(HANDLE,PDWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetCloseEnum(HANDLE);
DWORD __attribute__((__stdcall__)) WNetGetUniversalNameA(LPCSTR,DWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUniversalNameW(LPCWSTR,DWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUserA(LPCSTR,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUserW(LPCWSTR,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetProviderNameA(DWORD,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetProviderNameW(DWORD,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetNetworkInformationA(LPCSTR,LPNETINFOSTRUCT);
DWORD __attribute__((__stdcall__)) WNetGetNetworkInformationW(LPCWSTR,LPNETINFOSTRUCT);
DWORD __attribute__((__stdcall__)) WNetGetResourceInformationA(LPNETRESOURCEA,LPVOID,LPDWORD,LPSTR*);
DWORD __attribute__((__stdcall__)) WNetGetResourceInformationW(LPNETRESOURCEW,LPVOID,LPDWORD,LPWSTR*);
DWORD __attribute__((__stdcall__)) WNetGetResourceParentA(LPNETRESOURCEA,LPVOID,LPDWORD);
DWORD __attribute__((__stdcall__)) WNetGetResourceParentW(LPNETRESOURCEW,LPVOID,LPDWORD);
DWORD __attribute__((__stdcall__)) WNetGetLastErrorA(PDWORD,LPSTR,DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetGetLastErrorW(PDWORD,LPWSTR,DWORD,LPWSTR,DWORD);
DWORD __attribute__((__stdcall__)) MultinetGetConnectionPerformanceA(LPNETRESOURCEA,LPNETCONNECTINFOSTRUCT);
DWORD __attribute__((__stdcall__)) MultinetGetConnectionPerformanceW(LPNETRESOURCEW,LPNETCONNECTINFOSTRUCT);
# 320 "C:/upp/mingw/include/winnetwk.h" 3
typedef NETRESOURCEA NETRESOURCE,*LPNETRESOURCE;
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT,*LPCONNECTDLGSTRUCT;
typedef DISCDLGSTRUCTA DISCDLGSTRUCT,*LPDISCDLGSTRUCT;
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO,*LPUNIVERSAL_NAME_INFO;
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO,*LPREMOTE_NAME_INFO;
# 348 "C:/upp/mingw/include/winnetwk.h" 3
}
# 65 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winreg.h" 1 3



       
# 5 "C:/upp/mingw/include/winreg.h" 3







extern "C" {
# 50 "C:/upp/mingw/include/winreg.h" 3
typedef ACCESS_MASK REGSAM;
typedef struct value_entA {
 LPSTR ve_valuename;
 DWORD ve_valuelen;
 DWORD ve_valueptr;
 DWORD ve_type;
} VALENTA,*PVALENTA;
typedef struct value_entW {
 LPWSTR ve_valuename;
 DWORD ve_valuelen;
 DWORD ve_valueptr;
 DWORD ve_type;
} VALENTW,*PVALENTW;
 BOOL __attribute__((__stdcall__)) AbortSystemShutdownA(LPCSTR);
 BOOL __attribute__((__stdcall__)) AbortSystemShutdownW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) InitiateSystemShutdownA(LPSTR,LPSTR,DWORD,BOOL,BOOL);
 BOOL __attribute__((__stdcall__)) InitiateSystemShutdownW(LPWSTR,LPWSTR,DWORD,BOOL,BOOL);
 LONG __attribute__((__stdcall__)) RegCloseKey(HKEY);
 LONG __attribute__((__stdcall__)) RegConnectRegistryA(LPCSTR,HKEY,PHKEY);
 LONG __attribute__((__stdcall__)) RegConnectRegistryW(LPCWSTR,HKEY,PHKEY);
 LONG __attribute__((__stdcall__)) RegCreateKeyA(HKEY,LPCSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegCreateKeyExA(HKEY,LPCSTR,DWORD,LPSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,PDWORD);
 LONG __attribute__((__stdcall__)) RegCreateKeyExW(HKEY,LPCWSTR,DWORD,LPWSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,PDWORD);
 LONG __attribute__((__stdcall__)) RegCreateKeyW(HKEY,LPCWSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegDeleteKeyA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegDeleteKeyW(HKEY,LPCWSTR);




 LONG __attribute__((__stdcall__)) RegDeleteValueA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegDeleteValueW(HKEY,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegEnumKeyA(HKEY,DWORD,LPSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegEnumKeyW(HKEY,DWORD,LPWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegEnumKeyExA(HKEY,DWORD,LPSTR,PDWORD,PDWORD,LPSTR,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegEnumKeyExW(HKEY,DWORD,LPWSTR,PDWORD,PDWORD,LPWSTR,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegEnumValueA(HKEY,DWORD,LPSTR,PDWORD,PDWORD,PDWORD,LPBYTE,PDWORD);
 LONG __attribute__((__stdcall__)) RegEnumValueW(HKEY,DWORD,LPWSTR,PDWORD,PDWORD,PDWORD,LPBYTE,PDWORD);
 LONG __attribute__((__stdcall__)) RegFlushKey(HKEY);
 LONG __attribute__((__stdcall__)) RegGetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PDWORD);
 LONG __attribute__((__stdcall__)) RegLoadKeyA(HKEY,LPCSTR,LPCSTR);
 LONG __attribute__((__stdcall__)) RegLoadKeyW(HKEY,LPCWSTR,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegNotifyChangeKeyValue(HKEY,BOOL,DWORD,HANDLE,BOOL);
 LONG __attribute__((__stdcall__)) RegOpenKeyA(HKEY,LPCSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyW(HKEY,LPCWSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegQueryInfoKeyA(HKEY,LPSTR,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegQueryInfoKeyW(HKEY,LPWSTR,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegQueryMultipleValuesA(HKEY,PVALENTA,DWORD,LPSTR,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryMultipleValuesW(HKEY,PVALENTW,DWORD,LPWSTR,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG);
 LONG __attribute__((__stdcall__)) RegQueryValueExA(HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG);
 LONG __attribute__((__stdcall__)) RegReplaceKeyA(HKEY,LPCSTR,LPCSTR,LPCSTR);
 LONG __attribute__((__stdcall__)) RegReplaceKeyW(HKEY,LPCWSTR,LPCWSTR,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegRestoreKeyA(HKEY,LPCSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegRestoreKeyW(HKEY,LPCWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegSaveKeyA(HKEY,LPCSTR,LPSECURITY_ATTRIBUTES);
 LONG __attribute__((__stdcall__)) RegSaveKeyW(HKEY,LPCWSTR,LPSECURITY_ATTRIBUTES);
 LONG __attribute__((__stdcall__)) RegSetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 LONG __attribute__((__stdcall__)) RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,const BYTE*,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,const BYTE*,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegUnLoadKeyA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegUnLoadKeyW(HKEY,LPCWSTR);
# 148 "C:/upp/mingw/include/winreg.h" 3
typedef VALENTA VALENT,*PVALENT;
# 178 "C:/upp/mingw/include/winreg.h" 3
}
# 68 "C:/upp/mingw/include/windows.h" 2 3


# 1 "C:/upp/mingw/include/winsvc.h" 1 3



       
# 5 "C:/upp/mingw/include/winsvc.h" 3







extern "C" {
# 74 "C:/upp/mingw/include/winsvc.h" 3
typedef struct _SERVICE_STATUS {
 DWORD dwServiceType;
 DWORD dwCurrentState;
 DWORD dwControlsAccepted;
 DWORD dwWin32ExitCode;
 DWORD dwServiceSpecificExitCode;
 DWORD dwCheckPoint;
 DWORD dwWaitHint;
} SERVICE_STATUS,*LPSERVICE_STATUS;
typedef struct _SERVICE_STATUS_PROCESS {
 DWORD dwServiceType;
 DWORD dwCurrentState;
 DWORD dwControlsAccepted;
 DWORD dwWin32ExitCode;
 DWORD dwServiceSpecificExitCode;
 DWORD dwCheckPoint;
 DWORD dwWaitHint;
 DWORD dwProcessId;
 DWORD dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;
typedef enum _SC_STATUS_TYPE {
 SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;
typedef enum _SC_ENUM_TYPE {
        SC_ENUM_PROCESS_INFO = 0
} SC_ENUM_TYPE;
typedef struct _ENUM_SERVICE_STATUSA {
 LPSTR lpServiceName;
 LPSTR lpDisplayName;
 SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA,*LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
 LPWSTR lpServiceName;
 LPWSTR lpDisplayName;
 SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW,*LPENUM_SERVICE_STATUSW;
typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
 LPSTR lpServiceName;
 LPSTR lpDisplayName;
 SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA,*LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
 LPWSTR lpServiceName;
 LPWSTR lpDisplayName;
 SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW,*LPENUM_SERVICE_STATUS_PROCESSW;
typedef struct _QUERY_SERVICE_CONFIGA {
 DWORD dwServiceType;
 DWORD dwStartType;
 DWORD dwErrorControl;
 LPSTR lpBinaryPathName;
 LPSTR lpLoadOrderGroup;
 DWORD dwTagId;
 LPSTR lpDependencies;
 LPSTR lpServiceStartName;
 LPSTR lpDisplayName;
} QUERY_SERVICE_CONFIGA,*LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
 DWORD dwServiceType;
 DWORD dwStartType;
 DWORD dwErrorControl;
 LPWSTR lpBinaryPathName;
 LPWSTR lpLoadOrderGroup;
 DWORD dwTagId;
 LPWSTR lpDependencies;
 LPWSTR lpServiceStartName;
 LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW,*LPQUERY_SERVICE_CONFIGW;
typedef struct _QUERY_SERVICE_LOCK_STATUSA {
 DWORD fIsLocked;
 LPSTR lpLockOwner;
 DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA,*LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
 DWORD fIsLocked;
 LPWSTR lpLockOwner;
 DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW,*LPQUERY_SERVICE_LOCK_STATUSW;
typedef void (__attribute__((__stdcall__)) *LPSERVICE_MAIN_FUNCTIONA)(DWORD,LPSTR*);
typedef void (__attribute__((__stdcall__)) *LPSERVICE_MAIN_FUNCTIONW)(DWORD,LPWSTR*);
typedef struct _SERVICE_TABLE_ENTRYA {
 LPSTR lpServiceName;
 LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
} SERVICE_TABLE_ENTRYA,*LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
 LPWSTR lpServiceName;
 LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
} SERVICE_TABLE_ENTRYW,*LPSERVICE_TABLE_ENTRYW;
typedef struct SC_HANDLE__{int i;}*SC_HANDLE;
typedef SC_HANDLE *LPSC_HANDLE;
typedef PVOID SC_LOCK;
typedef DWORD SERVICE_STATUS_HANDLE;
typedef void(__attribute__((__stdcall__)) *LPHANDLER_FUNCTION)(DWORD);
typedef DWORD (__attribute__((__stdcall__)) *LPHANDLER_FUNCTION_EX)(DWORD,DWORD,LPVOID,LPVOID);
typedef struct _SERVICE_DESCRIPTIONA {
 LPSTR lpDescription;
} SERVICE_DESCRIPTIONA,*LPSERVICE_DESCRIPTIONA;
typedef struct _SERVICE_DESCRIPTIONW {
 LPWSTR lpDescription;
} SERVICE_DESCRIPTIONW,*LPSERVICE_DESCRIPTIONW;
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE = 0,
        SC_ACTION_RESTART = 1,
        SC_ACTION_REBOOT = 2,
        SC_ACTION_RUN_COMMAND = 3
} SC_ACTION_TYPE;
typedef struct _SC_ACTION {
 SC_ACTION_TYPE Type;
 DWORD Delay;
} SC_ACTION,*LPSC_ACTION;
typedef struct _SERVICE_FAILURE_ACTIONSA {
 DWORD dwResetPeriod;
 LPSTR lpRebootMsg;
 LPSTR lpCommand;
 DWORD cActions;
 SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA,*LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
 DWORD dwResetPeriod;
 LPWSTR lpRebootMsg;
 LPWSTR lpCommand;
 DWORD cActions;
 SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW,*LPSERVICE_FAILURE_ACTIONSW;

 BOOL __attribute__((__stdcall__)) ChangeServiceConfigA(SC_HANDLE,DWORD,DWORD,DWORD,LPCSTR,LPCSTR,LPDWORD,LPCSTR,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfigW(SC_HANDLE,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,LPDWORD,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfig2A(SC_HANDLE,DWORD,LPVOID);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfig2W(SC_HANDLE,DWORD,LPVOID);
 BOOL __attribute__((__stdcall__)) CloseServiceHandle(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) ControlService(SC_HANDLE,DWORD,LPSERVICE_STATUS);
 SC_HANDLE __attribute__((__stdcall__)) CreateServiceA(SC_HANDLE,LPCSTR,LPCSTR,DWORD,DWORD,DWORD,DWORD,LPCSTR,LPCSTR,PDWORD,LPCSTR,LPCSTR,LPCSTR);
 SC_HANDLE __attribute__((__stdcall__)) CreateServiceW(SC_HANDLE,LPCWSTR,LPCWSTR,DWORD,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,PDWORD,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) DeleteService(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) EnumDependentServicesA(SC_HANDLE,DWORD,LPENUM_SERVICE_STATUSA,DWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumDependentServicesW(SC_HANDLE,DWORD,LPENUM_SERVICE_STATUSW,DWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusA(SC_HANDLE,DWORD,DWORD,LPENUM_SERVICE_STATUSA,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusW(SC_HANDLE,DWORD,DWORD,LPENUM_SERVICE_STATUSW,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusExA(SC_HANDLE,SC_ENUM_TYPE,DWORD,DWORD,LPBYTE,DWORD,LPDWORD,LPDWORD,LPDWORD,LPCSTR);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusExW(SC_HANDLE,SC_ENUM_TYPE,DWORD,DWORD,LPBYTE,DWORD,LPDWORD,LPDWORD,LPDWORD,LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetServiceDisplayNameA(SC_HANDLE,LPCSTR,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceDisplayNameW(SC_HANDLE,LPCWSTR,LPWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceKeyNameA(SC_HANDLE,LPCSTR,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceKeyNameW(SC_HANDLE,LPCWSTR,LPWSTR,PDWORD);
 SC_LOCK __attribute__((__stdcall__)) LockServiceDatabase(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) NotifyBootConfigStatus(BOOL);
 SC_HANDLE __attribute__((__stdcall__)) OpenSCManagerA(LPCSTR,LPCSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenSCManagerW(LPCWSTR,LPCWSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenServiceA(SC_HANDLE,LPCSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenServiceW(SC_HANDLE,LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfigA(SC_HANDLE,LPQUERY_SERVICE_CONFIGA,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfigW(SC_HANDLE,LPQUERY_SERVICE_CONFIGW,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfig2A(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfig2W(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceLockStatusA(SC_HANDLE,LPQUERY_SERVICE_LOCK_STATUSA,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceLockStatusW(SC_HANDLE,LPQUERY_SERVICE_LOCK_STATUSW,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceObjectSecurity(SC_HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceStatus(SC_HANDLE,LPSERVICE_STATUS);
 BOOL __attribute__((__stdcall__)) QueryServiceStatusEx(SC_HANDLE,SC_STATUS_TYPE,LPBYTE,DWORD,LPDWORD);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerA(LPCSTR,LPHANDLER_FUNCTION);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerW(LPCWSTR,LPHANDLER_FUNCTION);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerExA(LPCSTR,LPHANDLER_FUNCTION_EX,LPVOID);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerExW(LPCWSTR,LPHANDLER_FUNCTION_EX,LPVOID);
 BOOL __attribute__((__stdcall__)) SetServiceObjectSecurity(SC_HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) SetServiceStatus(SERVICE_STATUS_HANDLE,LPSERVICE_STATUS);
 BOOL __attribute__((__stdcall__)) StartServiceA(SC_HANDLE,DWORD,LPCSTR*);
 BOOL __attribute__((__stdcall__)) StartServiceCtrlDispatcherA(LPSERVICE_TABLE_ENTRYA);
 BOOL __attribute__((__stdcall__)) StartServiceCtrlDispatcherW(LPSERVICE_TABLE_ENTRYW);
 BOOL __attribute__((__stdcall__)) StartServiceW(SC_HANDLE,DWORD,LPCWSTR*);
 BOOL __attribute__((__stdcall__)) UnlockServiceDatabase(SC_LOCK);
# 278 "C:/upp/mingw/include/winsvc.h" 3
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS,*LPENUM_SERVICE_STATUS;
typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG,*LPQUERY_SERVICE_CONFIG;
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS,*LPQUERY_SERVICE_LOCK_STATUS;
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY,*LPSERVICE_TABLE_ENTRY;
typedef LPSERVICE_MAIN_FUNCTIONA LPSERVICE_MAIN_FUNCTION;
typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
# 311 "C:/upp/mingw/include/winsvc.h" 3
}
# 71 "C:/upp/mingw/include/windows.h" 2 3



# 1 "C:/upp/mingw/include/cderr.h" 1 3



       
# 5 "C:/upp/mingw/include/cderr.h" 3
# 75 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/dde.h" 1 3



       
# 5 "C:/upp/mingw/include/dde.h" 3



extern "C" {
# 23 "C:/upp/mingw/include/dde.h" 3
typedef struct {
 unsigned short bAppReturnCode:8,reserved:6,fBusy:1,fAck:1;
} DDEACK;
typedef struct {
 unsigned short reserved:14,fDeferUpd:1,fAckReq:1;
 short cfFormat;
} DDEADVISE;
typedef struct {
 unsigned short unused:12,fResponse:1,fRelease:1,reserved:1,fAckReq:1;
 short cfFormat;
 BYTE Value[1];
} DDEDATA;
typedef struct {
 unsigned short unused:13,fRelease:1,fReserved:2;
 short cfFormat;
 BYTE Value[1];
} DDEPOKE;
typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
         fAckReq:1;
    short cfFormat;
} DDELN;

typedef struct {
 unsigned short unused:12,fAck:1,fRelease:1,fReserved:1,fAckReq:1;
    short cfFormat;
    BYTE rgb[1];
} DDEUP;
BOOL __attribute__((__stdcall__)) DdeSetQualityOfService(HWND,const SECURITY_QUALITY_OF_SERVICE*,PSECURITY_QUALITY_OF_SERVICE);
BOOL __attribute__((__stdcall__)) ImpersonateDdeClientWindow(HWND,HWND);
LPARAM __attribute__((__stdcall__)) PackDDElParam(UINT,UINT_PTR,UINT_PTR);
BOOL __attribute__((__stdcall__)) UnpackDDElParam(UINT,LPARAM,PUINT_PTR,PUINT_PTR);
BOOL __attribute__((__stdcall__)) FreeDDElParam(UINT,LPARAM);
LPARAM __attribute__((__stdcall__)) ReuseDDElParam(LPARAM,UINT,UINT,UINT_PTR,UINT_PTR);



}
# 76 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/ddeml.h" 1 3



       
# 5 "C:/upp/mingw/include/ddeml.h" 3



extern "C" {
# 145 "C:/upp/mingw/include/ddeml.h" 3
typedef struct HCONVLIST__{int i;}*HCONVLIST;
typedef struct HCONV__{int i;}*HCONV;
typedef struct HSZ__{int i;}*HSZ;
typedef struct HDDEDATA__{int i;}*HDDEDATA;
typedef HDDEDATA __attribute__((__stdcall__)) FNCALLBACK(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
typedef HDDEDATA(__attribute__((__stdcall__)) *PFNCALLBACK)(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
typedef struct tagHSZPAIR {
 HSZ hszSvc;
 HSZ hszTopic;
} HSZPAIR, *PHSZPAIR;
typedef struct tagCONVCONTEXT {
 UINT cb;
 UINT wFlags;
 UINT wCountryID;
 int iCodePage;
 DWORD dwLangID;
 DWORD dwSecurity;
 SECURITY_QUALITY_OF_SERVICE qos;
} CONVCONTEXT,*PCONVCONTEXT;
typedef struct tagCONVINFO {
 DWORD cb;
 DWORD hUser;
 HCONV hConvPartner;
 HSZ hszSvcPartner;
 HSZ hszServiceReq;
 HSZ hszTopic;
 HSZ hszItem;
 UINT wFmt;
 UINT wType;
 UINT wStatus;
 UINT wConvst;
 UINT wLastError;
 HCONVLIST hConvList;
 CONVCONTEXT ConvCtxt;
 HWND hwnd;
 HWND hwndPartner;
} CONVINFO,*PCONVINFO;
typedef struct tagDDEML_MSG_HOOK_DATA {
 UINT uiLo;
 UINT uiHi;
 DWORD cbData;
 DWORD Data[8];
} DDEML_MSG_HOOK_DATA;
typedef struct tagMONHSZSTRUCT {
 UINT cb;
 BOOL fsAction;
 DWORD dwTime;
 HSZ hsz;
 HANDLE hTask;
 TCHAR str[1];
} MONHSZSTRUCT, *PMONHSZSTRUCT;
typedef struct tagMONLINKSTRUCT {
 UINT cb;
 DWORD dwTime;
 HANDLE hTask;
 BOOL fEstablished;
 BOOL fNoData;
 HSZ hszSvc;
 HSZ hszTopic;
 HSZ hszItem;
 UINT wFmt;
 BOOL fServer;
 HCONV hConvServer;
 HCONV hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;
typedef struct tagMONCONVSTRUCT {
 UINT cb;
 BOOL fConnect;
 DWORD dwTime;
 HANDLE hTask;
 HSZ hszSvc;
 HSZ hszTopic;
 HCONV hConvClient;
 HCONV hConvServer;
} MONCONVSTRUCT, *PMONCONVSTRUCT;
typedef struct tagMONCBSTRUCT {
 UINT cb;
 DWORD dwTime;
 HANDLE hTask;
 DWORD dwRet;
 UINT wType;
 UINT wFmt;
 HCONV hConv;
 HSZ hsz1;
 HSZ hsz2;
 HDDEDATA hData;
 ULONG_PTR dwData1;
 ULONG_PTR dwData2;
 CONVCONTEXT cc;
 DWORD cbData;
 DWORD Data[8];
} MONCBSTRUCT, *PMONCBSTRUCT;
typedef struct tagMONERRSTRUCT {
 UINT cb;
 UINT wLastError;
 DWORD dwTime;
 HANDLE hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;
typedef struct tagMONMSGSTRUCT {
 UINT cb;
 HWND hwndTo;
 DWORD dwTime;
 HANDLE hTask;
 UINT wMsg;
 WPARAM wParam;
 LPARAM lParam;
 DDEML_MSG_HOOK_DATA dmhd;
} MONMSGSTRUCT, *PMONMSGSTRUCT;

BOOL __attribute__((__stdcall__)) DdeAbandonTransaction(DWORD,HCONV,DWORD);
PBYTE __attribute__((__stdcall__)) DdeAccessData(HDDEDATA,PDWORD);
HDDEDATA __attribute__((__stdcall__)) DdeAddData(HDDEDATA,PBYTE,DWORD,DWORD);
HDDEDATA __attribute__((__stdcall__)) DdeClientTransaction(PBYTE,DWORD,HCONV,HSZ,UINT,UINT,DWORD,PDWORD);
int __attribute__((__stdcall__)) DdeCmpStringHandles(HSZ,HSZ);
HCONV __attribute__((__stdcall__)) DdeConnect(DWORD,HSZ,HSZ,PCONVCONTEXT);
HCONVLIST __attribute__((__stdcall__)) DdeConnectList(DWORD,HSZ,HSZ,HCONVLIST,PCONVCONTEXT);
HDDEDATA __attribute__((__stdcall__)) DdeCreateDataHandle(DWORD,PBYTE,DWORD,DWORD,HSZ,UINT,UINT);
HSZ __attribute__((__stdcall__)) DdeCreateStringHandleA(DWORD,LPCSTR,int);
HSZ __attribute__((__stdcall__)) DdeCreateStringHandleW(DWORD,LPCWSTR,int);
BOOL __attribute__((__stdcall__)) DdeDisconnect(HCONV);
BOOL __attribute__((__stdcall__)) DdeDisconnectList(HCONVLIST);
BOOL __attribute__((__stdcall__)) DdeEnableCallback(DWORD,HCONV,UINT);
BOOL __attribute__((__stdcall__)) DdeFreeDataHandle(HDDEDATA);
BOOL __attribute__((__stdcall__)) DdeFreeStringHandle(DWORD,HSZ);
DWORD __attribute__((__stdcall__)) DdeGetData(HDDEDATA,PBYTE,DWORD,DWORD);
UINT __attribute__((__stdcall__)) DdeGetLastError(DWORD);
BOOL __attribute__((__stdcall__)) DdeImpersonateClient(HCONV);
UINT __attribute__((__stdcall__)) DdeInitializeA(PDWORD,PFNCALLBACK,DWORD,DWORD);
UINT __attribute__((__stdcall__)) DdeInitializeW(PDWORD,PFNCALLBACK,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) DdeKeepStringHandle(DWORD,HSZ);
HDDEDATA __attribute__((__stdcall__)) DdeNameService(DWORD,HSZ,HSZ,UINT);
BOOL __attribute__((__stdcall__)) DdePostAdvise(DWORD,HSZ,HSZ);
UINT __attribute__((__stdcall__)) DdeQueryConvInfo(HCONV,DWORD,PCONVINFO);
HCONV __attribute__((__stdcall__)) DdeQueryNextServer(HCONVLIST,HCONV);
DWORD __attribute__((__stdcall__)) DdeQueryStringA(DWORD,HSZ,LPSTR,DWORD,int);
DWORD __attribute__((__stdcall__)) DdeQueryStringW(DWORD,HSZ,LPWSTR,DWORD,int);
HCONV __attribute__((__stdcall__)) DdeReconnect(HCONV);
BOOL __attribute__((__stdcall__)) DdeSetUserHandle(HCONV,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) DdeUnaccessData(HDDEDATA);
BOOL __attribute__((__stdcall__)) DdeUninitialize(DWORD);
# 312 "C:/upp/mingw/include/ddeml.h" 3
}
# 77 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/dlgs.h" 1 3



       
# 5 "C:/upp/mingw/include/dlgs.h" 3



extern "C" {
# 176 "C:/upp/mingw/include/dlgs.h" 3
typedef struct tagCRGB {
 BYTE bRed;
 BYTE bGreen;
 BYTE bBlue;
 BYTE bExtra;
} CRGB;


}
# 78 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/imm.h" 1 3



       
# 5 "C:/upp/mingw/include/imm.h" 3



extern "C" {
# 249 "C:/upp/mingw/include/imm.h" 3
typedef DWORD HIMC;
typedef DWORD HIMCC;
typedef HKL *LPHKL;
typedef struct tagCOMPOSITIONFORM {
 DWORD dwStyle;
 POINT ptCurrentPos;
 RECT rcArea;
} COMPOSITIONFORM,*PCOMPOSITIONFORM,*LPCOMPOSITIONFORM;
typedef struct tagCANDIDATEFORM {
 DWORD dwIndex;
 DWORD dwStyle;
 POINT ptCurrentPos;
 RECT rcArea;
} CANDIDATEFORM,*PCANDIDATEFORM,*LPCANDIDATEFORM;
typedef struct tagCANDIDATELIST {
 DWORD dwSize;
 DWORD dwStyle;
 DWORD dwCount;
 DWORD dwSelection;
 DWORD dwPageStart;
 DWORD dwPageSize;
 DWORD dwOffset[1];
} CANDIDATELIST,*PCANDIDATELIST,*LPCANDIDATELIST;
typedef struct tagIMECHARPOSITION {
  DWORD dwSize;
  DWORD dwCharPos;
  POINT pt;
  UINT cLineHeight;
  RECT rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION;
typedef struct tagRECONVERTSTRING {
  DWORD dwSize;
  DWORD dwVersion;
  DWORD dwStrLen;
  DWORD dwStrOffset;
  DWORD dwCompStrLen;
  DWORD dwCompStrOffset;
  DWORD dwTargetStrLen;
  DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING;
typedef struct tagREGISTERWORDA {
 LPSTR lpReading;
 LPSTR lpWord;
} REGISTERWORDA,*PREGISTERWORDA,*LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
 LPWSTR lpReading;
 LPWSTR lpWord;
} REGISTERWORDW,*PREGISTERWORDW,*LPREGISTERWORDW;
typedef struct tagSTYLEBUFA {
 DWORD dwStyle;
 CHAR szDescription[32];
} STYLEBUFA,*PSTYLEBUFA,*LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
 DWORD dwStyle;
 WCHAR szDescription[32];
} STYLEBUFW,*PSTYLEBUFW,*LPSTYLEBUFW;
typedef struct tagIMEMENUITEMINFOA {
 UINT cbSize;
 UINT fType;
 UINT fState;
 UINT wID;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 CHAR szString[80];
 HBITMAP hbmpItem;
} IMEMENUITEMINFOA,*PIMEMENUITEMINFOA,*LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
 UINT cbSize;
 UINT fType;
 UINT fState;
 UINT wID;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 WCHAR szString[80];
 HBITMAP hbmpItem;
} IMEMENUITEMINFOW,*PIMEMENUITEMINFOW,*LPIMEMENUITEMINFOW;
typedef int (__attribute__((__stdcall__)) *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (__attribute__((__stdcall__)) *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);







typedef REGISTERWORDA REGISTERWORD,*PREGISTERWORD,*LPREGISTERWORD;
typedef STYLEBUFA STYLEBUF,*PSTYLEBUF,*LPSTYLEBUF;
typedef IMEMENUITEMINFOA IMEMENUITEMINFO,*PIMEMENUITEMINFO,*LPIMEMENUITEMINFO;

HKL __attribute__((__stdcall__)) ImmInstallIMEA(LPCSTR,LPCSTR);
HKL __attribute__((__stdcall__)) ImmInstallIMEW(LPCWSTR,LPCWSTR);
HWND __attribute__((__stdcall__)) ImmGetDefaultIMEWnd(HWND);
UINT __attribute__((__stdcall__)) ImmGetDescriptionA(HKL,LPSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetDescriptionW(HKL,LPWSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetIMEFileNameA(HKL,LPSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetIMEFileNameW(HKL,LPWSTR,UINT);
DWORD __attribute__((__stdcall__)) ImmGetProperty(HKL,DWORD);
BOOL __attribute__((__stdcall__)) ImmIsIME(HKL);
BOOL __attribute__((__stdcall__)) ImmSimulateHotKey(HWND,DWORD);
HIMC __attribute__((__stdcall__)) ImmCreateContext(void);
BOOL __attribute__((__stdcall__)) ImmDestroyContext(HIMC);
HIMC __attribute__((__stdcall__)) ImmGetContext(HWND);
BOOL __attribute__((__stdcall__)) ImmReleaseContext(HWND,HIMC);
HIMC __attribute__((__stdcall__)) ImmAssociateContext(HWND,HIMC);
LONG __attribute__((__stdcall__)) ImmGetCompositionStringA(HIMC,DWORD,PVOID,DWORD);
LONG __attribute__((__stdcall__)) ImmGetCompositionStringW(HIMC,DWORD,PVOID,DWORD);
BOOL __attribute__((__stdcall__)) ImmSetCompositionStringA(HIMC,DWORD,PCVOID,DWORD,PCVOID,DWORD);
BOOL __attribute__((__stdcall__)) ImmSetCompositionStringW(HIMC,DWORD,PCVOID,DWORD,PCVOID,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListCountA(HIMC,PDWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListCountW(HIMC,PDWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListA(HIMC,DWORD,PCANDIDATELIST,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListW(HIMC,DWORD,PCANDIDATELIST,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetGuideLineA(HIMC,DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetGuideLineW(HIMC,DWORD,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetConversionStatus(HIMC,LPDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ImmSetConversionStatus(HIMC,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetOpenStatus(HIMC);
BOOL __attribute__((__stdcall__)) ImmSetOpenStatus(HIMC,BOOL);

BOOL __attribute__((__stdcall__)) ImmGetCompositionFontA(HIMC,LPLOGFONTA);
BOOL __attribute__((__stdcall__)) ImmGetCompositionFontW(HIMC,LPLOGFONTW);
BOOL __attribute__((__stdcall__)) ImmSetCompositionFontA(HIMC,LPLOGFONTA);
BOOL __attribute__((__stdcall__)) ImmSetCompositionFontW(HIMC,LPLOGFONTW);

BOOL __attribute__((__stdcall__)) ImmConfigureIMEA(HKL,HWND,DWORD,PVOID);
BOOL __attribute__((__stdcall__)) ImmConfigureIMEW(HKL,HWND,DWORD,PVOID);
LRESULT __attribute__((__stdcall__)) ImmEscapeA(HKL,HIMC,UINT,PVOID);
LRESULT __attribute__((__stdcall__)) ImmEscapeW(HKL,HIMC,UINT,PVOID);
DWORD __attribute__((__stdcall__)) ImmGetConversionListA(HKL,HIMC,LPCSTR,PCANDIDATELIST,DWORD,UINT);
DWORD __attribute__((__stdcall__)) ImmGetConversionListW(HKL,HIMC,LPCWSTR,PCANDIDATELIST,DWORD,UINT);
BOOL __attribute__((__stdcall__)) ImmNotifyIME(HIMC,DWORD,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetStatusWindowPos(HIMC,LPPOINT);
BOOL __attribute__((__stdcall__)) ImmSetStatusWindowPos(HIMC,LPPOINT);
BOOL __attribute__((__stdcall__)) ImmGetCompositionWindow(HIMC,PCOMPOSITIONFORM);
BOOL __attribute__((__stdcall__)) ImmSetCompositionWindow(HIMC,PCOMPOSITIONFORM);
BOOL __attribute__((__stdcall__)) ImmGetCandidateWindow(HIMC,DWORD,PCANDIDATEFORM);
BOOL __attribute__((__stdcall__)) ImmSetCandidateWindow(HIMC,PCANDIDATEFORM);
BOOL __attribute__((__stdcall__)) ImmIsUIMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL __attribute__((__stdcall__)) ImmIsUIMessageW(HWND,UINT,WPARAM,LPARAM);
UINT __attribute__((__stdcall__)) ImmGetVirtualKey(HWND);
BOOL __attribute__((__stdcall__)) ImmRegisterWordA(HKL,LPCSTR,DWORD,LPCSTR);
BOOL __attribute__((__stdcall__)) ImmRegisterWordW(HKL,LPCWSTR,DWORD,LPCWSTR);
BOOL __attribute__((__stdcall__)) ImmUnregisterWordA(HKL,LPCSTR,DWORD,LPCSTR);
BOOL __attribute__((__stdcall__)) ImmUnregisterWordW(HKL,LPCWSTR,DWORD,LPCWSTR);
UINT __attribute__((__stdcall__)) ImmGetRegisterWordStyleA(HKL,UINT,PSTYLEBUFA);
UINT __attribute__((__stdcall__)) ImmGetRegisterWordStyleW(HKL,UINT,PSTYLEBUFW);
UINT __attribute__((__stdcall__)) ImmEnumRegisterWordA(HKL,REGISTERWORDENUMPROCA,LPCSTR,DWORD,LPCSTR,PVOID);
UINT __attribute__((__stdcall__)) ImmEnumRegisterWordW(HKL,REGISTERWORDENUMPROCW,LPCWSTR,DWORD,LPCWSTR,PVOID);
BOOL __attribute__((__stdcall__)) EnableEUDC(BOOL);
BOOL __attribute__((__stdcall__)) ImmDisableIME(DWORD);
DWORD __attribute__((__stdcall__)) ImmGetImeMenuItemsA(HIMC,DWORD,DWORD,LPIMEMENUITEMINFOA,LPIMEMENUITEMINFOA,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetImeMenuItemsW(HIMC,DWORD,DWORD,LPIMEMENUITEMINFOW,LPIMEMENUITEMINFOW,DWORD);
# 450 "C:/upp/mingw/include/imm.h" 3
}
# 79 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/lzexpand.h" 1 3



       
# 5 "C:/upp/mingw/include/lzexpand.h" 3



extern "C" {
# 18 "C:/upp/mingw/include/lzexpand.h" 3
LONG __attribute__((__stdcall__)) CopyLZFile(INT,INT);
INT __attribute__((__stdcall__)) GetExpandedNameA(LPSTR,LPSTR);
INT __attribute__((__stdcall__)) GetExpandedNameW(LPWSTR,LPWSTR);
void __attribute__((__stdcall__)) LZClose(INT);
LONG __attribute__((__stdcall__)) LZCopy(INT,INT);
void __attribute__((__stdcall__)) LZDone(void);
INT __attribute__((__stdcall__)) LZInit(INT);
INT __attribute__((__stdcall__)) LZOpenFileA(LPSTR,LPOFSTRUCT,WORD);
INT __attribute__((__stdcall__)) LZOpenFileW(LPWSTR,LPOFSTRUCT,WORD);
INT __attribute__((__stdcall__)) LZRead(INT,LPSTR,INT);
LONG __attribute__((__stdcall__)) LZSeek(INT,LONG,INT);
INT __attribute__((__stdcall__)) LZStart(void);
# 38 "C:/upp/mingw/include/lzexpand.h" 3
}
# 80 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/mmsystem.h" 1 3




       
# 6 "C:/upp/mingw/include/mmsystem.h" 3

#pragma pack(push,1)

extern "C" {
# 905 "C:/upp/mingw/include/mmsystem.h" 3
typedef DWORD MCIERROR;
typedef UINT MCIDEVICEID;
typedef UINT(__attribute__((__stdcall__)) *YIELDPROC)(MCIDEVICEID,DWORD);
typedef UINT MMVERSION;
typedef UINT MMRESULT;
typedef struct mmtime_tag {
 UINT wType;
 union {
  DWORD ms;
  DWORD sample;
  DWORD cb;
  DWORD ticks;
  struct {
   BYTE hour;
   BYTE min;
   BYTE sec;
   BYTE frame;
   BYTE fps;
   BYTE dummy;
   BYTE pad[2];
  } smpte;
  struct {
   DWORD songptrpos;
  } midi;
 } u;
} MMTIME,*PMMTIME,*LPMMTIME;
typedef struct HDRVR__{int i;}*HDRVR;
typedef struct tagDRVCONFIGINFO {
 DWORD dwDCISize;
 LPCWSTR lpszDCISectionName;
 LPCWSTR lpszDCIAliasName;
} DRVCONFIGINFO,*PDRVCONFIGINFO,*LPDRVCONFIGINFO;
typedef struct DRVCONFIGINFOEX {
 DWORD dwDCISize;
 LPCWSTR lpszDCISectionName;
 LPCWSTR lpszDCIAliasName;
 DWORD dnDevNode;
} DRVCONFIGINFOEX,*PDRVCONFIGINFOEX,*LPDRVCONFIGINFOEX;
typedef LRESULT(__attribute__((__stdcall__))* DRIVERPROC)(DWORD,HDRVR,UINT,LPARAM,LPARAM);
typedef void (__attribute__((__stdcall__)) DRVCALLBACK)(HDRVR,UINT,DWORD,DWORD,DWORD);
typedef DRVCALLBACK *LPDRVCALLBACK;
typedef DRVCALLBACK *PDRVCALLBACK;
typedef struct HWAVE__{int i;}*HWAVE;
typedef struct HWAVEIN__{int i;}*HWAVEIN;
typedef struct HWAVEOUT__{int i;}*HWAVEOUT;
typedef HWAVEIN *LPHWAVEIN;
typedef HWAVEOUT *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK *LPWAVECALLBACK;
typedef struct wavehdr_tag {
 LPSTR lpData;
 DWORD dwBufferLength;
 DWORD dwBytesRecorded;
 DWORD dwUser;
 DWORD dwFlags;
 DWORD dwLoops;
 struct wavehdr_tag *lpNext;
 DWORD reserved;
} WAVEHDR,*PWAVEHDR,*LPWAVEHDR;
typedef struct tagWAVEOUTCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
 DWORD dwSupport;
} WAVEOUTCAPSA,*PWAVEOUTCAPSA,*LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
 DWORD dwSupport;
} WAVEOUTCAPSW,*PWAVEOUTCAPSW,*LPWAVEOUTCAPSW;
typedef struct tagWAVEINCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
} WAVEINCAPSA,*PWAVEINCAPSA,*LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
} WAVEINCAPSW,*PWAVEINCAPSW,*LPWAVEINCAPSW;
typedef struct waveformat_tag {
 WORD wFormatTag;
 WORD nChannels;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
} WAVEFORMAT,*PWAVEFORMAT,*LPWAVEFORMAT;
typedef struct pcmwaveformat_tag {
 WAVEFORMAT wf;
 WORD wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT,*LPPCMWAVEFORMAT;



typedef struct tWAVEFORMATEX {
 WORD wFormatTag;
 WORD nChannels;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
 WORD wBitsPerSample;
 WORD cbSize;
} WAVEFORMATEX,*PWAVEFORMATEX,*LPWAVEFORMATEX;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

typedef struct HMIDI__{int i;}*HMIDI;
typedef struct HMIDIIN__{int i;}*HMIDIIN;
typedef struct HMIDIOUT__{int i;}*HMIDIOUT;
typedef struct HMIDISTRM__{int i;}*HMIDISTRM;
typedef HMIDI *LPHMIDI;
typedef HMIDIIN *LPHMIDIIN;
typedef HMIDIOUT *LPHMIDIOUT;
typedef HMIDISTRM *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK *LPMIDICALLBACK;
typedef WORD PATCHARRAY[128];
typedef WORD *LPPATCHARRAY;
typedef WORD KEYARRAY[128];
typedef WORD *LPKEYARRAY;
typedef struct tagMIDIOUTCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 WORD wTechnology;
 WORD wVoices;
 WORD wNotes;
 WORD wChannelMask;
 DWORD dwSupport;
} MIDIOUTCAPSA,*PMIDIOUTCAPSA,*LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 WORD wTechnology;
 WORD wVoices;
 WORD wNotes;
 WORD wChannelMask;
 DWORD dwSupport;
} MIDIOUTCAPSW,*PMIDIOUTCAPSW,*LPMIDIOUTCAPSW;
typedef struct tagMIDIINCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwSupport;
} MIDIINCAPSA,*PMIDIINCAPSA,*LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwSupport;
} MIDIINCAPSW,*PMIDIINCAPSW,*NPMIDIINCAPSW,*LPMIDIINCAPSW;
typedef struct midihdr_tag {
 LPSTR lpData;
 DWORD dwBufferLength;
 DWORD dwBytesRecorded;
 DWORD dwUser;
 DWORD dwFlags;
 struct midihdr_tag *lpNext;
 DWORD reserved;
 DWORD dwOffset;
 DWORD dwReserved[8];
} MIDIHDR,*PMIDIHDR,*LPMIDIHDR;
typedef struct midievent_tag {
 DWORD dwDeltaTime;
 DWORD dwStreamID;
 DWORD dwEvent;
 DWORD dwParms[1];
} MIDIEVENT;
typedef struct midistrmbuffver_tag {
 DWORD dwVersion;
 DWORD dwMid;
 DWORD dwOEMVersion;
} MIDISTRMBUFFVER;
typedef struct midiproptimediv_tag {
 DWORD cbStruct;
 DWORD dwTimeDiv;
} MIDIPROPTIMEDIV,*LPMIDIPROPTIMEDIV;
typedef struct midiproptempo_tag {
 DWORD cbStruct;
 DWORD dwTempo;
} MIDIPROPTEMPO,*LPMIDIPROPTEMPO;
typedef struct tagAUXCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 WORD wTechnology;
 WORD wReserved1;
 DWORD dwSupport;
} AUXCAPSA,*PAUXCAPSA,*LPAUXCAPSA;
typedef struct tagAUXCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 WORD wTechnology;
 WORD wReserved1;
 DWORD dwSupport;
} AUXCAPSW,*PAUXCAPSW,*LPAUXCAPSW;
typedef struct HMIXEROBJ__{int i;}*HMIXEROBJ;
typedef HMIXEROBJ *LPHMIXEROBJ;
typedef struct HMIXER__{int i;}*HMIXER;
typedef HMIXER *LPHMIXER;
typedef struct tagMIXERCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD fdwSupport;
 DWORD cDestinations;
} MIXERCAPSA,*PMIXERCAPSA,*LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD fdwSupport;
 DWORD cDestinations;
} MIXERCAPSW,*PMIXERCAPSW,*LPMIXERCAPSW;
typedef struct tagMIXERLINEA {
 DWORD cbStruct;
 DWORD dwDestination;
 DWORD dwSource;
 DWORD dwLineID;
 DWORD fdwLine;
 DWORD dwUser;
 DWORD dwComponentType;
 DWORD cChannels;
 DWORD cConnections;
 DWORD cControls;
 CHAR szShortName[16];
 CHAR szName[64];
 struct {
  DWORD dwType;
  DWORD dwDeviceID;
  WORD wMid;
  WORD wPid;
  MMVERSION vDriverVersion;
  CHAR szPname[32];
 } Target;
} MIXERLINEA,*PMIXERLINEA,*LPMIXERLINEA;
typedef struct tagMIXERLINEW {
 DWORD cbStruct;
 DWORD dwDestination;
 DWORD dwSource;
 DWORD dwLineID;
 DWORD fdwLine;
 DWORD dwUser;
 DWORD dwComponentType;
 DWORD cChannels;
 DWORD cConnections;
 DWORD cControls;
 WCHAR szShortName[16];
 WCHAR szName[64];
 struct {
  DWORD dwType;
  DWORD dwDeviceID;
  WORD wMid;
  WORD wPid;
  MMVERSION vDriverVersion;
  WCHAR szPname[32];
 } Target;
} MIXERLINEW,*PMIXERLINEW,*LPMIXERLINEW;
typedef struct tagMIXERCONTROLA {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD dwControlType;
 DWORD fdwControl;
 DWORD cMultipleItems;
 CHAR szShortName[16];
 CHAR szName[64];
 union {
  __extension__ struct {
   LONG lMinimum;
   LONG lMaximum;
  };
  __extension__ struct {
   DWORD dwMinimum;
   DWORD dwMaximum;
  };
  DWORD dwReserved[6];
 } Bounds;
 union {
  DWORD cSteps;
  DWORD cbCustomData;
  DWORD dwReserved[6];
 } Metrics;
} MIXERCONTROLA,*PMIXERCONTROLA,*LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD dwControlType;
 DWORD fdwControl;
 DWORD cMultipleItems;
 WCHAR szShortName[16];
 WCHAR szName[64];
 union {
  __extension__ struct {
   LONG lMinimum;
   LONG lMaximum;
  };
  __extension__ struct {
   DWORD dwMinimum;
   DWORD dwMaximum;
  };
  DWORD dwReserved[6];
 } Bounds;
 union {
  DWORD cSteps;
  DWORD cbCustomData;
  DWORD dwReserved[6];
 } Metrics;
} MIXERCONTROLW,*PMIXERCONTROLW,*LPMIXERCONTROLW;
typedef struct tagMIXERLINECONTROLSA {
 DWORD cbStruct;
 DWORD dwLineID;
 __extension__ union {
  DWORD dwControlID;
  DWORD dwControlType;
 } ;
 DWORD cControls;
 DWORD cbmxctrl;
 LPMIXERCONTROLA pamxctrl;
} MIXERLINECONTROLSA,*PMIXERLINECONTROLSA,*LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
 DWORD cbStruct;
 DWORD dwLineID;
 __extension__ union {
  DWORD dwControlID;
  DWORD dwControlType;
 } ;
 DWORD cControls;
 DWORD cbmxctrl;
 LPMIXERCONTROLW pamxctrl;
} MIXERLINECONTROLSW,*PMIXERLINECONTROLSW,*LPMIXERLINECONTROLSW;
typedef struct tMIXERCONTROLDETAILS {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD cChannels;
 __extension__ union {
  HWND hwndOwner;
  DWORD cMultipleItems;
 } ;
 DWORD cbDetails;
 PVOID paDetails;
} MIXERCONTROLDETAILS,*PMIXERCONTROLDETAILS,*LPMIXERCONTROLDETAILS;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
 DWORD dwParam1;
 DWORD dwParam2;
 CHAR szName[64];
} MIXERCONTROLDETAILS_LISTTEXTA,*PMIXERCONTROLDETAILS_LISTTEXTA,*LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
 DWORD dwParam1;
 DWORD dwParam2;
 WCHAR szName[64];
} MIXERCONTROLDETAILS_LISTTEXTW,*PMIXERCONTROLDETAILS_LISTTEXTW,*LPMIXERCONTROLDETAILS_LISTTEXTW;
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
 LONG fValue;
} MIXERCONTROLDETAILS_BOOLEAN,*PMIXERCONTROLDETAILS_BOOLEAN,*LPMIXERCONTROLDETAILS_BOOLEAN;
typedef struct tMIXERCONTROLDETAILS_SIGNED {
 LONG lValue;
} MIXERCONTROLDETAILS_SIGNED,*PMIXERCONTROLDETAILS_SIGNED,*LPMIXERCONTROLDETAILS_SIGNED;
typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
 DWORD dwValue;
} MIXERCONTROLDETAILS_UNSIGNED,*PMIXERCONTROLDETAILS_UNSIGNED,*LPMIXERCONTROLDETAILS_UNSIGNED;
typedef void(__attribute__((__stdcall__)) TIMECALLBACK)(UINT,UINT,DWORD,DWORD,DWORD);
typedef TIMECALLBACK *LPTIMECALLBACK;
typedef struct timecaps_tag {
 UINT wPeriodMin;
 UINT wPeriodMax;
} TIMECAPS,*PTIMECAPS,*LPTIMECAPS;
typedef struct tagJOYCAPSA {
 WORD wMid;
 WORD wPid;
 CHAR szPname[32];
 UINT wXmin;
 UINT wXmax;
 UINT wYmin;
 UINT wYmax;
 UINT wZmin;
 UINT wZmax;
 UINT wNumButtons;
 UINT wPeriodMin;
 UINT wPeriodMax;
 UINT wRmin;
 UINT wRmax;
 UINT wUmin;
 UINT wUmax;
 UINT wVmin;
 UINT wVmax;
 UINT wCaps;
 UINT wMaxAxes;
 UINT wNumAxes;
 UINT wMaxButtons;
 CHAR szRegKey[32];
 CHAR szOEMVxD[260];
} JOYCAPSA,*PJOYCAPSA,*LPJOYCAPSA;
typedef struct tagJOYCAPSW {
 WORD wMid;
 WORD wPid;
 WCHAR szPname[32];
 UINT wXmin;
 UINT wXmax;
 UINT wYmin;
 UINT wYmax;
 UINT wZmin;
 UINT wZmax;
 UINT wNumButtons;
 UINT wPeriodMin;
 UINT wPeriodMax;
 UINT wRmin;
 UINT wRmax;
 UINT wUmin;
 UINT wUmax;
 UINT wVmin;
 UINT wVmax;
 UINT wCaps;
 UINT wMaxAxes;
 UINT wNumAxes;
 UINT wMaxButtons;
 WCHAR szRegKey[32];
 WCHAR szOEMVxD[260];
} JOYCAPSW,*PJOYCAPSW,*LPJOYCAPSW;
typedef struct joyinfo_tag {
 UINT wXpos;
 UINT wYpos;
 UINT wZpos;
 UINT wButtons;
} JOYINFO,*PJOYINFO,*LPJOYINFO;
typedef struct joyinfoex_tag {
 DWORD dwSize;
 DWORD dwFlags;
 DWORD dwXpos;
 DWORD dwYpos;
 DWORD dwZpos;
 DWORD dwRpos;
 DWORD dwUpos;
 DWORD dwVpos;
 DWORD dwButtons;
 DWORD dwButtonNumber;
 DWORD dwPOV;
 DWORD dwReserved1;
 DWORD dwReserved2;
} JOYINFOEX,*PJOYINFOEX,*LPJOYINFOEX;
typedef DWORD FOURCC;
typedef char *HPSTR;
typedef struct HMMIO__{int i;}*HMMIO;
typedef LRESULT (__attribute__((__stdcall__)) MMIOPROC)(LPSTR,UINT,LPARAM,LPARAM);
typedef MMIOPROC *LPMMIOPROC;
typedef struct _MMIOINFO {
 DWORD dwFlags;
 FOURCC fccIOProc;
 LPMMIOPROC pIOProc;
 UINT wErrorRet;
 HTASK htask;
 LONG cchBuffer;
 HPSTR pchBuffer;
 HPSTR pchNext;
 HPSTR pchEndRead;
 HPSTR pchEndWrite;
 LONG lBufOffset;
 LONG lDiskOffset;
 DWORD adwInfo[3];
 DWORD dwReserved1;
 DWORD dwReserved2;
 HMMIO hmmio;
} MMIOINFO,*PMMIOINFO,*LPMMIOINFO;
typedef const MMIOINFO *LPCMMIOINFO;
typedef struct _MMCKINFO {
 FOURCC ckid;
 DWORD cksize;
 FOURCC fccType;
 DWORD dwDataOffset;
 DWORD dwFlags;
} MMCKINFO,*PMMCKINFO,*LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;
typedef struct tagMCI_GENERIC_PARMS {
 DWORD dwCallback;
} MCI_GENERIC_PARMS,*PMCI_GENERIC_PARMS,*LPMCI_GENERIC_PARMS;
typedef struct tagMCI_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
} MCI_OPEN_PARMSA,*PMCI_OPEN_PARMSA,*LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
} MCI_OPEN_PARMSW,*PMCI_OPEN_PARMSW,*LPMCI_OPEN_PARMSW;
typedef struct tagMCI_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_PLAY_PARMS,*PMCI_PLAY_PARMS,*LPMCI_PLAY_PARMS;
typedef struct tagMCI_SEEK_PARMS {
 DWORD dwCallback;
 DWORD dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS,*LPMCI_SEEK_PARMS;
typedef struct tagMCI_STATUS_PARMS {
 DWORD dwCallback;
 DWORD dwReturn;
 DWORD dwItem;
 DWORD dwTrack;
} MCI_STATUS_PARMS,*PMCI_STATUS_PARMS,*LPMCI_STATUS_PARMS;
typedef struct tagMCI_INFO_PARMSA {
 DWORD dwCallback;
 LPSTR lpstrReturn;
 DWORD dwRetSize;
} MCI_INFO_PARMSA,*LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
 DWORD dwCallback;
 LPWSTR lpstrReturn;
 DWORD dwRetSize;
} MCI_INFO_PARMSW,*LPMCI_INFO_PARMSW;
typedef struct tagMCI_GETDEVCAPS_PARMS {
 DWORD dwCallback;
 DWORD dwReturn;
 DWORD dwItem;
} MCI_GETDEVCAPS_PARMS,*PMCI_GETDEVCAPS_PARMS,*LPMCI_GETDEVCAPS_PARMS;
typedef struct tagMCI_SYSINFO_PARMSA {
 DWORD dwCallback;
 LPSTR lpstrReturn;
 DWORD dwRetSize;
 DWORD dwNumber;
 UINT wDeviceType;
} MCI_SYSINFO_PARMSA,*PMCI_SYSINFO_PARMSA,*LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
 DWORD dwCallback;
 LPWSTR lpstrReturn;
 DWORD dwRetSize;
 DWORD dwNumber;
 UINT wDeviceType;
} MCI_SYSINFO_PARMSW,*PMCI_SYSINFO_PARMSW,*LPMCI_SYSINFO_PARMSW;
typedef struct tagMCI_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
} MCI_SET_PARMS,*PMCI_SET_PARMS,*LPMCI_SET_PARMS;
typedef struct tagMCI_BREAK_PARMS {
 DWORD dwCallback;
 int nVirtKey;
 HWND hwndBreak;
} MCI_BREAK_PARMS,*PMCI_BREAK_PARMS,*LPMCI_BREAK_PARMS;
typedef struct tagMCI_SAVE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
} MCI_SAVE_PARMSA,*PMCI_SAVE_PARMSA,*LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
} MCI_SAVE_PARMSW,*PMCI_SAVE_PARMSW,*LPMCI_SAVE_PARMSW;
typedef struct tagMCI_LOAD_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
} MCI_LOAD_PARMSA,*PMCI_LOAD_PARMSA,*LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
} MCI_LOAD_PARMSW,*PMCI_LOAD_PARMSW,*LPMCI_LOAD_PARMSW;
typedef struct tagMCI_RECORD_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_RECORD_PARMS,*LPMCI_RECORD_PARMS;
typedef struct tagMCI_VD_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
 DWORD dwSpeed;
} MCI_VD_PLAY_PARMS,*PMCI_VD_PLAY_PARMS,*LPMCI_VD_PLAY_PARMS;
typedef struct tagMCI_VD_STEP_PARMS {
 DWORD dwCallback;
 DWORD dwFrames;
} MCI_VD_STEP_PARMS,*PMCI_VD_STEP_PARMS,*LPMCI_VD_STEP_PARMS;
typedef struct tagMCI_VD_ESCAPE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpstrCommand;
} MCI_VD_ESCAPE_PARMSA,*PMCI_VD_ESCAPE_PARMSA,*LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpstrCommand;
} MCI_VD_ESCAPE_PARMSW,*PMCI_VD_ESCAPE_PARMSW,*LPMCI_VD_ESCAPE_PARMSW;
typedef struct tagMCI_WAVE_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA,*PMCI_WAVE_OPEN_PARMSA,*LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW,*PMCI_WAVE_OPEN_PARMSW,*LPMCI_WAVE_OPEN_PARMSW;
typedef struct tagMCI_WAVE_DELETE_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS,*LPMCI_WAVE_DELETE_PARMS;
typedef struct tagMCI_WAVE_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
 UINT wInput;
 UINT wOutput;
 WORD wFormatTag;
 WORD wReserved2;
 WORD nChannels;
 WORD wReserved3;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
 WORD wReserved4;
 WORD wBitsPerSample;
 WORD wReserved5;
} MCI_WAVE_SET_PARMS,*PMCI_WAVE_SET_PARMS,*LPMCI_WAVE_SET_PARMS;

LRESULT __attribute__((__stdcall__)) CloseDriver(HDRVR,LONG,LONG);
HDRVR __attribute__((__stdcall__)) OpenDriver(LPCWSTR,LPCWSTR,LONG);
LRESULT __attribute__((__stdcall__)) SendDriverMessage(HDRVR,UINT,LONG,LONG);
HMODULE __attribute__((__stdcall__)) DrvGetModuleHandle(HDRVR);
HMODULE __attribute__((__stdcall__)) GetDriverModuleHandle(HDRVR);
LRESULT __attribute__((__stdcall__)) DefDriverProc(DWORD,HDRVR,UINT,LPARAM,LPARAM);
UINT __attribute__((__stdcall__)) mmsystemGetVersion(void);

BOOL __attribute__((__stdcall__)) sndPlaySoundA(LPCSTR,UINT);
BOOL __attribute__((__stdcall__)) sndPlaySoundW(LPCWSTR,UINT);
BOOL __attribute__((__stdcall__)) PlaySoundA(LPCSTR,HMODULE,DWORD);
BOOL __attribute__((__stdcall__)) PlaySoundW(LPCWSTR,HMODULE,DWORD);
UINT __attribute__((__stdcall__)) waveOutGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) waveOutGetDevCapsA(UINT,LPWAVEOUTCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetDevCapsW(UINT,LPWAVEOUTCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetVolume(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetVolume(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutOpen(LPHWAVEOUT,UINT,LPCWAVEFORMATEX,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutClose(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutPrepareHeader(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutUnprepareHeader(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutWrite(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutPause(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutRestart(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutReset(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutBreakLoop(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutGetPosition(HWAVEOUT,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetPitch(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetPitch(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetPlaybackRate(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetPlaybackRate(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetID(HWAVEOUT,LPUINT);
MMRESULT __attribute__((__stdcall__)) waveOutMessage(HWAVEOUT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) waveInGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) waveInGetDevCapsA(UINT,LPWAVEINCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetDevCapsW(UINT,LPWAVEINCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInOpen(LPHWAVEIN,UINT,LPCWAVEFORMATEX,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) waveInClose(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInPrepareHeader(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInUnprepareHeader(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInAddBuffer(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInStart(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInStop(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInReset(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInGetPosition(HWAVEIN,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetID(HWAVEIN,LPUINT);
MMRESULT __attribute__((__stdcall__)) waveInMessage(HWAVEIN,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) midiOutGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) midiStreamOpen(LPHMIDISTRM,LPUINT,DWORD,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiStreamClose(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamProperty(HMIDISTRM,LPBYTE,DWORD);
MMRESULT __attribute__((__stdcall__)) midiStreamPosition(HMIDISTRM,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) midiStreamOut(HMIDISTRM,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiStreamPause(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamRestart(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamStop(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiConnect(HMIDI,HMIDIOUT,PVOID);
MMRESULT __attribute__((__stdcall__)) midiDisconnect(HMIDI,HMIDIOUT,PVOID);
MMRESULT __attribute__((__stdcall__)) midiOutGetDevCapsA(UINT,LPMIDIOUTCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetDevCapsW(UINT,LPMIDIOUTCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetVolume(HMIDIOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) midiOutSetVolume(HMIDIOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutOpen(LPHMIDIOUT,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutClose(HMIDIOUT);
MMRESULT __attribute__((__stdcall__)) midiOutPrepareHeader(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutUnprepareHeader(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutShortMsg(HMIDIOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutLongMsg(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutReset(HMIDIOUT);
MMRESULT __attribute__((__stdcall__)) midiOutCachePatches(HMIDIOUT,UINT,LPWORD,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutCacheDrumPatches(HMIDIOUT,UINT,LPWORD,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetID(HMIDIOUT,LPUINT);
MMRESULT __attribute__((__stdcall__)) midiOutMessage(HMIDIOUT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) midiInGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) midiInGetDevCapsA(UINT,LPMIDIINCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetDevCapsW(UINT,LPMIDIINCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInOpen(LPHMIDIIN,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiInClose(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInPrepareHeader(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInUnprepareHeader(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInAddBuffer(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInStart(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInStop(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInReset(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInGetID(HMIDIIN,LPUINT);
MMRESULT __attribute__((__stdcall__)) midiInMessage(HMIDIIN,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) auxGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) auxGetDevCapsA(UINT,LPAUXCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) auxGetDevCapsW(UINT,LPAUXCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) auxSetVolume(UINT,DWORD);
MMRESULT __attribute__((__stdcall__)) auxGetVolume(UINT,PDWORD);
MMRESULT __attribute__((__stdcall__)) auxOutMessage(UINT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) mixerGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) mixerGetDevCapsA(UINT,LPMIXERCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) mixerGetDevCapsW(UINT,LPMIXERCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) mixerOpen(LPHMIXER,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerClose(HMIXER);
DWORD __attribute__((__stdcall__)) mixerMessage(HMIXER,UINT,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineInfoA(HMIXEROBJ,LPMIXERLINEA,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineInfoW(HMIXEROBJ,LPMIXERLINEW,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetID(HMIXEROBJ,PUINT,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineControlsA(HMIXEROBJ,LPMIXERLINECONTROLSA,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineControlsW(HMIXEROBJ,LPMIXERLINECONTROLSW,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetControlDetailsA(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetControlDetailsW(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerSetControlDetails(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) timeGetSystemTime(LPMMTIME,UINT);
DWORD __attribute__((__stdcall__)) timeGetTime(void);
MMRESULT __attribute__((__stdcall__)) timeSetEvent(UINT,UINT,LPTIMECALLBACK,DWORD,UINT);
MMRESULT __attribute__((__stdcall__)) timeKillEvent(UINT);
MMRESULT __attribute__((__stdcall__)) timeGetDevCaps(LPTIMECAPS,UINT);
MMRESULT __attribute__((__stdcall__)) timeBeginPeriod(UINT);
MMRESULT __attribute__((__stdcall__)) timeEndPeriod(UINT);
UINT __attribute__((__stdcall__)) joyGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) joyGetDevCapsA(UINT,LPJOYCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) joyGetDevCapsW(UINT,LPJOYCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) joyGetPos(UINT,LPJOYINFO);
MMRESULT __attribute__((__stdcall__)) joyGetPosEx(UINT,LPJOYINFOEX);
MMRESULT __attribute__((__stdcall__)) joyGetThreshold(UINT,LPUINT);
MMRESULT __attribute__((__stdcall__)) joyReleaseCapture(UINT);
MMRESULT __attribute__((__stdcall__)) joySetCapture(HWND,UINT,UINT,BOOL);
MMRESULT __attribute__((__stdcall__)) joySetThreshold(UINT,UINT);
FOURCC __attribute__((__stdcall__)) mmioStringToFOURCCA(LPCSTR,UINT);
FOURCC __attribute__((__stdcall__)) mmioStringToFOURCCW(LPCWSTR,UINT);
LPMMIOPROC __attribute__((__stdcall__)) mmioInstallIOProcA(FOURCC,LPMMIOPROC,DWORD);
LPMMIOPROC __attribute__((__stdcall__)) mmioInstallIOProcW(FOURCC,LPMMIOPROC,DWORD);
HMMIO __attribute__((__stdcall__)) mmioOpenA(LPSTR,LPMMIOINFO,DWORD);
HMMIO __attribute__((__stdcall__)) mmioOpenW(LPWSTR,LPMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioRenameA(LPCSTR,LPCSTR,LPCMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioRenameW(LPCWSTR,LPCWSTR,LPCMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioClose(HMMIO,UINT);
LONG __attribute__((__stdcall__)) mmioRead(HMMIO,HPSTR,LONG);
LONG __attribute__((__stdcall__)) mmioWrite(HMMIO,LPCSTR,LONG);
LONG __attribute__((__stdcall__)) mmioSeek(HMMIO,LONG,int);
MMRESULT __attribute__((__stdcall__)) mmioGetInfo(HMMIO,LPMMIOINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioSetInfo(HMMIO,LPCMMIOINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioSetBuffer(HMMIO,LPSTR,LONG,UINT);
MMRESULT __attribute__((__stdcall__)) mmioFlush(HMMIO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioAdvance(HMMIO,LPMMIOINFO,UINT);
LRESULT __attribute__((__stdcall__)) mmioSendMessage(HMMIO,UINT,LPARAM,LPARAM);
MMRESULT __attribute__((__stdcall__)) mmioDescend(HMMIO,LPMMCKINFO,const MMCKINFO*,UINT);
MMRESULT __attribute__((__stdcall__)) mmioAscend(HMMIO,LPMMCKINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioCreateChunk(HMMIO,LPMMCKINFO,UINT);
MCIERROR __attribute__((__stdcall__)) mciSendCommandA(MCIDEVICEID,UINT,DWORD,DWORD);
MCIERROR __attribute__((__stdcall__)) mciSendCommandW(MCIDEVICEID,UINT,DWORD,DWORD);
MCIERROR __attribute__((__stdcall__)) mciSendStringA(LPCSTR,LPSTR,UINT,HWND);
MCIERROR __attribute__((__stdcall__)) mciSendStringW(LPCWSTR,LPWSTR,UINT,HWND);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDA(LPCSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDW(LPCWSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDFromElementIDA(DWORD,LPCSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDFromElementIDW(DWORD,LPCWSTR);
BOOL __attribute__((__stdcall__)) mciGetErrorStringA(MCIERROR,LPSTR,UINT);
BOOL __attribute__((__stdcall__)) mciGetErrorStringW(MCIERROR,LPWSTR,UINT);
BOOL __attribute__((__stdcall__)) mciSetYieldProc(MCIDEVICEID,YIELDPROC,DWORD);
HTASK __attribute__((__stdcall__)) mciGetCreatorTask(MCIDEVICEID);
YIELDPROC __attribute__((__stdcall__)) mciGetYieldProc(MCIDEVICEID,PDWORD);

typedef struct tagMCI_SEQ_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
 DWORD dwTempo;
 DWORD dwPort;
 DWORD dwSlave;
 DWORD dwMaster;
 DWORD dwOffset;
} MCI_SEQ_SET_PARMS,*PMCI_SEQ_SET_PARMS,*LPMCI_SEQ_SET_PARMS;
typedef struct tagMCI_ANIM_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_ANIM_OPEN_PARMSA,*PMCI_ANIM_OPEN_PARMSA,*LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_ANIM_OPEN_PARMSW,*PMCI_ANIM_OPEN_PARMSW,*LPMCI_ANIM_OPEN_PARMSW;
typedef struct tagMCI_ANIM_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
 DWORD dwSpeed;
} MCI_ANIM_PLAY_PARMS,*PMCI_ANIM_PLAY_PARMS,*LPMCI_ANIM_PLAY_PARMS;
typedef struct tagMCI_ANIM_STEP_PARMS {
 DWORD dwCallback;
 DWORD dwFrames;
} MCI_ANIM_STEP_PARMS,*PMCI_ANIM_STEP_PARMS,*LPMCI_ANIM_STEP_PARMS;
typedef struct tagMCI_ANIM_WINDOW_PARMSA {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCSTR lpstrText;
} MCI_ANIM_WINDOW_PARMSA,*PMCI_ANIM_WINDOW_PARMSA,*LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCWSTR lpstrText;
} MCI_ANIM_WINDOW_PARMSW,*PMCI_ANIM_WINDOW_PARMSW,*LPMCI_ANIM_WINDOW_PARMSW;
typedef struct tagMCI_ANIM_RECT_PARMS {
 DWORD dwCallback;




 RECT rc;

} MCI_ANIM_RECT_PARMS,*PMCI_ANIM_RECT_PARMS,*LPMCI_ANIM_RECT_PARMS;
typedef struct tagMCI_ANIM_UPDATE_PARMS {
 DWORD dwCallback;
 RECT rc;
 HDC hDC;
} MCI_ANIM_UPDATE_PARMS,*PMCI_ANIM_UPDATE_PARMS,*LPMCI_ANIM_UPDATE_PARMS;
typedef struct tagMCI_OVLY_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_OVLY_OPEN_PARMSA,*PMCI_OVLY_OPEN_PARMSA,*LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_OVLY_OPEN_PARMSW,*PMCI_OVLY_OPEN_PARMSW,*LPMCI_OVLY_OPEN_PARMSW;
typedef struct tagMCI_OVLY_WINDOW_PARMSA {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCSTR lpstrText;
} MCI_OVLY_WINDOW_PARMSA,*PMCI_OVLY_WINDOW_PARMSA,*LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCWSTR lpstrText;
} MCI_OVLY_WINDOW_PARMSW,*PMCI_OVLY_WINDOW_PARMSW,*LPMCI_OVLY_WINDOW_PARMSW;
typedef struct tagMCI_OVLY_RECT_PARMS {
 DWORD dwCallback;




 RECT rc;

} MCI_OVLY_RECT_PARMS,*PMCI_OVLY_RECT_PARMS,*LPMCI_OVLY_RECT_PARMS;
typedef struct tagMCI_OVLY_SAVE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
 RECT rc;
} MCI_OVLY_SAVE_PARMSA,*PMCI_OVLY_SAVE_PARMSA,*LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
 RECT rc;
} MCI_OVLY_SAVE_PARMSW,*PMCI_OVLY_SAVE_PARMSW,*LPMCI_OVLY_SAVE_PARMSW;
typedef struct tagMCI_OVLY_LOAD_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
 RECT rc;
} MCI_OVLY_LOAD_PARMSA,*PMCI_OVLY_LOAD_PARMSA,*LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
 RECT rc;
} MCI_OVLY_LOAD_PARMSW,*PMCI_OVLY_LOAD_PARMSW,*LPMCI_OVLY_LOAD_PARMSW;
# 1890 "C:/upp/mingw/include/mmsystem.h" 3
typedef WAVEOUTCAPSA WAVEOUTCAPS,*PWAVEOUTCAPS,*LPWAVEOUTCAPS;
typedef WAVEINCAPSA WAVEINCAPS,*PWAVEINCAPS,*LPWAVEINCAPS;
typedef MIDIOUTCAPSA MIDIOUTCAPS,*PMIDIOUTCAPS,*LPMIDIOUTCAPS;
typedef MIDIINCAPSA MIDIINCAPS,*PMIDIINCAPS,*LPMIDIINCAPS;
typedef AUXCAPSA AUXCAPS,*PAUXCAPS,*LPAUXCAPS;
typedef MIXERCAPSA MIXERCAPS,*PMIXERCAPS,*LPMIXERCAPS;
typedef MIXERLINEA MIXERLINE,*PMIXERLINE,*LPMIXERLINE;
typedef MIXERCONTROLA MIXERCONTROL,*PMIXERCONTROL,*LPMIXERCONTROL;
typedef MIXERLINECONTROLSA MIXERLINECONTROLS,*PMIXERLINECONTROLS,*LPMIXERLINECONTROLS;
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT,*PMIXERCONTROLDETAILS_LISTTEXT,*LPMIXERCONTROLDETAILS_LISTTEXT;
typedef JOYCAPSA JOYCAPS,*PJOYCAPS,*LPJOYCAPS;
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS,*PMCI_OPEN_PARMS,*LPMCI_OPEN_PARMS;
typedef MCI_INFO_PARMSA MCI_INFO_PARMS,*LPMCI_INFO_PARMS;
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS,*PMCI_SYSINFO_PARMS,*LPMCI_SYSINFO_PARMS;
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS,*PMCI_SAVE_PARMS,*LPMCI_SAVE_PARMS;
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS,*PMCI_LOAD_PARMS,*LPMCI_LOAD_PARMS;
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS,*PMCI_VD_ESCAPE_PARMS,*LPMCI_VD_ESCAPE_PARMS;
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS,*PMCI_WAVE_OPEN_PARMS,*LPMCI_WAVE_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS,*PMCI_ANIM_OPEN_PARMS,*LPMCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS,*PMCI_ANIM_WINDOW_PARMS,*LPMCI_ANIM_WINDOW_PARMS;
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS,*PMCI_OVLY_OPEN_PARMS,*LPMCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS,*PMCI_OVLY_WINDOW_PARMS,*LPMCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS,*PMCI_OVLY_SAVE_PARMS,*LPMCI_OVLY_SAVE_PARMS;
# 1940 "C:/upp/mingw/include/mmsystem.h" 3
}

#pragma pack(pop)
# 81 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/nb30.h" 1 3



       
# 5 "C:/upp/mingw/include/nb30.h" 3



extern "C" {
# 95 "C:/upp/mingw/include/nb30.h" 3
typedef struct _ACTION_HEADER {
 ULONG transport_id;
 USHORT action_code;
 USHORT reserved;
} ACTION_HEADER,*PACTION_HEADER;
typedef struct _ADAPTER_STATUS {
 UCHAR adapter_address[6];
 UCHAR rev_major;
 UCHAR reserved0;
 UCHAR adapter_type;
 UCHAR rev_minor;
 WORD duration;
 WORD frmr_recv;
 WORD frmr_xmit;
 WORD iframe_recv_err;
 WORD xmit_aborts;
 DWORD xmit_success;
 DWORD recv_success;
 WORD iframe_xmit_err;
 WORD recv_buff_unavail;
 WORD t1_timeouts;
 WORD ti_timeouts;
 DWORD reserved1;
 WORD free_ncbs;
 WORD max_cfg_ncbs;
 WORD max_ncbs;
 WORD xmit_buf_unavail;
 WORD max_dgram_size;
 WORD pending_sess;
 WORD max_cfg_sess;
 WORD max_sess;
 WORD max_sess_pkt_size;
 WORD name_count;
} ADAPTER_STATUS,*PADAPTER_STATUS;
typedef struct _FIND_NAME_BUFFER {
 UCHAR length;
 UCHAR access_control;
 UCHAR frame_control;
 UCHAR destination_addr[6];
 UCHAR source_addr[6];
 UCHAR routing_info[18];
} FIND_NAME_BUFFER,*PFIND_NAME_BUFFER;
typedef struct _FIND_NAME_HEADER {
 WORD node_count;
 UCHAR reserved;
 UCHAR unique_group;
} FIND_NAME_HEADER,*PFIND_NAME_HEADER;
typedef struct _LANA_ENUM {
 UCHAR length;
 UCHAR lana[254 +1];
} LANA_ENUM,*PLANA_ENUM;
typedef struct _NAME_BUFFER {
 UCHAR name[16];
 UCHAR name_num;
 UCHAR name_flags;
} NAME_BUFFER,*PNAME_BUFFER;
typedef struct _NCB {
 UCHAR ncb_command;
 UCHAR ncb_retcode;
 UCHAR ncb_lsn;
 UCHAR ncb_num;
 PUCHAR ncb_buffer;
 WORD ncb_length;
 UCHAR ncb_callname[16];
 UCHAR ncb_name[16];
 UCHAR ncb_rto;
 UCHAR ncb_sto;
 void (__attribute__((__stdcall__)) *ncb_post)(struct _NCB*);
 UCHAR ncb_lana_num;
 UCHAR ncb_cmd_cplt;
 UCHAR ncb_reserve[10];
 HANDLE ncb_event;
} NCB,*PNCB;
typedef struct _SESSION_BUFFER {
 UCHAR lsn;
 UCHAR state;
 UCHAR local_name[16];
 UCHAR remote_name[16];
 UCHAR rcvs_outstanding;
 UCHAR sends_outstanding;
} SESSION_BUFFER,*PSESSION_BUFFER;
typedef struct _SESSION_HEADER {
 UCHAR sess_name;
 UCHAR num_sess;
 UCHAR rcv_dg_outstanding;
 UCHAR rcv_any_outstanding;
} SESSION_HEADER,*PSESSION_HEADER;
UCHAR __attribute__((__stdcall__)) Netbios(PNCB);

}
# 82 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/rpc.h" 1 3

# 1 "C:/upp/mingw/include/windows.h" 1 3
# 3 "C:/upp/mingw/include/rpc.h" 2 3





       
# 9 "C:/upp/mingw/include/rpc.h" 3



extern "C" {
# 37 "C:/upp/mingw/include/rpc.h" 3
typedef void *I_RPC_HANDLE;
typedef long RPC_STATUS;

# 1 "C:/upp/mingw/include/rpcdce.h" 1 3



       
# 5 "C:/upp/mingw/include/rpcdce.h" 3



extern "C" {

# 1 "C:/upp/mingw/include/basetyps.h" 1 3



       
# 5 "C:/upp/mingw/include/basetyps.h" 3
# 125 "C:/upp/mingw/include/basetyps.h" 3
typedef GUID UUID;



typedef GUID IID;

typedef GUID CLSID;
typedef CLSID *LPCLSID;
typedef IID *LPIID;
typedef IID *REFIID;
typedef CLSID *REFCLSID;
typedef GUID FMTID;
typedef FMTID *REFFMTID;
typedef unsigned long error_status_t;

typedef unsigned long PROPID;
# 11 "C:/upp/mingw/include/rpcdce.h" 2 3
# 94 "C:/upp/mingw/include/rpcdce.h" 3
typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
typedef struct _RPC_BINDING_VECTOR {
 unsigned long Count;
 RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
typedef struct _UUID_VECTOR {
 unsigned long Count;
 UUID *Uuid[1];
} UUID_VECTOR;
typedef void *RPC_IF_HANDLE;
typedef struct _RPC_IF_ID {
 UUID Uuid;
 unsigned short VersMajor;
 unsigned short VersMinor;
} RPC_IF_ID;
typedef struct _RPC_POLICY {
 unsigned int Length ;
 unsigned long EndpointFlags ;
 unsigned long NICFlags ;
} RPC_POLICY,*PRPC_POLICY ;
typedef void __attribute__((__stdcall__)) RPC_OBJECT_INQ_FN(UUID*,UUID*,RPC_STATUS*);
typedef RPC_STATUS RPC_IF_CALLBACK_FN(RPC_IF_HANDLE,void*);
typedef struct {
 unsigned int Count;
 unsigned long Stats[1];
} RPC_STATS_VECTOR;
typedef struct {
 unsigned long Count;
 RPC_IF_ID*IfId[1];
} RPC_IF_ID_VECTOR;
typedef void *RPC_AUTH_IDENTITY_HANDLE;
typedef void *RPC_AUTHZ_HANDLE;
typedef struct _RPC_SECURITY_QOS {
 unsigned long Version;
 unsigned long Capabilities;
 unsigned long IdentityTracking;
 unsigned long ImpersonationType;
} RPC_SECURITY_QOS,*PRPC_SECURITY_QOS;
typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
 unsigned short *User;
 unsigned long UserLength;
 unsigned short *Domain;
 unsigned long DomainLength;
 unsigned short *Password;
 unsigned long PasswordLength;
 unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W,*PSEC_WINNT_AUTH_IDENTITY_W;
typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
 unsigned char *User;
 unsigned long UserLength;
 unsigned char *Domain;
 unsigned long DomainLength;
 unsigned char *Password;
 unsigned long PasswordLength;
 unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A,*PSEC_WINNT_AUTH_IDENTITY_A;
typedef struct {
 unsigned char *UserName;
 unsigned char *ComputerName;
 unsigned short Privilege;
 unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1,* PRPC_CLIENT_INFORMATION1;
typedef I_RPC_HANDLE *RPC_EP_INQ_HANDLE;
typedef int(__attribute__((__stdcall__)) *RPC_MGMT_AUTHORIZATION_FN)(RPC_BINDING_HANDLE,unsigned long,RPC_STATUS*);


typedef struct _RPC_PROTSEQ_VECTORA {
 unsigned int Count;
 unsigned char*Protseq[1];
} RPC_PROTSEQ_VECTORA;
typedef struct _RPC_PROTSEQ_VECTORW {
 unsigned int Count;
 unsigned short*Protseq[1];
} RPC_PROTSEQ_VECTORW;
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFromStringBindingA(unsigned char *,RPC_BINDING_HANDLE *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFromStringBindingW(unsigned short *,RPC_BINDING_HANDLE *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingToStringBindingA(RPC_BINDING_HANDLE,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingToStringBindingW(RPC_BINDING_HANDLE,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingComposeA(unsigned char *,unsigned char *,unsigned char *,unsigned char *,unsigned char *,unsigned char **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingComposeW(unsigned short *,unsigned short *,unsigned short *,unsigned short *,unsigned short *,unsigned short **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingParseA(unsigned char *,unsigned char **,unsigned char **,unsigned char **,unsigned char **,unsigned char **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingParseW(unsigned short *,unsigned short **,unsigned short **,unsigned short **,unsigned short **,unsigned short **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringFreeA(unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcStringFreeW(unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkIsProtseqValidA(unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkIsProtseqValidW(unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkInqProtseqsA(RPC_PROTSEQ_VECTORA**);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkInqProtseqsW(RPC_PROTSEQ_VECTORW**);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA**);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeW(RPC_PROTSEQ_VECTORW**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqA(unsigned char*,unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqW(unsigned short*,unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqExA(unsigned char*,unsigned int MaxCalls,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqExW(unsigned short*,unsigned int,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpA(unsigned char*,unsigned int,unsigned char*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpExA(unsigned char*,unsigned int,unsigned char*,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpW(unsigned short*,unsigned int,unsigned short*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpExW(unsigned short*,unsigned int,unsigned short*,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfA(unsigned char*,unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfExA(unsigned char*,unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfW(unsigned short*,unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfExW(unsigned short*,unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqServerPrincNameA(RPC_BINDING_HANDLE,unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqServerPrincNameW(RPC_BINDING_HANDLE,unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqDefaultPrincNameA(unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqDefaultPrincNameW(unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingInqEntryNameA(RPC_BINDING_HANDLE,unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingInqEntryNameW(RPC_BINDING_HANDLE,unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthClientA(RPC_BINDING_HANDLE,RPC_AUTHZ_HANDLE *,unsigned char**,unsigned long*,unsigned long*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthClientW(RPC_BINDING_HANDLE,RPC_AUTHZ_HANDLE *,unsigned short**,unsigned long*,unsigned long*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoA(RPC_BINDING_HANDLE,unsigned char**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoW(RPC_BINDING_HANDLE,unsigned short**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE,unsigned char*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE,unsigned char*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoW(RPC_BINDING_HANDLE,unsigned short*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoExW(RPC_BINDING_HANDLE,unsigned short*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoExA(RPC_BINDING_HANDLE,unsigned char**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoExW(RPC_BINDING_HANDLE,unsigned short ** , unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *, unsigned long , RPC_SECURITY_QOS *);
typedef void(__attribute__((__stdcall__)) *RPC_AUTH_KEY_RETRIEVAL_FN)(void*,unsigned short*,unsigned long,void**,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterAuthInfoA(unsigned char*,unsigned long,RPC_AUTH_KEY_RETRIEVAL_FN,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterAuthInfoW(unsigned short*,unsigned long,RPC_AUTH_KEY_RETRIEVAL_FN,void*);
RPC_STATUS __attribute__((__stdcall__)) UuidToStringA(UUID*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) UuidFromStringA(unsigned char*,UUID*);
RPC_STATUS __attribute__((__stdcall__)) UuidToStringW(UUID*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) UuidFromStringW(unsigned short*,UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterNoReplaceA(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterNoReplaceW(RPC_IF_HANDLE,RPC_BINDING_VECTOR*, UUID_VECTOR*,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterA(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterW(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) DceErrorInqTextA(RPC_STATUS,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) DceErrorInqTextW(RPC_STATUS,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqNextA(RPC_EP_INQ_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE*,UUID*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqNextW(RPC_EP_INQ_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE*,UUID*,unsigned short**);
# 332 "C:/upp/mingw/include/rpcdce.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcBindingCopy(RPC_BINDING_HANDLE,RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFree(RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqObject(RPC_BINDING_HANDLE,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingReset(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetObject(RPC_BINDING_HANDLE,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqDefaultProtectLevel(unsigned long,unsigned long *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingVectorFree(RPC_BINDING_VECTOR **);
RPC_STATUS __attribute__((__stdcall__)) RpcIfInqId(RPC_IF_HANDLE,RPC_IF_ID *);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqComTimeout(RPC_BINDING_HANDLE,unsigned int*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetComTimeout(RPC_BINDING_HANDLE,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetCancelTimeout(long Timeout);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectInqType(UUID *,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectSetInqFn(RPC_OBJECT_INQ_FN *);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectSetType(UUID *,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA **);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqIf(RPC_IF_HANDLE,UUID*,void**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerListen(unsigned int,unsigned int,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIf(RPC_IF_HANDLE,UUID*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIfEx(RPC_IF_HANDLE,UUID*,void*,unsigned int,unsigned int,RPC_IF_CALLBACK_FN*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIf2(RPC_IF_HANDLE,UUID*,void*,unsigned int,unsigned int,unsigned int,RPC_IF_CALLBACK_FN*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUnregisterIf(RPC_IF_HANDLE,UUID*,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqs(unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsEx(unsigned int,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsIf(unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsIfEx(unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtStatsVectorFree(RPC_STATS_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqStats(RPC_BINDING_HANDLE,RPC_STATS_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtIsServerListening(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtStopServerListening(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtWaitServerListen(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetServerStackSize(unsigned long);
void __attribute__((__stdcall__)) RpcSsDontSerializeContext(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEnableIdleCleanup(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqIfIds(RPC_BINDING_HANDLE,RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcIfIdVectorFree(RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcEpResolveBinding(RPC_BINDING_HANDLE,RPC_IF_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingServerFromClient(RPC_BINDING_HANDLE,RPC_BINDING_HANDLE*);
__attribute__((noreturn)) void __attribute__((__stdcall__)) RpcRaiseException(RPC_STATUS);
RPC_STATUS __attribute__((__stdcall__)) RpcTestCancel(void);
RPC_STATUS __attribute__((__stdcall__)) RpcCancelThread(void*);
RPC_STATUS __attribute__((__stdcall__)) UuidCreate(UUID*);
signed int __attribute__((__stdcall__)) UuidCompare(UUID*,UUID*, RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) UuidCreateNil(UUID*);
int __attribute__((__stdcall__)) UuidEqual(UUID*,UUID*, RPC_STATUS*);
unsigned short __attribute__((__stdcall__)) UuidHash(UUID*,RPC_STATUS*);
int __attribute__((__stdcall__)) UuidIsNil(UUID*,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpUnregister(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqBegin(RPC_BINDING_HANDLE,unsigned long,RPC_IF_ID*,unsigned long,UUID*,RPC_EP_INQ_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqDone(RPC_EP_INQ_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpUnregister(RPC_BINDING_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE,UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetAuthorizationFn(RPC_MGMT_AUTHORIZATION_FN);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqParameter(unsigned int,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetParameter(unsigned int,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtBindingInqParameter(RPC_BINDING_HANDLE,unsigned int,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtBindingSetParameter(RPC_BINDING_HANDLE,unsigned int,unsigned long);





# 1 "C:/upp/mingw/include/rpcdcep.h" 1 3



       
# 5 "C:/upp/mingw/include/rpcdcep.h" 3



extern "C" {
# 22 "C:/upp/mingw/include/rpcdcep.h" 3
typedef struct _RPC_VERSION {
 unsigned short MajorVersion;
 unsigned short MinorVersion;
} RPC_VERSION;
typedef struct _RPC_SYNTAX_IDENTIFIER {
 GUID SyntaxGUID;
 RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, *PRPC_SYNTAX_IDENTIFIER;
typedef struct _RPC_MESSAGE {
 HANDLE Handle;
 unsigned long DataRepresentation;
 void *Buffer;
 unsigned int BufferLength;
 unsigned int ProcNum;
 PRPC_SYNTAX_IDENTIFIER TransferSyntax;
 void *RpcInterfaceInformation;
 void *ReservedForRuntime;
 void *ManagerEpv;
 void *ImportContext;
 unsigned long RpcFlags;
} RPC_MESSAGE,*PRPC_MESSAGE;
typedef long __attribute__((__stdcall__)) RPC_FORWARD_FUNCTION(GUID*,RPC_VERSION*,GUID*,unsigned char*,void**);
typedef void(__attribute__((__stdcall__)) *RPC_DISPATCH_FUNCTION) ( PRPC_MESSAGE Message);
typedef struct {
 unsigned int DispatchTableCount;
 RPC_DISPATCH_FUNCTION *DispatchTable;
 int Reserved;
} RPC_DISPATCH_TABLE,*PRPC_DISPATCH_TABLE;
typedef struct _RPC_PROTSEQ_ENDPOINT {
 unsigned char *RpcProtocolSequence;
 unsigned char *Endpoint;
} RPC_PROTSEQ_ENDPOINT,*PRPC_PROTSEQ_ENDPOINT;
typedef struct _RPC_SERVER_INTERFACE {
 unsigned int Length;
 RPC_SYNTAX_IDENTIFIER InterfaceId;
 RPC_SYNTAX_IDENTIFIER TransferSyntax;
 PRPC_DISPATCH_TABLE DispatchTable;
 unsigned int RpcProtseqEndpointCount;
 PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
 void *DefaultManagerEpv;
 void const *InterpreterInfo;
} RPC_SERVER_INTERFACE,*PRPC_SERVER_INTERFACE;
typedef struct _RPC_CLIENT_INTERFACE {
 unsigned int Length;
 RPC_SYNTAX_IDENTIFIER InterfaceId;
 RPC_SYNTAX_IDENTIFIER TransferSyntax;
 PRPC_DISPATCH_TABLE DispatchTable;
 unsigned int RpcProtseqEndpointCount;
 PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
 unsigned long Reserved;
 void const *InterpreterInfo;
} RPC_CLIENT_INTERFACE,*PRPC_CLIENT_INTERFACE;
typedef void *I_RPC_MUTEX;
typedef struct _RPC_TRANSFER_SYNTAX {
 GUID Uuid;
 unsigned short VersMajor;
 unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;
typedef RPC_STATUS (*RPC_BLOCKING_FN)(void*,void*,void*);

long __attribute__((__stdcall__)) I_RpcGetBuffer(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcSendReceive(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcSend(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcFreeBuffer(RPC_MESSAGE*);
void __attribute__((__stdcall__)) I_RpcRequestMutex(I_RPC_MUTEX*);
void __attribute__((__stdcall__)) I_RpcClearMutex(I_RPC_MUTEX);
void __attribute__((__stdcall__)) I_RpcDeleteMutex(I_RPC_MUTEX);
__attribute__((__stdcall__)) void * I_RpcAllocate(unsigned int);
void __attribute__((__stdcall__)) I_RpcFree(void*);
void __attribute__((__stdcall__)) I_RpcPauseExecution(unsigned long);
typedef void(__attribute__((__stdcall__)) *PRPC_RUNDOWN) (void*);
long __attribute__((__stdcall__)) I_RpcMonitorAssociation(HANDLE,PRPC_RUNDOWN,void*);
long __attribute__((__stdcall__)) I_RpcStopMonitorAssociation(HANDLE);
HANDLE __attribute__((__stdcall__)) I_RpcGetCurrentCallHandle(void);
long __attribute__((__stdcall__)) I_RpcGetAssociationContext(void**);
long __attribute__((__stdcall__)) I_RpcSetAssociationContext(void*);

long __attribute__((__stdcall__)) I_RpcNsBindingSetEntryName(HANDLE,unsigned long,unsigned short*);
long __attribute__((__stdcall__)) I_RpcBindingInqDynamicEndpoint(HANDLE, unsigned short**);




long __attribute__((__stdcall__)) I_RpcBindingInqTransportType(HANDLE,unsigned int*);
long __attribute__((__stdcall__)) I_RpcIfInqTransferSyntaxes(HANDLE,RPC_TRANSFER_SYNTAX*,unsigned int,unsigned int*);
long __attribute__((__stdcall__)) I_UuidCreate(GUID*);
long __attribute__((__stdcall__)) I_RpcBindingCopy(HANDLE,HANDLE*);
long __attribute__((__stdcall__)) I_RpcBindingIsClientLocal(HANDLE,unsigned int*);
void __attribute__((__stdcall__)) I_RpcSsDontSerializeContext(void);
long __attribute__((__stdcall__)) I_RpcServerRegisterForwardFunction(RPC_FORWARD_FUNCTION*);
long __attribute__((__stdcall__)) I_RpcConnectionInqSockBuffSize(unsigned long*,unsigned long*);
long __attribute__((__stdcall__)) I_RpcConnectionSetSockBuffSize(unsigned long,unsigned long);
long __attribute__((__stdcall__)) I_RpcBindingSetAsync(HANDLE,RPC_BLOCKING_FN);
long __attribute__((__stdcall__)) I_RpcAsyncSendReceive(RPC_MESSAGE*,void*);
long __attribute__((__stdcall__)) I_RpcGetThreadWindowHandle(void**);
long __attribute__((__stdcall__)) I_RpcServerThreadPauseListening(void);
long __attribute__((__stdcall__)) I_RpcServerThreadContinueListening(void);
long __attribute__((__stdcall__)) I_RpcServerUnregisterEndpointA(unsigned char*,unsigned char*);
long __attribute__((__stdcall__)) I_RpcServerUnregisterEndpointW(unsigned short*,unsigned short*);






}
# 393 "C:/upp/mingw/include/rpcdce.h" 2 3

}
# 41 "C:/upp/mingw/include/rpc.h" 2 3
# 1 "C:/upp/mingw/include/rpcnsi.h" 1 3



       
# 5 "C:/upp/mingw/include/rpcnsi.h" 3



extern "C" {

typedef void *RPC_NS_HANDLE;
# 20 "C:/upp/mingw/include/rpcnsi.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingExportA(unsigned long,unsigned char*,RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingUnexportA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupBeginA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupNext(RPC_NS_HANDLE,RPC_BINDING_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrAddA(unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrRemoveA(unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqBeginA(unsigned long,unsigned char*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqNextA(RPC_NS_HANDLE,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltAddA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltRemoveA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqBeginA(unsigned long,unsigned char*,unsigned long,RPC_IF_ID*,unsigned long,unsigned long,unsigned char*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqNextA(RPC_NS_HANDLE,RPC_IF_ID*,unsigned char**,unsigned long*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqNext( RPC_NS_HANDLE, UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqDone( RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryExpandNameA(unsigned long,unsigned char*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtBindingUnexportA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryCreateA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryInqIfIdsA(unsigned long,unsigned char*,RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtInqExpAge(unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtSetExpAge(unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportNext(RPC_NS_HANDLE,RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingSelect(RPC_BINDING_VECTOR*,RPC_BINDING_HANDLE*);

RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqBeginA(unsigned long,unsigned char*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportBeginA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID*,RPC_NS_HANDLE*);


RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingExportW(unsigned long,unsigned short*,RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingUnexportW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupBeginW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrAddW(unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrRemoveW(unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqBeginW(unsigned long,unsigned short*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqNextW(RPC_NS_HANDLE,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltAddW(unsigned long,unsigned short*, RPC_IF_ID*,unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltRemoveW(unsigned long,unsigned short*, RPC_IF_ID*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqBeginW(unsigned long,unsigned short*, unsigned long,RPC_IF_ID*,unsigned long,unsigned long,unsigned short*, RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqNextW(RPC_NS_HANDLE,RPC_IF_ID*, unsigned short**,unsigned long*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqBeginW(unsigned long,unsigned short*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryExpandNameW(unsigned long,unsigned short*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtBindingUnexportW(unsigned long,unsigned short*,RPC_IF_ID*,unsigned long,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryCreateW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryInqIfIdsW(unsigned long,unsigned short , RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportBeginW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID*,RPC_NS_HANDLE*);
# 120 "C:/upp/mingw/include/rpcnsi.h" 3
}
# 42 "C:/upp/mingw/include/rpc.h" 2 3
# 1 "C:/upp/mingw/include/rpcnterr.h" 1 3



       
# 5 "C:/upp/mingw/include/rpcnterr.h" 3
# 43 "C:/upp/mingw/include/rpc.h" 2 3
# 59 "C:/upp/mingw/include/rpc.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcImpersonateClient(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcRevertToSelf(void);
long __attribute__((__stdcall__)) I_RpcMapWin32Status(RPC_STATUS);

}
# 83 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/shellapi.h" 1 3



       
# 5 "C:/upp/mingw/include/shellapi.h" 3



extern "C" {
# 142 "C:/upp/mingw/include/shellapi.h" 3
typedef WORD FILEOP_FLAGS;
typedef WORD PRINTEROP_FLAGS;
# 1 "C:/upp/mingw/include/pshpack2.h" 1 3

#pragma pack(push,2)
# 145 "C:/upp/mingw/include/shellapi.h" 2 3
typedef struct _AppBarData {
 DWORD cbSize;
 HWND hWnd;
 UINT uCallbackMessage;
 UINT uEdge;
 RECT rc;
 LPARAM lParam;
} APPBARDATA,*PAPPBARDATA;
typedef struct HDROP__{int i;}*HDROP;

typedef struct _NOTIFYICONDATAA {
  DWORD cbSize;
  HWND hWnd;
  UINT uID;
  UINT uFlags;
  UINT uCallbackMessage;
  HICON hIcon;
# 174 "C:/upp/mingw/include/shellapi.h" 3
  CHAR szTip[64];







} NOTIFYICONDATAA,*PNOTIFYICONDATAA;

typedef struct _NOTIFYICONDATAW {
  DWORD cbSize;
  HWND hWnd;
  UINT uID;
  UINT uFlags;
  UINT uCallbackMessage;
  HICON hIcon;
# 203 "C:/upp/mingw/include/shellapi.h" 3
  WCHAR szTip[64];







} NOTIFYICONDATAW,*PNOTIFYICONDATAW;

typedef struct _SHELLEXECUTEINFOA {
 DWORD cbSize;
 ULONG fMask;
 HWND hwnd;
 LPCSTR lpVerb;
 LPCSTR lpFile;
 LPCSTR lpParameters;
 LPCSTR lpDirectory;
 int nShow;
 HINSTANCE hInstApp;
 PVOID lpIDList;
 LPCSTR lpClass;
 HKEY hkeyClass;
 DWORD dwHotKey;
 HANDLE hIcon;
 HANDLE hProcess;
} SHELLEXECUTEINFOA,*LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW {
 DWORD cbSize;
 ULONG fMask;
 HWND hwnd;
 LPCWSTR lpVerb;
 LPCWSTR lpFile;
 LPCWSTR lpParameters;
 LPCWSTR lpDirectory;
 int nShow;
 HINSTANCE hInstApp;
 PVOID lpIDList;
 LPCWSTR lpClass;
 HKEY hkeyClass;
 DWORD dwHotKey;
 HANDLE hIcon;
 HANDLE hProcess;
} SHELLEXECUTEINFOW,*LPSHELLEXECUTEINFOW;
typedef struct _SHFILEOPSTRUCTA {
 HWND hwnd;
 UINT wFunc;
 LPCSTR pFrom;
 LPCSTR pTo;
 FILEOP_FLAGS fFlags;
 BOOL fAnyOperationsAborted;
 PVOID hNameMappings;
 LPCSTR lpszProgressTitle;
} SHFILEOPSTRUCTA,*LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW {
 HWND hwnd;
 UINT wFunc;
 LPCWSTR pFrom;
 LPCWSTR pTo;
 FILEOP_FLAGS fFlags;
 BOOL fAnyOperationsAborted;
 PVOID hNameMappings;
 LPCWSTR lpszProgressTitle;
} SHFILEOPSTRUCTW,*LPSHFILEOPSTRUCTW;
typedef struct _SHFILEINFOA {
 HICON hIcon;
 int iIcon;
 DWORD dwAttributes;
 CHAR szDisplayName[260];
 CHAR szTypeName[80];
} SHFILEINFOA;
typedef struct _SHFILEINFOW {
 HICON hIcon;
 int iIcon;
 DWORD dwAttributes;
 WCHAR szDisplayName[260];
 WCHAR szTypeName[80];
} SHFILEINFOW;
typedef struct _SHQUERYRBINFO {
 DWORD cbSize;
 long long i64Size;
 long long i64NumItems;
} SHQUERYRBINFO, *LPSHQUERYRBINFO;
# 1 "C:/upp/mingw/include/poppack.h" 1 3

#pragma pack(pop)
# 287 "C:/upp/mingw/include/shellapi.h" 2 3

LPWSTR * __attribute__((__stdcall__)) CommandLineToArgvW(LPCWSTR,int*);
void __attribute__((__stdcall__)) DragAcceptFiles(HWND,BOOL);
void __attribute__((__stdcall__)) DragFinish(HDROP);
UINT __attribute__((__stdcall__)) DragQueryFileA(HDROP,UINT,LPSTR,UINT);
UINT __attribute__((__stdcall__)) DragQueryFileW(HDROP,UINT,LPWSTR,UINT);
BOOL __attribute__((__stdcall__)) DragQueryPoint(HDROP,LPPOINT);
HICON __attribute__((__stdcall__)) DuplicateIcon(HINSTANCE,HICON);
HICON __attribute__((__stdcall__)) ExtractAssociatedIconA(HINSTANCE,LPCSTR,PWORD);
HICON __attribute__((__stdcall__)) ExtractAssociatedIconW(HINSTANCE,LPCWSTR,PWORD);
HICON __attribute__((__stdcall__)) ExtractIconA(HINSTANCE,LPCSTR,UINT);
HICON __attribute__((__stdcall__)) ExtractIconW(HINSTANCE,LPCWSTR,UINT);
UINT __attribute__((__stdcall__)) ExtractIconExA(LPCSTR,int,HICON*,HICON*,UINT);
UINT __attribute__((__stdcall__)) ExtractIconExW(LPCWSTR,int,HICON*,HICON*,UINT);
HINSTANCE __attribute__((__stdcall__)) FindExecutableA(LPCSTR,LPCSTR,LPSTR);
HINSTANCE __attribute__((__stdcall__)) FindExecutableW(LPCWSTR,LPCWSTR,LPWSTR);
UINT __attribute__((__stdcall__)) SHAppBarMessage(DWORD,PAPPBARDATA);
BOOL __attribute__((__stdcall__)) Shell_NotifyIconA(DWORD,PNOTIFYICONDATAA);
BOOL __attribute__((__stdcall__)) Shell_NotifyIconW(DWORD,PNOTIFYICONDATAW);
int __attribute__((__stdcall__)) ShellAboutA(HWND,LPCSTR,LPCSTR,HICON);
int __attribute__((__stdcall__)) ShellAboutW(HWND,LPCWSTR,LPCWSTR,HICON);
HINSTANCE __attribute__((__stdcall__)) ShellExecuteA(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,INT);
HINSTANCE __attribute__((__stdcall__)) ShellExecuteW(HWND,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,INT);
BOOL __attribute__((__stdcall__)) ShellExecuteExA(LPSHELLEXECUTEINFOA);
BOOL __attribute__((__stdcall__)) ShellExecuteExW(LPSHELLEXECUTEINFOW);
int __attribute__((__stdcall__)) SHFileOperationA(LPSHFILEOPSTRUCTA);
int __attribute__((__stdcall__)) SHFileOperationW(LPSHFILEOPSTRUCTW);
void __attribute__((__stdcall__)) SHFreeNameMappings(HANDLE);
DWORD __attribute__((__stdcall__)) SHGetFileInfoA(LPCSTR,DWORD,SHFILEINFOA*,UINT,UINT);
DWORD __attribute__((__stdcall__)) SHGetFileInfoW(LPCWSTR,DWORD,SHFILEINFOW*,UINT,UINT);
HRESULT __attribute__((__stdcall__)) SHQueryRecycleBinA(LPCSTR, LPSHQUERYRBINFO);
HRESULT __attribute__((__stdcall__)) SHQueryRecycleBinW(LPCWSTR, LPSHQUERYRBINFO);
HRESULT __attribute__((__stdcall__)) SHEmptyRecycleBinA(HWND,LPCSTR,DWORD);
HRESULT __attribute__((__stdcall__)) SHEmptyRecycleBinW(HWND,LPCWSTR,DWORD);
# 342 "C:/upp/mingw/include/shellapi.h" 3
typedef NOTIFYICONDATAA NOTIFYICONDATA,*PNOTIFYICONDATA;
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO,*LPSHELLEXECUTEINFO;
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT,*LPSHFILEOPSTRUCT;
typedef SHFILEINFOA SHFILEINFO;
# 361 "C:/upp/mingw/include/shellapi.h" 3
}
# 84 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/winperf.h" 1 3



       
# 5 "C:/upp/mingw/include/winperf.h" 3



extern "C" {
# 78 "C:/upp/mingw/include/winperf.h" 3
typedef struct _PERF_DATA_BLOCK {
 WCHAR Signature[4];
 DWORD LittleEndian;
 DWORD Version;
 DWORD Revision;
 DWORD TotalByteLength;
 DWORD HeaderLength;
 DWORD NumObjectTypes;
 LONG DefaultObject;
 SYSTEMTIME SystemTime;
 LARGE_INTEGER PerfTime;
 LARGE_INTEGER PerfFreq;
 LARGE_INTEGER PerfTime100nSec;
 DWORD SystemNameLength;
 DWORD SystemNameOffset;
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;
typedef struct _PERF_OBJECT_TYPE {
 DWORD TotalByteLength;
 DWORD DefinitionLength;
 DWORD HeaderLength;
 DWORD ObjectNameTitleIndex;
 LPWSTR ObjectNameTitle;
 DWORD ObjectHelpTitleIndex;
 LPWSTR ObjectHelpTitle;
 DWORD DetailLevel;
 DWORD NumCounters;
 LONG DefaultCounter;
 LONG NumInstances;
 DWORD CodePage;
 LARGE_INTEGER PerfTime;
 LARGE_INTEGER PerfFreq;
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;
typedef struct _PERF_COUNTER_DEFINITION {
 DWORD ByteLength;
 DWORD CounterNameTitleIndex;
 LPWSTR CounterNameTitle;
 DWORD CounterHelpTitleIndex;
 LPWSTR CounterHelpTitle;
 LONG DefaultScale;
 DWORD DetailLevel;
 DWORD CounterType;
 DWORD CounterSize;
 DWORD CounterOffset;
} PERF_COUNTER_DEFINITION,*PPERF_COUNTER_DEFINITION;
typedef struct _PERF_INSTANCE_DEFINITION {
 DWORD ByteLength;
 DWORD ParentObjectTitleIndex;
 DWORD ParentObjectInstance;
 LONG UniqueID;
 DWORD NameOffset;
 DWORD NameLength;
} PERF_INSTANCE_DEFINITION,*PPERF_INSTANCE_DEFINITION;
typedef struct _PERF_COUNTER_BLOCK {
 DWORD ByteLength;
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;
typedef DWORD(__attribute__((__stdcall__)) PM_OPEN_PROC)(LPWSTR);
typedef DWORD(__attribute__((__stdcall__)) PM_COLLECT_PROC)(LPWSTR,PVOID*,PDWORD,PDWORD);
typedef DWORD(__attribute__((__stdcall__)) PM_CLOSE_PROC)(void);

}
# 85 "C:/upp/mingw/include/windows.h" 2 3

# 1 "C:/upp/mingw/include/commdlg.h" 1 3



       
# 5 "C:/upp/mingw/include/commdlg.h" 3



extern "C" {

#pragma pack(push,1)
# 232 "C:/upp/mingw/include/commdlg.h" 3
typedef UINT (__attribute__((__stdcall__)) *__CDHOOKPROC)(HWND,UINT,WPARAM,LPARAM);
typedef __CDHOOKPROC LPCCHOOKPROC;
typedef __CDHOOKPROC LPCFHOOKPROC;
typedef __CDHOOKPROC LPFRHOOKPROC;
typedef __CDHOOKPROC LPOFNHOOKPROC;
typedef __CDHOOKPROC LPPAGEPAINTHOOK;
typedef __CDHOOKPROC LPPAGESETUPHOOK;
typedef __CDHOOKPROC LPSETUPHOOKPROC;
typedef __CDHOOKPROC LPPRINTHOOKPROC;
typedef struct tagCHOOSECOLORA {
 DWORD lStructSize;
 HWND hwndOwner;
 HWND hInstance;
 COLORREF rgbResult;
 COLORREF* lpCustColors;
 DWORD Flags;
 LPARAM lCustData;
 LPCCHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
} CHOOSECOLORA,*LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
 DWORD lStructSize;
 HWND hwndOwner;
 HWND hInstance;
 COLORREF rgbResult;
 COLORREF* lpCustColors;
 DWORD Flags;
 LPARAM lCustData;
 LPCCHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
} CHOOSECOLORW,*LPCHOOSECOLORW;
typedef struct tagCHOOSEFONTA {
 DWORD lStructSize;
 HWND hwndOwner;
 HDC hDC;
 LPLOGFONTA lpLogFont;
 INT iPointSize;
 DWORD Flags;
 DWORD rgbColors;
 LPARAM lCustData;
 LPCFHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
 HINSTANCE hInstance;
 LPSTR lpszStyle;
 WORD nFontType;
 WORD ___MISSING_ALIGNMENT__;
 INT nSizeMin;
 INT nSizeMax;
} CHOOSEFONTA,*LPCHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
 DWORD lStructSize;
 HWND hwndOwner;
 HDC hDC;
 LPLOGFONTW lpLogFont;
 INT iPointSize;
 DWORD Flags;
 DWORD rgbColors;
 LPARAM lCustData;
 LPCFHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
 HINSTANCE hInstance;
 LPWSTR lpszStyle;
 WORD nFontType;
 WORD ___MISSING_ALIGNMENT__;
 INT nSizeMin;
 INT nSizeMax;
} CHOOSEFONTW,*LPCHOOSEFONTW;
typedef struct tagDEVNAMES {
 WORD wDriverOffset;
 WORD wDeviceOffset;
 WORD wOutputOffset;
 WORD wDefault;
} DEVNAMES,*LPDEVNAMES;
typedef struct {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 DWORD Flags;
 LPSTR lpstrFindWhat;
 LPSTR lpstrReplaceWith;
 WORD wFindWhatLen;
 WORD wReplaceWithLen;
 LPARAM lCustData;
 LPFRHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
} FINDREPLACEA,*LPFINDREPLACEA;
typedef struct {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 DWORD Flags;
 LPWSTR lpstrFindWhat;
 LPWSTR lpstrReplaceWith;
 WORD wFindWhatLen;
 WORD wReplaceWithLen;
 LPARAM lCustData;
 LPFRHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
} FINDREPLACEW,*LPFINDREPLACEW;
typedef struct tagOFNA {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCSTR lpstrFilter;
 LPSTR lpstrCustomFilter;
 DWORD nMaxCustFilter;
 DWORD nFilterIndex;
 LPSTR lpstrFile;
 DWORD nMaxFile;
 LPSTR lpstrFileTitle;
 DWORD nMaxFileTitle;
 LPCSTR lpstrInitialDir;
 LPCSTR lpstrTitle;
 DWORD Flags;
 WORD nFileOffset;
 WORD nFileExtension;
 LPCSTR lpstrDefExt;
 DWORD lCustData;
 LPOFNHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;





} OPENFILENAMEA,*LPOPENFILENAMEA;
typedef struct tagOFNW {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCWSTR lpstrFilter;
 LPWSTR lpstrCustomFilter;
 DWORD nMaxCustFilter;
 DWORD nFilterIndex;
 LPWSTR lpstrFile;
 DWORD nMaxFile;
 LPWSTR lpstrFileTitle;
 DWORD nMaxFileTitle;
 LPCWSTR lpstrInitialDir;
 LPCWSTR lpstrTitle;
 DWORD Flags;
 WORD nFileOffset;
 WORD nFileExtension;
 LPCWSTR lpstrDefExt;
 DWORD lCustData;
 LPOFNHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;





} OPENFILENAMEW,*LPOPENFILENAMEW;
typedef struct _OFNOTIFYA {
 NMHDR hdr;
 LPOPENFILENAMEA lpOFN;
 LPSTR pszFile;
} OFNOTIFYA,*LPOFNOTIFYA;
typedef struct _OFNOTIFYW {
 NMHDR hdr;
 LPOPENFILENAMEW lpOFN;
 LPWSTR pszFile;
} OFNOTIFYW,*LPOFNOTIFYW;
typedef struct tagPSDA {
 DWORD lStructSize;
 HWND hwndOwner;
 HGLOBAL hDevMode;
 HGLOBAL hDevNames;
 DWORD Flags;
 POINT ptPaperSize;
 RECT rtMinMargin;
 RECT rtMargin;
 HINSTANCE hInstance;
 LPARAM lCustData;
 LPPAGESETUPHOOK lpfnPageSetupHook;
 LPPAGEPAINTHOOK lpfnPagePaintHook;
 LPCSTR lpPageSetupTemplateName;
 HGLOBAL hPageSetupTemplate;
} PAGESETUPDLGA,*LPPAGESETUPDLGA;
typedef struct tagPSDW {
 DWORD lStructSize;
 HWND hwndOwner;
 HGLOBAL hDevMode;
 HGLOBAL hDevNames;
 DWORD Flags;
 POINT ptPaperSize;
 RECT rtMinMargin;
 RECT rtMargin;
 HINSTANCE hInstance;
 LPARAM lCustData;
 LPPAGESETUPHOOK lpfnPageSetupHook;
 LPPAGEPAINTHOOK lpfnPagePaintHook;
 LPCWSTR lpPageSetupTemplateName;
 HGLOBAL hPageSetupTemplate;
} PAGESETUPDLGW,*LPPAGESETUPDLGW;
typedef struct tagPDA {
 DWORD lStructSize;
 HWND hwndOwner;
 HANDLE hDevMode;
 HANDLE hDevNames;
 HDC hDC;
 DWORD Flags;
 WORD nFromPage;
 WORD nToPage;
 WORD nMinPage;
 WORD nMaxPage;
 WORD nCopies;
 HINSTANCE hInstance;
 DWORD lCustData;
 LPPRINTHOOKPROC lpfnPrintHook;
 LPSETUPHOOKPROC lpfnSetupHook;
 LPCSTR lpPrintTemplateName;
 LPCSTR lpSetupTemplateName;
 HANDLE hPrintTemplate;
 HANDLE hSetupTemplate;
} PRINTDLGA,*LPPRINTDLGA;
typedef struct tagPDW {
 DWORD lStructSize;
 HWND hwndOwner;
 HANDLE hDevMode;
 HANDLE hDevNames;
 HDC hDC;
 DWORD Flags;
 WORD nFromPage;
 WORD nToPage;
 WORD nMinPage;
 WORD nMaxPage;
 WORD nCopies;
 HINSTANCE hInstance;
 DWORD lCustData;
 LPPRINTHOOKPROC lpfnPrintHook;
 LPSETUPHOOKPROC lpfnSetupHook;
 LPCWSTR lpPrintTemplateName;
 LPCWSTR lpSetupTemplateName;
 HANDLE hPrintTemplate;
 HANDLE hSetupTemplate;
} PRINTDLGW,*LPPRINTDLGW;
# 524 "C:/upp/mingw/include/commdlg.h" 3
BOOL __attribute__((__stdcall__)) ChooseColorA(LPCHOOSECOLORA);
BOOL __attribute__((__stdcall__)) ChooseColorW(LPCHOOSECOLORW);
BOOL __attribute__((__stdcall__)) ChooseFontA(LPCHOOSEFONTA);
BOOL __attribute__((__stdcall__)) ChooseFontW(LPCHOOSEFONTW);
DWORD __attribute__((__stdcall__)) CommDlgExtendedError(void);
HWND __attribute__((__stdcall__)) FindTextA(LPFINDREPLACEA);
HWND __attribute__((__stdcall__)) FindTextW(LPFINDREPLACEW);
short __attribute__((__stdcall__)) GetFileTitleA(LPCSTR,LPSTR,WORD);
short __attribute__((__stdcall__)) GetFileTitleW(LPCWSTR,LPWSTR,WORD);
BOOL __attribute__((__stdcall__)) GetOpenFileNameA(LPOPENFILENAMEA);
BOOL __attribute__((__stdcall__)) GetOpenFileNameW(LPOPENFILENAMEW);
BOOL __attribute__((__stdcall__)) GetSaveFileNameA(LPOPENFILENAMEA);
BOOL __attribute__((__stdcall__)) GetSaveFileNameW(LPOPENFILENAMEW);
BOOL __attribute__((__stdcall__)) PageSetupDlgA(LPPAGESETUPDLGA);
BOOL __attribute__((__stdcall__)) PageSetupDlgW(LPPAGESETUPDLGW);
BOOL __attribute__((__stdcall__)) PrintDlgA(LPPRINTDLGA);
BOOL __attribute__((__stdcall__)) PrintDlgW(LPPRINTDLGW);
HWND __attribute__((__stdcall__)) ReplaceTextA(LPFINDREPLACEA);
HWND __attribute__((__stdcall__)) ReplaceTextW(LPFINDREPLACEW);
# 584 "C:/upp/mingw/include/commdlg.h" 3
typedef CHOOSECOLORA CHOOSECOLOR,*LPCHOOSECOLOR;
typedef CHOOSEFONTA CHOOSEFONT,*LPCHOOSEFONT;
typedef FINDREPLACEA FINDREPLACE,*LPFINDREPLACE;
typedef OPENFILENAMEA OPENFILENAME,*LPOPENFILENAME;
typedef OFNOTIFYA OFNOTIFY,*LPOFNOTIFY;
typedef PAGESETUPDLGA PAGESETUPDLG,*LPPAGESETUPDLG;
typedef PRINTDLGA PRINTDLG,*LPPRINTDLG;
# 605 "C:/upp/mingw/include/commdlg.h" 3
#pragma pack(pop)

}
# 87 "C:/upp/mingw/include/windows.h" 2 3
# 1 "C:/upp/mingw/include/winspool.h" 1 3



       
# 5 "C:/upp/mingw/include/winspool.h" 3



extern "C" {
# 237 "C:/upp/mingw/include/winspool.h" 3
typedef struct _ADDJOB_INFO_1A {
 LPSTR Path;
 DWORD JobId;
} ADDJOB_INFO_1A,*PADDJOB_INFO_1A,*LPADDJOB_INFO_1A;
typedef struct _ADDJOB_INFO_1W {
 LPWSTR Path;
 DWORD JobId;
} ADDJOB_INFO_1W,*PADDJOB_INFO_1W,*LPADDJOB_INFO_1W;
typedef struct _DATATYPES_INFO_1A{LPSTR pName;} DATATYPES_INFO_1A,*PDATATYPES_INFO_1A,*LPDATATYPES_INFO_1A;
typedef struct _DATATYPES_INFO_1W{LPWSTR pName;} DATATYPES_INFO_1W,*PDATATYPES_INFO_1W,*LPDATATYPES_INFO_1W;
typedef struct _JOB_INFO_1A {
 DWORD JobId;
 LPSTR pPrinterName;
 LPSTR pMachineName;
 LPSTR pUserName;
 LPSTR pDocument;
 LPSTR pDatatype;
 LPSTR pStatus;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD TotalPages;
 DWORD PagesPrinted;
 SYSTEMTIME Submitted;
} JOB_INFO_1A,*PJOB_INFO_1A,*LPJOB_INFO_1A;
typedef struct _JOB_INFO_1W {
 DWORD JobId;
 LPWSTR pPrinterName;
 LPWSTR pMachineName;
 LPWSTR pUserName;
 LPWSTR pDocument;
 LPWSTR pDatatype;
 LPWSTR pStatus;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD TotalPages;
 DWORD PagesPrinted;
 SYSTEMTIME Submitted;
} JOB_INFO_1W,*PJOB_INFO_1W,*LPJOB_INFO_1W;
typedef struct _JOB_INFO_2A {
 DWORD JobId;
 LPSTR pPrinterName;
 LPSTR pMachineName;
 LPSTR pUserName;
 LPSTR pDocument;
 LPSTR pNotifyName;
 LPSTR pDatatype;
 LPSTR pPrintProcessor;
 LPSTR pParameters;
 LPSTR pDriverName;
 LPDEVMODEA pDevMode;
 LPSTR pStatus;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD TotalPages;
 DWORD Size;
 SYSTEMTIME Submitted;
 DWORD Time;
 DWORD PagesPrinted;
} JOB_INFO_2A,*PJOB_INFO_2A,*LPJOB_INFO_2A;
typedef struct _JOB_INFO_2W {
 DWORD JobId;
 LPWSTR pPrinterName;
 LPWSTR pMachineName;
 LPWSTR pUserName;
 LPWSTR pDocument;
 LPWSTR pNotifyName;
 LPWSTR pDatatype;
 LPWSTR pPrintProcessor;
 LPWSTR pParameters;
 LPWSTR pDriverName;
 LPDEVMODEW pDevMode;
 LPWSTR pStatus;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD TotalPages;
 DWORD Size;
 SYSTEMTIME Submitted;
 DWORD Time;
 DWORD PagesPrinted;
} JOB_INFO_2W,*PJOB_INFO_2W,*LPJOB_INFO_2W;
typedef struct _JOB_INFO_3 {
 DWORD JobId;
 DWORD NextJobId;
 DWORD Reserved;
} JOB_INFO_3,*PJOB_INFO_3,*LPJOB_INFO_3;
typedef struct _DOC_INFO_1A {
 LPSTR pDocName;
 LPSTR pOutputFile;
 LPSTR pDatatype;
} DOC_INFO_1A,*PDOC_INFO_1A,*LPDOC_INFO_1A;
typedef struct _DOC_INFO_1W {
 LPWSTR pDocName;
 LPWSTR pOutputFile;
 LPWSTR pDatatype;
} DOC_INFO_1W,*PDOC_INFO_1W,*LPDOC_INFO_1W;
typedef struct _DOC_INFO_2A {
 LPSTR pDocName;
 LPSTR pOutputFile;
 LPSTR pDatatype;
 DWORD dwMode;
 DWORD JobId;
} DOC_INFO_2A,*PDOC_INFO_2A,*LPDOC_INFO_2A;
typedef struct _DOC_INFO_2W {
 LPWSTR pDocName;
 LPWSTR pOutputFile;
 LPWSTR pDatatype;
 DWORD dwMode;
 DWORD JobId;
} DOC_INFO_2W,*PDOC_INFO_2W,*LPDOC_INFO_2W;
typedef struct _DRIVER_INFO_1A {LPSTR pName;} DRIVER_INFO_1A,*PDRIVER_INFO_1A,*LPDRIVER_INFO_1A;
typedef struct _DRIVER_INFO_1W {LPWSTR pName;} DRIVER_INFO_1W,*PDRIVER_INFO_1W,*LPDRIVER_INFO_1W;
typedef struct _DRIVER_INFO_2A {
 DWORD cVersion;
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDriverPath;
 LPSTR pDataFile;
 LPSTR pConfigFile;
} DRIVER_INFO_2A,*PDRIVER_INFO_2A,*LPDRIVER_INFO_2A;
typedef struct _DRIVER_INFO_2W {
 DWORD cVersion;
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDriverPath;
 LPWSTR pDataFile;
 LPWSTR pConfigFile;
} DRIVER_INFO_2W,*PDRIVER_INFO_2W,*LPDRIVER_INFO_2W;
typedef struct _DRIVER_INFO_3A {
 DWORD cVersion;
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDriverPath;
 LPSTR pDataFile;
 LPSTR pConfigFile;
 LPSTR pHelpFile;
 LPSTR pDependentFiles;
 LPSTR pMonitorName;
 LPSTR pDefaultDataType;
} DRIVER_INFO_3A,*PDRIVER_INFO_3A,*LPDRIVER_INFO_3A;
typedef struct _DRIVER_INFO_3W {
 DWORD cVersion;
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDriverPath;
 LPWSTR pDataFile;
 LPWSTR pConfigFile;
 LPWSTR pHelpFile;
 LPWSTR pDependentFiles;
 LPWSTR pMonitorName;
 LPWSTR pDefaultDataType;
} DRIVER_INFO_3W,*PDRIVER_INFO_3W,*LPDRIVER_INFO_3W;
# 486 "C:/upp/mingw/include/winspool.h" 3
typedef struct _MONITOR_INFO_1A{LPSTR pName;} MONITOR_INFO_1A,*PMONITOR_INFO_1A,*LPMONITOR_INFO_1A;
typedef struct _MONITOR_INFO_1W{LPWSTR pName;} MONITOR_INFO_1W,*PMONITOR_INFO_1W,*LPMONITOR_INFO_1W;
typedef struct _PORT_INFO_1A {LPSTR pName;} PORT_INFO_1A,*PPORT_INFO_1A,*LPPORT_INFO_1A;
typedef struct _PORT_INFO_1W {LPWSTR pName;} PORT_INFO_1W,*PPORT_INFO_1W,*LPPORT_INFO_1W;
typedef struct _MONITOR_INFO_2A{
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDLLName;
} MONITOR_INFO_2A,*PMONITOR_INFO_2A,*LPMONITOR_INFO_2A;
typedef struct _MONITOR_INFO_2W{
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDLLName;
} MONITOR_INFO_2W,*PMONITOR_INFO_2W,*LPMONITOR_INFO_2W;
typedef struct _PORT_INFO_2A {
 LPSTR pPortName;
 LPSTR pMonitorName;
 LPSTR pDescription;
 DWORD fPortType;
 DWORD Reserved;
} PORT_INFO_2A,*PPORT_INFO_2A,*LPPORT_INFO_2A;
typedef struct _PORT_INFO_2W {
 LPWSTR pPortName;
 LPWSTR pMonitorName;
 LPWSTR pDescription;
 DWORD fPortType;
 DWORD Reserved;
} PORT_INFO_2W,*PPORT_INFO_2W,*LPPORT_INFO_2W;
typedef struct _PORT_INFO_3A {
 DWORD dwStatus;
 LPSTR pszStatus;
 DWORD dwSeverity;
} PORT_INFO_3A,*PPORT_INFO_3A,*LPPORT_INFO_3A;
typedef struct _PORT_INFO_3W {
 DWORD dwStatus;
 LPWSTR pszStatus;
 DWORD dwSeverity;
} PORT_INFO_3W,*PPORT_INFO_3W,*LPPORT_INFO_3W;
# 540 "C:/upp/mingw/include/winspool.h" 3
typedef struct _PRINTER_INFO_1A {
 DWORD Flags;
 LPSTR pDescription;
 LPSTR pName;
 LPSTR pComment;
} PRINTER_INFO_1A,*PPRINTER_INFO_1A,*LPPRINTER_INFO_1A;
typedef struct _PRINTER_INFO_1W {
 DWORD Flags;
 LPWSTR pDescription;
 LPWSTR pName;
 LPWSTR pComment;
} PRINTER_INFO_1W,*PPRINTER_INFO_1W,*LPPRINTER_INFO_1W;
typedef struct _PRINTER_INFO_2A {
 LPSTR pServerName;
 LPSTR pPrinterName;
 LPSTR pShareName;
 LPSTR pPortName;
 LPSTR pDriverName;
 LPSTR pComment;
 LPSTR pLocation;
 LPDEVMODEA pDevMode;
 LPSTR pSepFile;
 LPSTR pPrintProcessor;
 LPSTR pDatatype;
 LPSTR pParameters;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Attributes;
 DWORD Priority;
 DWORD DefaultPriority;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD Status;
 DWORD cJobs;
 DWORD AveragePPM;
} PRINTER_INFO_2A,*PPRINTER_INFO_2A,*LPPRINTER_INFO_2A;
typedef struct _PRINTER_INFO_2W {
 LPWSTR pServerName;
 LPWSTR pPrinterName;
 LPWSTR pShareName;
 LPWSTR pPortName;
 LPWSTR pDriverName;
 LPWSTR pComment;
 LPWSTR pLocation;
 LPDEVMODEW pDevMode;
 LPWSTR pSepFile;
 LPWSTR pPrintProcessor;
 LPWSTR pDatatype;
 LPWSTR pParameters;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Attributes;
 DWORD Priority;
 DWORD DefaultPriority;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD Status;
 DWORD cJobs;
 DWORD AveragePPM;
} PRINTER_INFO_2W,*PPRINTER_INFO_2W,*LPPRINTER_INFO_2W;
typedef struct _PRINTER_INFO_3 {
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3,*PPRINTER_INFO_3,*LPPRINTER_INFO_3;
typedef struct _PRINTER_INFO_4A {
 LPSTR pPrinterName;
 LPSTR pServerName;
 DWORD Attributes;
} PRINTER_INFO_4A,*PPRINTER_INFO_4A,*LPPRINTER_INFO_4A;
typedef struct _PRINTER_INFO_4W {
 LPWSTR pPrinterName;
 LPWSTR pServerName;
 DWORD Attributes;
} PRINTER_INFO_4W,*PPRINTER_INFO_4W,*LPPRINTER_INFO_4W;
typedef struct _PRINTER_INFO_5A {
 LPSTR pPrinterName;
 LPSTR pPortName;
 DWORD Attributes;
 DWORD DeviceNotSelectedTimeout;
 DWORD TransmissionRetryTimeout;
} PRINTER_INFO_5A,*PPRINTER_INFO_5A,*LPPRINTER_INFO_5A;
typedef struct _PRINTER_INFO_5W {
 LPWSTR pPrinterName;
 LPWSTR pPortName;
 DWORD Attributes;
 DWORD DeviceNotSelectedTimeout;
 DWORD TransmissionRetryTimeout;
} PRINTER_INFO_5W,*PPRINTER_INFO_5W,*LPPRINTER_INFO_5W;
typedef struct _PRINTER_INFO_6 {
 DWORD dwStatus;
} PRINTER_INFO_6,*PPRINTER_INFO_6,*LPPRINTER_INFO_6;
# 644 "C:/upp/mingw/include/winspool.h" 3
typedef struct _PRINTPROCESSOR_INFO_1A {LPSTR pName;} PRINTPROCESSOR_INFO_1A,*PPRINTPROCESSOR_INFO_1A,*LPPRINTPROCESSOR_INFO_1A;
typedef struct _PRINTPROCESSOR_INFO_1W {LPWSTR pName;} PRINTPROCESSOR_INFO_1W,*PPRINTPROCESSOR_INFO_1W,*LPPRINTPROCESSOR_INFO_1W;
typedef struct _PRINTER_NOTIFY_INFO_DATA {
 WORD Type;
 WORD Field;
 DWORD Reserved;
 DWORD Id;
 union {
  DWORD adwData[2];
  struct {
   DWORD cbBuf;
   PVOID pBuf;
  } Data;
 } NotifyData;
} PRINTER_NOTIFY_INFO_DATA,*PPRINTER_NOTIFY_INFO_DATA,*LPPRINTER_NOTIFY_INFO_DATA;
typedef struct _PRINTER_NOTIFY_INFO {
 DWORD Version;
 DWORD Flags;
 DWORD Count;
 PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO,*PPRINTER_NOTIFY_INFO,*LPPRINTER_NOTIFY_INFO;
typedef struct _FORM_INFO_1A {
 DWORD Flags;
 LPSTR pName;
 SIZEL Size;
 RECTL ImageableArea;
} FORM_INFO_1A,*PFORM_INFO_1A,*LPFORM_INFO_1A;
typedef struct _FORM_INFO_1W {
 DWORD Flags;
 LPWSTR pName;
 SIZEL Size;
 RECTL ImageableArea;
} FORM_INFO_1W,*PFORM_INFO_1W,*LPFORM_INFO_1W;
typedef struct _PRINTER_DEFAULTSA {
 LPSTR pDatatype;
 LPDEVMODE pDevMode;
 ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA,*PPRINTER_DEFAULTSA,*LPPRINTER_DEFAULTSA;
typedef struct _PRINTER_DEFAULTSW {
 LPWSTR pDatatype;
 LPDEVMODE pDevMode;
 ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW,*PPRINTER_DEFAULTSW,*LPPRINTER_DEFAULTSW;
# 695 "C:/upp/mingw/include/winspool.h" 3
typedef struct _PROVIDOR_INFO_1A {
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDLLName;
} PROVIDOR_INFO_1A,*PPROVIDOR_INFO_1A,*LPPROVIDOR_INFO_1A;
typedef struct _PROVIDOR_INFO_1W {
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDLLName;
} PROVIDOR_INFO_1W,*PPROVIDOR_INFO_1W,*LPPROVIDOR_INFO_1W;
typedef struct _PROVIDOR_INFO_2A {
 LPSTR pOrder;
} PROVIDOR_INFO_2A,*PPROVIDOR_INFO_2A,*LPROVIDOR_INFO_2A;
typedef struct _PROVIDOR_INFO_2W {
 LPWSTR pOrder;
} PROVIDOR_INFO_2W,*PPROVIDOR_INFO_2W,*LPROVIDOR_INFO_2W;

BOOL __attribute__((__stdcall__)) AbortPrinter(HANDLE);
BOOL __attribute__((__stdcall__)) AddFormA(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddFormW(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddJobA(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) AddJobW(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) AddMonitorA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddMonitorW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) AddPortW(LPWSTR,HWND,LPWSTR);
HANDLE __attribute__((__stdcall__)) AddPrinterA(LPSTR,DWORD,PBYTE);
HANDLE __attribute__((__stdcall__)) AddPrinterW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrinterConnectionA(LPSTR);
BOOL __attribute__((__stdcall__)) AddPrinterConnectionW(LPWSTR);
BOOL __attribute__((__stdcall__)) AddPrinterDriverA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrinterDriverW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrintProcessorA(LPSTR,LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) AddPrintProcessorW(LPWSTR,LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) AddPrintProvidorA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrintProvidorW(LPWSTR,DWORD,PBYTE);
LONG __attribute__((__stdcall__)) AdvancedDocumentPropertiesA(HWND,HANDLE,LPSTR,PDEVMODE,PDEVMODEA);
LONG __attribute__((__stdcall__)) AdvancedDocumentPropertiesW(HWND,HANDLE,LPWSTR,PDEVMODE,PDEVMODEW);
BOOL __attribute__((__stdcall__)) ClosePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) ConfigurePortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) ConfigurePortW(LPWSTR,HWND,LPWSTR);
HANDLE __attribute__((__stdcall__)) ConnectToPrinterDlg(HWND,DWORD);
BOOL __attribute__((__stdcall__)) DeleteFormA(HANDLE,LPSTR);
BOOL __attribute__((__stdcall__)) DeleteFormW(HANDLE,LPWSTR);
BOOL __attribute__((__stdcall__)) DeleteMonitorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeleteMonitorW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePortW(LPWSTR,HWND,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) DeletePrinterConnectionA(LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterConnectionW(LPWSTR);
DWORD __attribute__((__stdcall__)) DeletePrinterDataA(HANDLE,LPSTR);
DWORD __attribute__((__stdcall__)) DeletePrinterDataW(HANDLE,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterDriverA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterDriverW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProcessorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProcessorW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProvidorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProvidorW(LPWSTR,LPWSTR,LPWSTR);
LONG __attribute__((__stdcall__)) DocumentPropertiesA(HWND,HANDLE,LPSTR,PDEVMODEA,PDEVMODEA,DWORD);
LONG __attribute__((__stdcall__)) DocumentPropertiesW(HWND,HANDLE,LPWSTR,PDEVMODEW,PDEVMODEW,DWORD);
BOOL __attribute__((__stdcall__)) EndDocPrinter(HANDLE);
BOOL __attribute__((__stdcall__)) EndPagePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) EnumFormsA(HANDLE,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumFormsW(HANDLE,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumJobsA(HANDLE,DWORD,DWORD,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumJobsW(HANDLE,DWORD,DWORD,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumMonitorsA(LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumMonitorsW(LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPortsA(LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPortsW(LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) EnumPrinterDataA(HANDLE,DWORD,LPSTR,DWORD,PDWORD,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) EnumPrinterDataW(HANDLE,DWORD,LPWSTR,DWORD,PDWORD,PDWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrinterDriversA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrinterDriversW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintersA(DWORD,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintersW(DWORD,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorDatatypesA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorDatatypesW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorsA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorsW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) FindClosePrinterChangeNotification(HANDLE);
HANDLE __attribute__((__stdcall__)) FindFirstPrinterChangeNotification(HANDLE,DWORD,DWORD,PVOID);
HANDLE __attribute__((__stdcall__)) FindNextPrinterChangeNotification(HANDLE,PDWORD,PVOID,PVOID*);
BOOL __attribute__((__stdcall__)) FreePrinterNotifyInfo(PPRINTER_NOTIFY_INFO);




BOOL __attribute__((__stdcall__)) GetFormA(HANDLE,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetFormW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetJobA(HANDLE,DWORD,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetJobW(HANDLE,DWORD,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetPrinterA(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetPrinterW(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDataA(HANDLE,LPSTR,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDataW(HANDLE,LPWSTR,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverA(HANDLE,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverDirectoryA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverDirectoryW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrintProcessorDirectoryA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrintProcessorDirectoryW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) OpenPrinterA(LPSTR,PHANDLE,LPPRINTER_DEFAULTSA);
BOOL __attribute__((__stdcall__)) OpenPrinterW(LPWSTR,PHANDLE,LPPRINTER_DEFAULTSW);
DWORD __attribute__((__stdcall__)) PrinterMessageBoxA(HANDLE,DWORD,HWND,LPSTR,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) PrinterMessageBoxW(HANDLE,DWORD,HWND,LPWSTR,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) PrinterProperties(HWND,HANDLE);
BOOL __attribute__((__stdcall__)) ReadPrinter(HANDLE,PVOID,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ResetPrinterA(HANDLE,LPPRINTER_DEFAULTSA);
BOOL __attribute__((__stdcall__)) ResetPrinterW(HANDLE,LPPRINTER_DEFAULTSW);
BOOL __attribute__((__stdcall__)) ScheduleJob(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) SetFormA(HANDLE,LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) SetFormW(HANDLE,LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) SetJobA(HANDLE,DWORD,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetJobW(HANDLE,DWORD,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterA(HANDLE,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterW(HANDLE,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterDataA(HANDLE,LPSTR,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterDataW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD);
DWORD __attribute__((__stdcall__)) StartDocPrinterA(HANDLE,DWORD,PBYTE);
DWORD __attribute__((__stdcall__)) StartDocPrinterW(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) StartPagePrinter(HANDLE);
DWORD __attribute__((__stdcall__)) WaitForPrinterChange(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) WritePrinter(HANDLE,PVOID,DWORD,PDWORD);
# 900 "C:/upp/mingw/include/winspool.h" 3
typedef JOB_INFO_1A JOB_INFO_1,*PJOB_INFO_1,*LPJOB_INFO_1;
typedef JOB_INFO_2A JOB_INFO_2,*PJOB_INFO_2,*LPJOB_INFO_2;
typedef ADDJOB_INFO_1A ADDJOB_INFO_1,*PADDJOB_INFO_1,*LPADDJOB_INFO_1;
typedef DATATYPES_INFO_1A DATATYPES_INFO_1,*PDATATYPES_INFO_1,*LPDATATYPES_INFO_1;
typedef MONITOR_INFO_1A MONITOR_INFO_1,*PMONITOR_INFO_1,*LPMONITOR_INFO_1;
typedef MONITOR_INFO_2A MONITOR_INFO_2,*PMONITOR_INFO_2,*LPMONITOR_INFO_2;
typedef DOC_INFO_1A DOC_INFO_1,*PDOC_INFO_1,*LPDOC_INFO_1;
typedef DOC_INFO_2A DOC_INFO_2,*PDOC_INFO_2,*LPDOC_INFO_2;
typedef PORT_INFO_1A PORT_INFO_1,*PPORT_INFO_1,*LPPORT_INFO_1;
typedef PORT_INFO_2A PORT_INFO_2,*PPORT_INFO_2,*LPPORT_INFO_2;
typedef PORT_INFO_3A PORT_INFO_3,*PPORT_INFO_3,*LPPORT_INFO_3;
typedef DRIVER_INFO_1A DRIVER_INFO_1,*PDRIVER_INFO_1,*LPDRIVER_INFO_1;
typedef DRIVER_INFO_2A DRIVER_INFO_2,*PDRIVER_INFO_2,*LPDRIVER_INFO_2;
typedef DRIVER_INFO_3A DRIVER_INFO_3,*PDRIVER_INFO_3,*LPDRIVER_INFO_3;






typedef PRINTER_INFO_1A PRINTER_INFO_1,*PPRINTER_INFO_1,*LPPRINTER_INFO_1;
typedef PRINTER_INFO_2A PRINTER_INFO_2,*PPRINTER_INFO_2,*LPPRINTER_INFO_2;
typedef PRINTER_INFO_4A PRINTER_INFO_4,*PPRINTER_INFO_4,*LPPRINTER_INFO_4;
typedef PRINTER_INFO_5A PRINTER_INFO_5,*PPRINTER_INFO_5,*LPPRINTER_INFO_5;



typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1,*PPRINTPROCESSOR_INFO_1,*LPPRINTPROCESSOR_INFO_1;
typedef FORM_INFO_1A FORM_INFO_1,*PFORM_INFO_1,*LPFORM_INFO_1;
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS,*PPRINTER_DEFAULTS,*LPPRINTER_DEFAULTS;
typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1,*PPROVIDOR_INFO_1,*LPROVIDOR_INFO_1;
typedef PROVIDOR_INFO_2A PROVIDOR_INFO_2,*PPROVIDOR_INFO_2,*LPROVIDOR_INFO_2;
# 980 "C:/upp/mingw/include/winspool.h" 3
}
# 88 "C:/upp/mingw/include/windows.h" 2 3
# 98 "C:/upp/mingw/include/windows.h" 3
# 1 "C:/upp/mingw/include/winsock2.h" 1 3
# 17 "C:/upp/mingw/include/winsock2.h" 3
       
# 18 "C:/upp/mingw/include/winsock2.h" 3
# 33 "C:/upp/mingw/include/winsock2.h" 3
extern "C" {




typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef u_int SOCKET;
# 61 "C:/upp/mingw/include/winsock2.h" 3
typedef struct fd_set {
 u_int fd_count;
 SOCKET fd_array[64];
} fd_set;
int __attribute__((__stdcall__)) __WSAFDIsSet(SOCKET,fd_set*);
# 109 "C:/upp/mingw/include/winsock2.h" 3
struct timeval {
 long tv_sec;
 long tv_usec;
};







struct hostent {
 char *h_name;
 char **h_aliases;
 short h_addrtype;
 short h_length;
 char **h_addr_list;

};
struct linger {
 u_short l_onoff;
 u_short l_linger;
};
# 155 "C:/upp/mingw/include/winsock2.h" 3
struct netent {
 char * n_name;
 char **n_aliases;
 short n_addrtype;
 u_long n_net;
};
struct servent {
 char *s_name;
 char **s_aliases;
 short s_port;
 char *s_proto;
};
struct protoent {
 char *p_name;
 char **p_aliases;
 short p_proto;
};
# 223 "C:/upp/mingw/include/winsock2.h" 3
struct in_addr {
 union {
  struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
  struct { u_short s_w1,s_w2; } S_un_w;
  u_long S_addr;
 } S_un;






};
# 254 "C:/upp/mingw/include/winsock2.h" 3
struct sockaddr_in {
 short sin_family;
 u_short sin_port;
 struct in_addr sin_addr;
 char sin_zero[8];
};


typedef struct WSAData {
 WORD wVersion;
 WORD wHighVersion;
 char szDescription[256 +1];
 char szSystemStatus[128 +1];
 unsigned short iMaxSockets;
 unsigned short iMaxUdpDg;
 char * lpVendorInfo;
} WSADATA;
typedef WSADATA *LPWSADATA;
# 336 "C:/upp/mingw/include/winsock2.h" 3
struct sockaddr {
 u_short sa_family;
 char sa_data[14];
};
# 356 "C:/upp/mingw/include/winsock2.h" 3
struct sockaddr_storage {
    short ss_family;
    char __ss_pad1[((sizeof (long long)) - sizeof (short))];
    long long __ss_align;
    char __ss_pad2[(128 - (sizeof (short) + ((sizeof (long long)) - sizeof (short)) + (sizeof (long long))))];
};


struct sockproto {
 u_short sp_family;
 u_short sp_protocol;
};
# 536 "C:/upp/mingw/include/winsock2.h" 3
 SOCKET __attribute__((__stdcall__)) accept(SOCKET,struct sockaddr*,int*);
 int __attribute__((__stdcall__)) bind(SOCKET,const struct sockaddr*,int);
 int __attribute__((__stdcall__)) closesocket(SOCKET);
 int __attribute__((__stdcall__)) connect(SOCKET,const struct sockaddr*,int);
 int __attribute__((__stdcall__)) ioctlsocket(SOCKET,long,u_long *);
 int __attribute__((__stdcall__)) getpeername(SOCKET,struct sockaddr*,int*);
 int __attribute__((__stdcall__)) getsockname(SOCKET,struct sockaddr*,int*);
 int __attribute__((__stdcall__)) getsockopt(SOCKET,int,int,char*,int*);
 unsigned long __attribute__((__stdcall__)) inet_addr(const char*);
 __attribute__((__stdcall__)) char * inet_ntoa(struct in_addr);
 int __attribute__((__stdcall__)) listen(SOCKET,int);
 int __attribute__((__stdcall__)) recv(SOCKET,char*,int,int);
 int __attribute__((__stdcall__)) recvfrom(SOCKET,char*,int,int,struct sockaddr*,int*);
 int __attribute__((__stdcall__)) send(SOCKET,const char*,int,int);
 int __attribute__((__stdcall__)) sendto(SOCKET,const char*,int,int,const struct sockaddr*,int);
 int __attribute__((__stdcall__)) setsockopt(SOCKET,int,int,const char*,int);
 int __attribute__((__stdcall__)) shutdown(SOCKET,int);
 SOCKET __attribute__((__stdcall__)) socket(int,int,int);
 __attribute__((__stdcall__)) struct hostent * gethostbyaddr(const char*,int,int);
 __attribute__((__stdcall__)) struct hostent * gethostbyname(const char*);
 __attribute__((__stdcall__)) struct servent * getservbyport(int,const char*);
 __attribute__((__stdcall__)) struct servent * getservbyname(const char*,const char*);
 __attribute__((__stdcall__)) struct protoent * getprotobynumber(int);
 __attribute__((__stdcall__)) struct protoent * getprotobyname(const char*);
typedef SOCKET (__attribute__((__stdcall__)) * LPFN_ACCEPT)(SOCKET, struct sockaddr*,int *);
typedef int (__attribute__((__stdcall__)) * LPFN_BIND)(SOCKET, const struct sockaddr*,int);
typedef int (__attribute__((__stdcall__)) * LPFN_CLOSESOCKET)(SOCKET);
typedef int (__attribute__((__stdcall__)) * LPFN_CONNECT)(SOCKET, const struct sockaddr*,int);
typedef int (__attribute__((__stdcall__)) * LPFN_IOCTLSOCKET)(SOCKET, long, u_long*);
typedef int (__attribute__((__stdcall__)) * LPFN_GETPEERNAME)(SOCKET, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETSOCKNAME)(SOCKET, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETSOCKOPT)(SOCKET, int, int, char*, int*);
typedef u_long(__attribute__((__stdcall__)) * LPFN_HTONL)(u_long);
typedef u_short(__attribute__((__stdcall__)) * LPFN_HTONS)(u_short);
typedef unsigned long(__attribute__((__stdcall__)) * LPFN_INET_ADDR)(const char*);
typedef char*(__attribute__((__stdcall__)) * LPFN_INET_NTOA)(struct in_addr);
typedef int(__attribute__((__stdcall__)) * LPFN_LISTEN)(SOCKET, int);
typedef u_long(__attribute__((__stdcall__)) * LPFN_NTOHL)(u_long);
typedef u_short(__attribute__((__stdcall__)) * LPFN_NTOHS)(u_short);
typedef int(__attribute__((__stdcall__)) * LPFN_RECV)(SOCKET, char*, int, int);
typedef int(__attribute__((__stdcall__)) * LPFN_RECVFROM)(SOCKET, char*, int, int, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_SELECT)(int, fd_set*, fd_set*, fd_set*, const struct timeval*);
typedef int(__attribute__((__stdcall__)) * LPFN_SEND)(SOCKET, const char*, int, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SENDTO)(SOCKET, const char*, int, int, const struct sockaddr*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SETSOCKOPT)(SOCKET, int, int, const char*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SHUTDOWN)(SOCKET, int);
typedef SOCKET(__attribute__((__stdcall__)) * LPFN_SOCKET)(int, int, int);
typedef struct hostent*(__attribute__((__stdcall__)) * LPFN_GETHOSTBYADDR)( const char*, int, int);
typedef struct hostent*(__attribute__((__stdcall__)) * LPFN_GETHOSTBYNAME)( const char*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETHOSTNAME)(char*, int);
typedef struct servent*(__attribute__((__stdcall__)) * LPFN_GETSERVBYPORT)(int, const char*);
typedef struct servent*(__attribute__((__stdcall__)) * LPFN_GETSERVBYNAME)(const char*, const char*);
typedef struct protoent*(__attribute__((__stdcall__)) * LPFN_GETPROTOBYNUMBER)(int);
typedef struct protoent*(__attribute__((__stdcall__)) * LPFN_GETPROTOBYNAME)(const char*);

 int __attribute__((__stdcall__)) WSAStartup(WORD,LPWSADATA);
 int __attribute__((__stdcall__)) WSACleanup(void);
 void __attribute__((__stdcall__)) WSASetLastError(int);
 int __attribute__((__stdcall__)) WSAGetLastError(void);
 typedef int(__attribute__((__stdcall__)) * LPFN_WSASTARTUP)(WORD, LPWSADATA);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACLEANUP)(void);
typedef void(__attribute__((__stdcall__)) * LPFN_WSASETLASTERROR)(int);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAGETLASTERROR)(void);




 BOOL __attribute__((__stdcall__)) WSAIsBlocking(void);
 int __attribute__((__stdcall__)) WSAUnhookBlockingHook(void);
 FARPROC __attribute__((__stdcall__)) WSASetBlockingHook(FARPROC);
 int __attribute__((__stdcall__)) WSACancelBlockingCall(void);
typedef BOOL(__attribute__((__stdcall__)) * LPFN_WSAISBLOCKING)(void);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAUNHOOKBLOCKINGHOOK)(void);
typedef FARPROC (__attribute__((__stdcall__)) * LPFN_WSASETBLOCKINGHOOK)(FARPROC);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACANCELBLOCKINGCALL)(void);

 HANDLE __attribute__((__stdcall__)) WSAAsyncGetServByName(HWND,u_int,const char*,const char*,char*,int);
 HANDLE __attribute__((__stdcall__)) WSAAsyncGetServByPort(HWND,u_int,int,const char*,char*,int);
 HANDLE __attribute__((__stdcall__)) WSAAsyncGetProtoByName(HWND,u_int,const char*,char*,int);
 HANDLE __attribute__((__stdcall__)) WSAAsyncGetProtoByNumber(HWND,u_int,int,char*,int);
 HANDLE __attribute__((__stdcall__)) WSAAsyncGetHostByName(HWND,u_int,const char*,char*,int);
 HANDLE __attribute__((__stdcall__)) WSAAsyncGetHostByAddr(HWND,u_int,const char*,int,int,char*,int);
 int __attribute__((__stdcall__)) WSACancelAsyncRequest(HANDLE);
 int __attribute__((__stdcall__)) WSAAsyncSelect(SOCKET,HWND,u_int,long);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETSERVBYNAME)(HWND, u_int, const char *, const char *, char *, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETSERVBYPORT)(HWND, u_int, int, const char *, char *, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETPROTOBYNAME)(HWND, u_int, const char*, char*, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETPROTOBYNUMBER)(HWND, u_int, int, char*, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETHOSTBYADDR)(HWND, u_int, const char*, int, int, char*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACANCELASYNCREQUEST)(HANDLE);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAASYNCSELECT)(SOCKET, HWND, u_int, long);

 u_long __attribute__((__stdcall__)) htonl(u_long);
 u_long __attribute__((__stdcall__)) ntohl(u_long);
 u_short __attribute__((__stdcall__)) htons(u_short);
 u_short __attribute__((__stdcall__)) ntohs(u_short);
 int __attribute__((__stdcall__)) select(int nfds,fd_set*,fd_set*,fd_set*,const struct timeval*);


int __attribute__((__stdcall__)) gethostname(char*,int);
# 644 "C:/upp/mingw/include/winsock2.h" 3
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr *LPSOCKADDR;
typedef struct sockaddr_storage SOCKADDR_STORAGE, *PSOCKADDR_STORAGE;
typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in *LPSOCKADDR_IN;
typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger *LPLINGER;
typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr *LPIN_ADDR;
typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set *LPFD_SET;
typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent *LPHOSTENT;
typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent *LPSERVENT;
typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent *LPPROTOENT;
typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval *LPTIMEVAL;
# 704 "C:/upp/mingw/include/winsock2.h" 3
typedef struct _OVERLAPPED *LPWSAOVERLAPPED;
# 721 "C:/upp/mingw/include/winsock2.h" 3
typedef struct _WSABUF {
 unsigned long len;
 char *buf;
} WSABUF, *LPWSABUF;

typedef enum
{
 BestEffortService,
 ControlledLoadService,
 PredictiveService,
 GuaranteedDelayService,
 GuaranteedService
} GUARANTEE;
# 745 "C:/upp/mingw/include/winsock2.h" 3
typedef unsigned int SERVICETYPE;
typedef struct _flowspec
{
 unsigned int TokenRate;
 unsigned int TokenBucketSize;
 unsigned int PeakBandwidth;
 unsigned int Latency;
 unsigned int DelayVariation;
 SERVICETYPE ServiceType;
 unsigned int MaxSduSize;
 unsigned int MinimumPolicedSize;
   } FLOWSPEC, *PFLOWSPEC, *LPFLOWSPEC;

typedef struct _QualityOfService
{
 FLOWSPEC SendingFlowspec;
 FLOWSPEC ReceivingFlowspec;
 WSABUF ProviderSpecific;
} QOS, *LPQOS;







typedef unsigned int GROUP;



typedef struct _WSANETWORKEVENTS {
 long lNetworkEvents;
 int iErrorCode[10];
} WSANETWORKEVENTS, *LPWSANETWORKEVENTS;






typedef enum _WSAESETSERVICEOP
{
 RNRSERVICE_REGISTER=0,
 RNRSERVICE_DEREGISTER,
 RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;

typedef struct _AFPROTOCOLS {
 INT iAddressFamily;
 INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;

typedef enum _WSAEcomparator
{
 COMP_EQUAL = 0,
 COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;

typedef struct _WSAVersion
{
 DWORD dwVersion;
 WSAECOMPARATOR ecHow;
} WSAVERSION, *PWSAVERSION, *LPWSAVERSION;



typedef struct _SOCKET_ADDRESS {
 LPSOCKADDR lpSockaddr;
 INT iSockaddrLength;
} SOCKET_ADDRESS,*PSOCKET_ADDRESS,*LPSOCKET_ADDRESS;
typedef struct _CSADDR_INFO {
 SOCKET_ADDRESS LocalAddr;
 SOCKET_ADDRESS RemoteAddr;
 INT iSocketType;
 INT iProtocol;
} CSADDR_INFO,*PCSADDR_INFO,*LPCSADDR_INFO;


typedef struct _SOCKET_ADDRESS_LIST {
    INT iAddressCount;
    SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, * LPSOCKET_ADDRESS_LIST;



typedef struct _BLOB {
 ULONG cbSize;
 BYTE *pBlobData;
} BLOB,*PBLOB,*LPBLOB;


typedef struct _WSAQuerySetA
{
 DWORD dwSize;
 LPSTR lpszServiceInstanceName;
 LPGUID lpServiceClassId;
 LPWSAVERSION lpVersion;
 LPSTR lpszComment;
 DWORD dwNameSpace;
 LPGUID lpNSProviderId;
 LPSTR lpszContext;
 DWORD dwNumberOfProtocols;
 LPAFPROTOCOLS lpafpProtocols;
 LPSTR lpszQueryString;
 DWORD dwNumberOfCsAddrs;
 LPCSADDR_INFO lpcsaBuffer;
 DWORD dwOutputFlags;
 LPBLOB lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;

typedef struct _WSAQuerySetW
{
 DWORD dwSize;
 LPWSTR lpszServiceInstanceName;
 LPGUID lpServiceClassId;
 LPWSAVERSION lpVersion;
 LPWSTR lpszComment;
 DWORD dwNameSpace;
 LPGUID lpNSProviderId;
 LPWSTR lpszContext;
 DWORD dwNumberOfProtocols;
 LPAFPROTOCOLS lpafpProtocols;
 LPWSTR lpszQueryString;
 DWORD dwNumberOfCsAddrs;
 LPCSADDR_INFO lpcsaBuffer;
 DWORD dwOutputFlags;
 LPBLOB lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;






typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
# 901 "C:/upp/mingw/include/winsock2.h" 3
typedef struct _WSANSClassInfoA
{
 LPSTR lpszName;
 DWORD dwNameSpace;
 DWORD dwValueType;
 DWORD dwValueSize;
 LPVOID lpValue;
} WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;

typedef struct _WSANSClassInfoW
{
 LPWSTR lpszName;
 DWORD dwNameSpace;
 DWORD dwValueType;
 DWORD dwValueSize;
 LPVOID lpValue;
} WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;






typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;


typedef struct _WSAServiceClassInfoA
{
 LPGUID lpServiceClassId;
 LPSTR lpszServiceClassName;
 DWORD dwCount;
 LPWSANSCLASSINFOA lpClassInfos;
} WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;

typedef struct _WSAServiceClassInfoW
{
 LPGUID lpServiceClassId;
 LPWSTR lpszServiceClassName;
 DWORD dwCount;
 LPWSANSCLASSINFOW lpClassInfos;
} WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;






typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;


typedef struct _WSANAMESPACE_INFOA {
 GUID NSProviderId;
 DWORD dwNameSpace;
 BOOL fActive;
 DWORD dwVersion;
 LPSTR lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;

typedef struct _WSANAMESPACE_INFOW {
 GUID NSProviderId;
 DWORD dwNameSpace;
 BOOL fActive;
 DWORD dwVersion;
 LPWSTR lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;






typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;


typedef struct _WSAPROTOCOLCHAIN {
 int ChainLen;
 DWORD ChainEntries[7];
} WSAPROTOCOLCHAIN, *LPWSAPROTOCOLCHAIN;



typedef struct _WSAPROTOCOL_INFOA {
 DWORD dwServiceFlags1;
 DWORD dwServiceFlags2;
 DWORD dwServiceFlags3;
 DWORD dwServiceFlags4;
 DWORD dwProviderFlags;
 GUID ProviderId;
 DWORD dwCatalogEntryId;
 WSAPROTOCOLCHAIN ProtocolChain;
 int iVersion;
 int iAddressFamily;
 int iMaxSockAddr;
 int iMinSockAddr;
 int iSocketType;
 int iProtocol;
 int iProtocolMaxOffset;
 int iNetworkByteOrder;
 int iSecurityScheme;
 DWORD dwMessageSize;
 DWORD dwProviderReserved;
 CHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOA, *LPWSAPROTOCOL_INFOA;

typedef struct _WSAPROTOCOL_INFOW {
 DWORD dwServiceFlags1;
 DWORD dwServiceFlags2;
 DWORD dwServiceFlags3;
 DWORD dwServiceFlags4;
 DWORD dwProviderFlags;
 GUID ProviderId;
 DWORD dwCatalogEntryId;
 WSAPROTOCOLCHAIN ProtocolChain;
 int iVersion;
 int iAddressFamily;
 int iMaxSockAddr;
 int iMinSockAddr;
 int iSocketType;
 int iProtocol;
 int iProtocolMaxOffset;
 int iNetworkByteOrder;
 int iSecurityScheme;
 DWORD dwMessageSize;
 DWORD dwProviderReserved;
 WCHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOW, * LPWSAPROTOCOL_INFOW;

typedef int (__attribute__((__stdcall__)) *LPCONDITIONPROC)(LPWSABUF, LPWSABUF, LPQOS, LPQOS, LPWSABUF, LPWSABUF, GROUP *, DWORD);
typedef void (__attribute__((__stdcall__)) *LPWSAOVERLAPPED_COMPLETION_ROUTINE)(DWORD, DWORD, LPWSAOVERLAPPED, DWORD);






typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;



typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC
} WSACOMPLETIONTYPE, * PWSACOMPLETIONTYPE, * LPWSACOMPLETIONTYPE;
typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, *LPWSACOMPLETION;
# 1146 "C:/upp/mingw/include/winsock2.h" 3
 SOCKET __attribute__((__stdcall__)) WSAAccept(SOCKET, struct sockaddr *, LPINT, LPCONDITIONPROC, DWORD);
 INT __attribute__((__stdcall__)) WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);
 INT __attribute__((__stdcall__)) WSAAddressToStringW(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
 BOOL __attribute__((__stdcall__)) WSACloseEvent(HANDLE);
 int __attribute__((__stdcall__)) WSAConnect(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
 HANDLE __attribute__((__stdcall__)) WSACreateEvent(void);
 int __attribute__((__stdcall__)) WSADuplicateSocketA(SOCKET, DWORD, LPWSAPROTOCOL_INFOA);
 int __attribute__((__stdcall__)) WSADuplicateSocketW(SOCKET, DWORD, LPWSAPROTOCOL_INFOW);
 INT __attribute__((__stdcall__)) WSAEnumNameSpaceProvidersA(LPDWORD, LPWSANAMESPACE_INFOA);
 INT __attribute__((__stdcall__)) WSAEnumNameSpaceProvidersW(LPDWORD, LPWSANAMESPACE_INFOW);
 int __attribute__((__stdcall__)) WSAEnumNetworkEvents(SOCKET, HANDLE, LPWSANETWORKEVENTS);
 int __attribute__((__stdcall__)) WSAEnumProtocolsA(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD);
 int __attribute__((__stdcall__)) WSAEnumProtocolsW(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD);
 int __attribute__((__stdcall__)) WSAEventSelect(SOCKET, HANDLE, long);
 BOOL __attribute__((__stdcall__)) WSAGetOverlappedResult(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD);
 BOOL __attribute__((__stdcall__)) WSAGetQOSByName(SOCKET, LPWSABUF, LPQOS);
 INT __attribute__((__stdcall__)) WSAGetServiceClassInfoA(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA);
 INT __attribute__((__stdcall__)) WSAGetServiceClassInfoW(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW);
 INT __attribute__((__stdcall__)) WSAGetServiceClassNameByClassIdA(LPGUID, LPSTR, LPDWORD);
 INT __attribute__((__stdcall__)) WSAGetServiceClassNameByClassIdW(LPGUID, LPWSTR, LPDWORD);
 int __attribute__((__stdcall__)) WSAHtonl(SOCKET, unsigned long, unsigned long *);
 int __attribute__((__stdcall__)) WSAHtons(SOCKET, unsigned short, unsigned short *);
 INT __attribute__((__stdcall__)) WSAInstallServiceClassA(LPWSASERVICECLASSINFOA);
 INT __attribute__((__stdcall__)) WSAInstallServiceClassW(LPWSASERVICECLASSINFOW);
 int __attribute__((__stdcall__)) WSAIoctl(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
 SOCKET __attribute__((__stdcall__)) WSAJoinLeaf(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
 INT __attribute__((__stdcall__)) WSALookupServiceBeginA(LPWSAQUERYSETA, DWORD, LPHANDLE);
 INT __attribute__((__stdcall__)) WSALookupServiceBeginW(LPWSAQUERYSETW lpqsRestrictions, DWORD, LPHANDLE);
 INT __attribute__((__stdcall__)) WSALookupServiceNextA(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA);
 INT __attribute__((__stdcall__)) WSALookupServiceNextW(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW);
 INT __attribute__((__stdcall__)) WSALookupServiceEnd(HANDLE);
 int __attribute__((__stdcall__)) WSANSPIoctl(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPWSACOMPLETION);
 int __attribute__((__stdcall__)) WSANtohl(SOCKET, unsigned long, unsigned long *);
 int __attribute__((__stdcall__)) WSANtohs(SOCKET, unsigned short, unsigned short *);
 int __attribute__((__stdcall__)) WSARecv(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
 int __attribute__((__stdcall__)) WSARecvDisconnect(SOCKET, LPWSABUF);
 int __attribute__((__stdcall__)) WSARecvFrom(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
 INT __attribute__((__stdcall__)) WSARemoveServiceClass(LPGUID);
 BOOL __attribute__((__stdcall__)) WSAResetEvent(HANDLE);
 int __attribute__((__stdcall__)) WSASend(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
 int __attribute__((__stdcall__)) WSASendDisconnect(SOCKET, LPWSABUF);
 int __attribute__((__stdcall__)) WSASendTo(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const struct sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) WSASetEvent(HANDLE);
 INT __attribute__((__stdcall__)) WSASetServiceA(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD);
 INT __attribute__((__stdcall__)) WSASetServiceW(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD);
 SOCKET __attribute__((__stdcall__)) WSASocketA(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD);
 SOCKET __attribute__((__stdcall__)) WSASocketW(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD);
 INT __attribute__((__stdcall__)) WSAStringToAddressA(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT);
 INT __attribute__((__stdcall__)) WSAStringToAddressW(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT);
 DWORD __attribute__((__stdcall__)) WSAWaitForMultipleEvents(DWORD, const HANDLE *, BOOL, DWORD, BOOL);

typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSAACCEPT)(SOCKET, struct sockaddr *, LPINT, LPCONDITIONPROC, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAADDRESSTOSTRINGA)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAADDRESSTOSTRINGW)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSACLOSEEVENT)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSACONNECT)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
typedef HANDLE (__attribute__((__stdcall__)) *LPFN_WSACREATEEVENT)(void);
typedef int (__attribute__((__stdcall__)) *LPFN_WSADUPLICATESOCKETA)(SOCKET, DWORD, LPWSAPROTOCOL_INFOA);
typedef int (__attribute__((__stdcall__)) *LPFN_WSADUPLICATESOCKETW)(SOCKET, DWORD, LPWSAPROTOCOL_INFOW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAENUMNAMESPACEPROVIDERSA)(LPDWORD, LPWSANAMESPACE_INFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAENUMNAMESPACEPROVIDERSW)(LPDWORD, LPWSANAMESPACE_INFOW);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMNETWORKEVENTS)(SOCKET, HANDLE, LPWSANETWORKEVENTS);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMPROTOCOLSA)(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMPROTOCOLSW)(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAEVENTSELECT)(SOCKET, HANDLE, long);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSAGETOVERLAPPEDRESULT)(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSAGETQOSBYNAME)(SOCKET, LPWSABUF, LPQOS);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSINFOA)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSINFOW)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA)(LPGUID, LPSTR, LPDWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW)(LPGUID, LPWSTR, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAHTONL)(SOCKET, unsigned long, unsigned long *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAHTONS)(SOCKET, unsigned short, unsigned short *);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAINSTALLSERVICECLASSA)(LPWSASERVICECLASSINFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAINSTALLSERVICECLASSW)(LPWSASERVICECLASSINFOW);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAIOCTL)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSAJOINLEAF)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEBEGINA)(LPWSAQUERYSETA, DWORD, LPHANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEBEGINW)(LPWSAQUERYSETW, DWORD, LPHANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICENEXTA)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICENEXTW)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEEND)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANSPIoctl)(HANDLE, DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPWSACOMPLETION);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANTOHL)(SOCKET, unsigned long, unsigned long *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANTOHS)(SOCKET, unsigned short, unsigned short *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECV)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECVDISCONNECT)(SOCKET, LPWSABUF);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECVFROM)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAREMOVESERVICECLASS)(LPGUID);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSARESETEVENT)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASEND)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASENDDISCONNECT)(SOCKET, LPWSABUF);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASENDTO)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const struct sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSASETEVENT)(HANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASETSERVICEA)(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASETSERVICEW)(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSASOCKETA)(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSASOCKETW)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASTRINGTOADDRESSA)(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASTRINGTOADDRESSW)(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT);
typedef DWORD (__attribute__((__stdcall__)) *LPFN_WSAWAITFORMULTIPLEEVENTS)(DWORD, const HANDLE *, BOOL, DWORD, BOOL);
# 1301 "C:/upp/mingw/include/winsock2.h" 3
}
# 99 "C:/upp/mingw/include/windows.h" 2 3
# 114 "C:/upp/mingw/include/windows.h" 3
# 1 "C:/upp/mingw/include/ole2.h" 1 3



       
# 5 "C:/upp/mingw/include/ole2.h" 3


#pragma pack(push,8)

# 1 "C:/upp/mingw/include/objbase.h" 1 3


# 1 "C:/upp/mingw/include/rpc.h" 1 3
# 4 "C:/upp/mingw/include/objbase.h" 2 3
# 1 "C:/upp/mingw/include/rpcndr.h" 1 3




       
# 6 "C:/upp/mingw/include/rpcndr.h" 3





# 1 "C:/upp/mingw/include/rpcnsip.h" 1 3



       
# 5 "C:/upp/mingw/include/rpcnsip.h" 3



extern "C" {

typedef struct {
 RPC_NS_HANDLE LookupContext;
 RPC_BINDING_HANDLE ProposedHandle;
 RPC_BINDING_VECTOR *Bindings;
} RPC_IMPORT_CONTEXT_P,*PRPC_IMPORT_CONTEXT_P;
RPC_STATUS __attribute__((__stdcall__)) I_RpcNsGetBuffer( PRPC_MESSAGE);
RPC_STATUS __attribute__((__stdcall__)) I_RpcNsSendReceive( PRPC_MESSAGE, RPC_BINDING_HANDLE*);
void __attribute__((__stdcall__)) I_RpcNsRaiseException( PRPC_MESSAGE, RPC_STATUS);
RPC_STATUS __attribute__((__stdcall__)) I_RpcReBindBuffer( PRPC_MESSAGE);
RPC_STATUS __attribute__((__stdcall__)) I_NsServerBindSearch(void);
RPC_STATUS __attribute__((__stdcall__)) I_NsClientBindSearch(void);
void __attribute__((__stdcall__)) I_NsClientBindDone(void);

}
# 12 "C:/upp/mingw/include/rpcndr.h" 2 3

extern "C" {

# 1 "C:/upp/mingw/include/objfwd.h" 1 3



       
# 5 "C:/upp/mingw/include/objfwd.h" 3





extern "C" {

typedef struct IMoniker *LPMONIKER;
typedef struct IStream *LPSTREAM;
typedef struct IMarshal *LPMARSHAL;
typedef struct IMalloc *LPMALLOC;
typedef struct IMallocSpy *LPMALLOCSPY;
typedef struct IMessageFilter *LPMESSAGEFILTER;
typedef struct IPersist *LPPERSIST;
typedef struct IPersistStream *LPPERSISTSTREAM;
typedef struct IRunningObjectTable *LPRUNNINGOBJECTTABLE;
typedef struct IBindCtx *LPBINDCTX,*LPBC;
typedef struct IAdviseSink *LPADVISESINK;
typedef struct IAdviseSink2 *LPADVISESINK2;
typedef struct IDataObject *LPDATAOBJECT;
typedef struct IDataAdviseHolder *LPDATAADVISEHOLDER;
typedef struct IEnumMoniker *LPENUMMONIKER;
typedef struct IEnumFORMATETC *LPENUMFORMATETC;
typedef struct IEnumSTATDATA *LPENUMSTATDATA;
typedef struct IEnumSTATSTG *LPENUMSTATSTG;
typedef struct IEnumSTATPROPSTG LPENUMSTATPROPSTG;
typedef struct IEnumString *LPENUMSTRING;
typedef struct IEnumUnknown *LPENUMUNKNOWN;
typedef struct IStorage *LPSTORAGE;
typedef struct IPersistStorage *LPPERSISTSTORAGE;
typedef struct ILockBytes *LPLOCKBYTES;
typedef struct IStdMarshalInfo *LPSTDMARSHALINFO;
typedef struct IExternalConnection *LPEXTERNALCONNECTION;
typedef struct IRunnableObject *LPRUNNABLEOBJECT;
typedef struct IROTData *LPROTDATA;
typedef struct IPersistFile *LPPERSISTFILE;
typedef struct IRootStorage *LPROOTSTORAGE;
typedef struct IRpcChannelBuffer *LPRPCCHANNELBUFFER;
typedef struct IRpcProxyBuffer *LPRPCPROXYBUFFER;
typedef struct IRpcStubBuffer *LPRPCSTUBBUFFER;
typedef struct IPropertyStorage *LPPROPERTYSTORAGE;
typedef struct IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG;
typedef struct IPropertySetStorage *LPPROPERTYSETSTORAGE;
typedef struct IClientSecurity *LPCLIENTSECURITY;
typedef struct IServerSecurity *LPSERVERSECURITY;
typedef struct IClassActivator *LPCLASSACTIVATOR;
typedef struct IFillLockBytes *LPFILLLOCKBYTES;
typedef struct IProgressNotify *LPPROGRESSNOTIFY;
typedef struct ILayoutStorage *LPLAYOUTSTORAGE;

}
# 16 "C:/upp/mingw/include/rpcndr.h" 2 3
# 51 "C:/upp/mingw/include/rpcndr.h" 3
typedef unsigned char byte;
typedef unsigned char boolean;
# 96 "C:/upp/mingw/include/rpcndr.h" 3
typedef void *NDR_CCONTEXT;
typedef struct {
 void *pad[2];
 void *userContext;
} *NDR_SCONTEXT;
typedef void (__attribute__((__stdcall__)) *NDR_RUNDOWN)(void*);
typedef struct _SCONTEXT_QUEUE {
 unsigned long NumberOfObjects;
 NDR_SCONTEXT *ArrayOfObjects;
} SCONTEXT_QUEUE,*PSCONTEXT_QUEUE;
struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;
typedef unsigned char *RPC_BUFPTR;
typedef unsigned long RPC_LENGTH;
typedef void(__attribute__((__stdcall__)) *EXPR_EVAL)(struct _MIDL_STUB_MESSAGE*);
typedef const unsigned char *PFORMAT_STRING;
typedef struct {
 long Dimension;
 unsigned long *BufferConformanceMark;
 unsigned long *BufferVarianceMark;
 unsigned long *MaxCountArray;
 unsigned long *OffsetArray;
 unsigned long *ActualCountArray;
} ARRAY_INFO,*PARRAY_INFO;

RPC_BINDING_HANDLE __attribute__((__stdcall__)) NDRCContextBinding(NDR_CCONTEXT);
void __attribute__((__stdcall__)) NDRCContextMarshall(NDR_CCONTEXT,void*);
void __attribute__((__stdcall__)) NDRCContextUnmarshall(NDR_CCONTEXT*,RPC_BINDING_HANDLE,void*,unsigned long);
void __attribute__((__stdcall__)) NDRSContextMarshall(NDR_SCONTEXT,void*,NDR_RUNDOWN);
NDR_SCONTEXT __attribute__((__stdcall__)) NDRSContextUnmarshall(void*pBuff,unsigned long);
void __attribute__((__stdcall__)) RpcSsDestroyClientContext(void**);
void __attribute__((__stdcall__)) NDRcopy(void*,void*,unsigned int);
unsigned int __attribute__((__stdcall__)) MIDL_wchar_strlen(wchar_t*);
void __attribute__((__stdcall__)) MIDL_wchar_strcpy(void*,wchar_t*);
void __attribute__((__stdcall__)) char_from_ndr(PRPC_MESSAGE,unsigned char*);
void __attribute__((__stdcall__)) char_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned char*);
void __attribute__((__stdcall__)) short_from_ndr(PRPC_MESSAGE,unsigned short*);
void __attribute__((__stdcall__)) short_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned short*);
void __attribute__((__stdcall__)) short_from_ndr_temp(unsigned char**,unsigned short*,unsigned long);
void __attribute__((__stdcall__)) long_from_ndr(PRPC_MESSAGE,unsigned long*);
void __attribute__((__stdcall__)) long_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned long*);
void __attribute__((__stdcall__)) long_from_ndr_temp(unsigned char**,unsigned long*,unsigned long);
void __attribute__((__stdcall__)) enum_from_ndr(PRPC_MESSAGE,unsigned int*);
void __attribute__((__stdcall__)) float_from_ndr(PRPC_MESSAGE,void*);
void __attribute__((__stdcall__)) float_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,void*);
void __attribute__((__stdcall__)) double_from_ndr(PRPC_MESSAGE,void*);
void __attribute__((__stdcall__)) double_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,void*);
void __attribute__((__stdcall__)) hyper_from_ndr(PRPC_MESSAGE,long long*);
void __attribute__((__stdcall__)) hyper_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,long long*);
void __attribute__((__stdcall__)) hyper_from_ndr_temp(unsigned char**,long long*,unsigned long);
void __attribute__((__stdcall__)) data_from_ndr(PRPC_MESSAGE,void*,char*,unsigned char);
void __attribute__((__stdcall__)) data_into_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_into_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) data_size_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_size_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_peek_ndr(PRPC_MESSAGE,unsigned char**,char*,unsigned char);
void *__attribute__((__stdcall__)) midl_allocate(int);

#pragma pack(push,4)
typedef struct _MIDL_STUB_MESSAGE {
 PRPC_MESSAGE RpcMsg;
 unsigned char *Buffer;
 unsigned char *BufferStart;
 unsigned char *BufferEnd;
 unsigned char *BufferMark;
 unsigned long BufferLength;
 unsigned long MemorySize;
 unsigned char *Memory;
 int IsClient;
 int ReuseBuffer;
 unsigned char *AllocAllNodesMemory;
 unsigned char *AllocAllNodesMemoryEnd;
 int IgnoreEmbeddedPointers;
 unsigned char *PointerBufferMark;
 unsigned char fBufferValid;
 unsigned char Unused;
 unsigned long MaxCount;
 unsigned long Offset;
 unsigned long ActualCount;
 void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
 void(__attribute__((__stdcall__)) *pfnFree)(void*);
 unsigned char *StackTop;
 unsigned char *pPresentedType;
 unsigned char *pTransmitType;
 handle_t SavedHandle;
 const struct _MIDL_STUB_DESC *StubDesc;
 struct _FULL_PTR_XLAT_TABLES *FullPtrXlatTables;
 unsigned long FullPtrRefId;
 int fCheckBounds;
 int fInDontFree :1;
 int fDontCallFreeInst :1;
 int fInOnlyParam :1;
 int fHasReturn :1;
 unsigned long dwDestContext;
 void*pvDestContext;
 NDR_SCONTEXT *SavedContextHandles;
 long ParamNumber;
 struct IRpcChannelBuffer *pRpcChannelBuffer;
 PARRAY_INFO pArrayInfo;
 unsigned long *SizePtrCountArray;
 unsigned long *SizePtrOffsetArray;
 unsigned long *SizePtrLengthArray;
 void*pArgQueue;
 unsigned long dwStubPhase;
 unsigned long w2kReserved[5];
} MIDL_STUB_MESSAGE,*PMIDL_STUB_MESSAGE;
#pragma pack(pop)
typedef void*(__attribute__((__stdcall__)) *GENERIC_BINDING_ROUTINE)(void*);
typedef void (__attribute__((__stdcall__)) *GENERIC_UNBIND_ROUTINE)(void*,unsigned char*);
typedef struct _GENERIC_BINDING_ROUTINE_PAIR {
 GENERIC_BINDING_ROUTINE pfnBind;
 GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_ROUTINE_PAIR,*PGENERIC_BINDING_ROUTINE_PAIR;
typedef struct __GENERIC_BINDING_INFO {
 void *pObj;
 unsigned int Size;
 GENERIC_BINDING_ROUTINE pfnBind;
 GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_INFO,*PGENERIC_BINDING_INFO;
typedef void(__attribute__((__stdcall__)) *XMIT_HELPER_ROUTINE)(PMIDL_STUB_MESSAGE);
typedef struct _XMIT_ROUTINE_QUINTUPLE {
 XMIT_HELPER_ROUTINE pfnTranslateToXmit;
 XMIT_HELPER_ROUTINE pfnTranslateFromXmit;
 XMIT_HELPER_ROUTINE pfnFreeXmit;
 XMIT_HELPER_ROUTINE pfnFreeInst;
} XMIT_ROUTINE_QUINTUPLE,*PXMIT_ROUTINE_QUINTUPLE;
typedef struct _MALLOC_FREE_STRUCT {
void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
void(__attribute__((__stdcall__)) *pfnFree)(void*);
} MALLOC_FREE_STRUCT;
typedef struct _COMM_FAULT_OFFSETS {
 short CommOffset;
 short FaultOffset;
} COMM_FAULT_OFFSETS;
typedef unsigned long (__attribute__((__stdcall__)) *USER_MARSHAL_SIZING_ROUTINE)(unsigned long *,unsigned long,void *);
typedef unsigned char *(__attribute__((__stdcall__)) *USER_MARSHAL_MARSHALLING_ROUTINE)(unsigned long *,unsigned char *,void *);
typedef unsigned char *(__attribute__((__stdcall__)) *USER_MARSHAL_UNMARSHALLING_ROUTINE)(unsigned long *,unsigned char *,void *);
typedef void (__attribute__((__stdcall__)) *USER_MARSHAL_FREEING_ROUTINE)(unsigned long *,void *);
typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
 USER_MARSHAL_SIZING_ROUTINE pfnBufferSize;
 USER_MARSHAL_MARSHALLING_ROUTINE pfnMarshall;
 USER_MARSHAL_UNMARSHALLING_ROUTINE pfnUnmarshall;
 USER_MARSHAL_FREEING_ROUTINE pfnFree;
} USER_MARSHAL_ROUTINE_QUADRUPLE;
typedef void (__attribute__((__stdcall__)) *NDR_NOTIFY_ROUTINE)(void);
typedef enum _IDL_CS_CONVERT {
 IDL_CS_NO_CONVERT,
 IDL_CS_IN_PLACE_CONVERT,
 IDL_CS_NEW_BUFFER_CONVERT
} IDL_CS_CONVERT;
typedef void (__attribute__((__stdcall__)) *CS_TYPE_NET_SIZE_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,unsigned long,IDL_CS_CONVERT*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_LOCAL_SIZE_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,unsigned long,IDL_CS_CONVERT*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_TO_NETCS_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,void*,unsigned long,byte*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_FROM_NETCS_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,byte*,unsigned long,unsigned long,void*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TAG_GETTING_ROUTINE)(RPC_BINDING_HANDLE,int,unsigned long*,unsigned long*,unsigned long*,error_status_t*);
typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES {
 CS_TYPE_NET_SIZE_ROUTINE pfnNetSize;
 CS_TYPE_TO_NETCS_ROUTINE pfnToNetCs;
 CS_TYPE_LOCAL_SIZE_ROUTINE pfnLocalSize;
 CS_TYPE_FROM_NETCS_ROUTINE pfnFromNetCs;
} NDR_CS_SIZE_CONVERT_ROUTINES;
typedef struct _NDR_CS_ROUTINES {
 NDR_CS_SIZE_CONVERT_ROUTINES *pSizeConvertRoutines;
 CS_TAG_GETTING_ROUTINE *pTagGettingRoutines;
} NDR_CS_ROUTINES;
typedef struct _MIDL_STUB_DESC {
 void*RpcInterfaceInformation;
 void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
 void(__attribute__((__stdcall__)) *pfnFree)(void*);
 union {
  handle_t *pAutoHandle;
  handle_t *pPrimitiveHandle;
  PGENERIC_BINDING_INFO pGenericBindingInfo;
 } IMPLICIT_HANDLE_INFO;
 const NDR_RUNDOWN *apfnNdrRundownRoutines;
 const GENERIC_BINDING_ROUTINE_PAIR *aGenericBindingRoutinePairs;
 const EXPR_EVAL *apfnExprEval;
 const XMIT_ROUTINE_QUINTUPLE *aXmitQuintuple;
 const unsigned char *pFormatTypes;
 int fCheckBounds;
 unsigned long Version;
 MALLOC_FREE_STRUCT *pMallocFreeStruct;
 long MIDLVersion;
 const COMM_FAULT_OFFSETS *CommFaultOffsets;
 const USER_MARSHAL_ROUTINE_QUADRUPLE *aUserMarshalQuadruple;
 const NDR_NOTIFY_ROUTINE *NotifyRoutineTable;
 ULONG_PTR mFlags;
 const NDR_CS_ROUTINES *CsRoutineTables;
 void *Reserved4;
 ULONG_PTR Reserved5;
} MIDL_STUB_DESC;
typedef const MIDL_STUB_DESC *PMIDL_STUB_DESC;
typedef void*PMIDL_XMIT_TYPE;
typedef struct _MIDL_FORMAT_STRING {
 short Pad;
 unsigned char Format[1];
} MIDL_FORMAT_STRING;
typedef void(__attribute__((__stdcall__)) *STUB_THUNK)(PMIDL_STUB_MESSAGE);
typedef long(__attribute__((__stdcall__)) *SERVER_ROUTINE)(void);
typedef struct _MIDL_SERVER_INFO_ {
 PMIDL_STUB_DESC pStubDesc;
 const SERVER_ROUTINE *DispatchTable;
 PFORMAT_STRING ProcString;
 const unsigned short *FmtStringOffset;
 const STUB_THUNK *ThunkTable;
} MIDL_SERVER_INFO,*PMIDL_SERVER_INFO;
typedef struct _MIDL_STUBLESS_PROXY_INFO {
 PMIDL_STUB_DESC pStubDesc;
 PFORMAT_STRING ProcFormatString;
 const unsigned short *FormatStringOffset;
} MIDL_STUBLESS_PROXY_INFO;
typedef MIDL_STUBLESS_PROXY_INFO *PMIDL_STUBLESS_PROXY_INFO;
typedef union _CLIENT_CALL_RETURN {
 void *Pointer;
 long Simple;
} CLIENT_CALL_RETURN;
typedef enum { XLAT_SERVER = 1,XLAT_CLIENT } XLAT_SIDE;
typedef struct _FULL_PTR_TO_REFID_ELEMENT {
 struct _FULL_PTR_TO_REFID_ELEMENT *Next;
 void*Pointer;
 unsigned long RefId;
 unsigned char State;
} FULL_PTR_TO_REFID_ELEMENT,*PFULL_PTR_TO_REFID_ELEMENT;
typedef struct _FULL_PTR_XLAT_TABLES {
 struct {
  void **XlatTable;
  unsigned char *StateTable;
  unsigned long NumberOfEntries;
 } RefIdToPointer;
 struct {
  PFULL_PTR_TO_REFID_ELEMENT *XlatTable;
  unsigned long NumberOfBuckets;
  unsigned long HashMask;
 } PointerToRefId;
 unsigned long NextRefId;
 XLAT_SIDE XlatSide;
} FULL_PTR_XLAT_TABLES,*PFULL_PTR_XLAT_TABLES;
void __attribute__((__stdcall__)) NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrPointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING pFormat);
unsigned char *__attribute__((__stdcall__)) NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrHardStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrComplexStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantStringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrClientContextMarshall(PMIDL_STUB_MESSAGE,NDR_CCONTEXT,int);
void __attribute__((__stdcall__)) NdrServerContextMarshall(PMIDL_STUB_MESSAGE,NDR_SCONTEXT,NDR_RUNDOWN);
void __attribute__((__stdcall__)) NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrPointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrHardStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
void __attribute__((__stdcall__)) NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE,NDR_CCONTEXT*,RPC_BINDING_HANDLE);
NDR_SCONTEXT __attribute__((__stdcall__)) NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrPointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrHardStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrContextHandleSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrPointerMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrHardStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrPointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrSimpleStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrHardStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrFixedArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrVaryingArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrByteCountPointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrInterfacePointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConvert(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrClientInitializeNew(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,unsigned int);
unsigned char *__attribute__((__stdcall__)) NdrServerInitializeNew(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC);
void __attribute__((__stdcall__)) NdrClientInitialize(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,unsigned int);
unsigned char *__attribute__((__stdcall__)) NdrServerInitialize(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC);
unsigned char *__attribute__((__stdcall__)) NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,PRPC_MESSAGE);
void __attribute__((__stdcall__)) NdrServerInitializeMarshall(PRPC_MESSAGE,PMIDL_STUB_MESSAGE);
unsigned char *__attribute__((__stdcall__)) NdrGetBuffer(PMIDL_STUB_MESSAGE,unsigned long,RPC_BINDING_HANDLE);
unsigned char *__attribute__((__stdcall__)) NdrNsGetBuffer(PMIDL_STUB_MESSAGE,unsigned long,RPC_BINDING_HANDLE);
unsigned char *__attribute__((__stdcall__)) NdrSendReceive(PMIDL_STUB_MESSAGE,unsigned char*);
unsigned char *__attribute__((__stdcall__)) NdrNsSendReceive(PMIDL_STUB_MESSAGE,unsigned char*,RPC_BINDING_HANDLE*);
void __attribute__((__stdcall__)) NdrFreeBuffer(PMIDL_STUB_MESSAGE);
CLIENT_CALL_RETURN __attribute__((__cdecl__)) NdrClientCall(PMIDL_STUB_DESC,PFORMAT_STRING,...);
CLIENT_CALL_RETURN __attribute__((__cdecl__)) NdrClientCall2(PMIDL_STUB_DESC,PFORMAT_STRING,...);
typedef enum {
 STUB_UNMARSHAL,
 STUB_CALL_SERVER,
 STUB_MARSHAL,
 STUB_CALL_SERVER_NO_HRESULT
} STUB_PHASE;
typedef enum {
 PROXY_CALCSIZE,
 PROXY_GETBUFFER,
 PROXY_MARSHAL,
 PROXY_SENDRECEIVE,
 PROXY_UNMARSHAL
} PROXY_PHASE;
long __attribute__((__stdcall__)) NdrStubCall(struct IRpcStubBuffer*,struct IRpcChannelBuffer*,PRPC_MESSAGE,unsigned long*);
void __attribute__((__stdcall__)) NdrServerCall(PRPC_MESSAGE);
int __attribute__((__stdcall__)) NdrServerUnmarshall(struct IRpcChannelBuffer*,PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,PFORMAT_STRING,void*);
void __attribute__((__stdcall__)) NdrServerMarshall(struct IRpcStubBuffer*,struct IRpcChannelBuffer*,PMIDL_STUB_MESSAGE,PFORMAT_STRING);
RPC_STATUS __attribute__((__stdcall__)) NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE,unsigned long*,unsigned long*,RPC_STATUS);
int __attribute__((__stdcall__)) NdrSH_UPDecision(PMIDL_STUB_MESSAGE,unsigned char**,RPC_BUFPTR);
int __attribute__((__stdcall__)) NdrSH_TLUPDecision(PMIDL_STUB_MESSAGE,unsigned char**);
int __attribute__((__stdcall__)) NdrSH_TLUPDecisionBuffer(PMIDL_STUB_MESSAGE,unsigned char**);
int __attribute__((__stdcall__)) NdrSH_IfAlloc(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
int __attribute__((__stdcall__)) NdrSH_IfAllocRef(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
int __attribute__((__stdcall__)) NdrSH_IfAllocSet(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_IfCopy(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_IfAllocCopy(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
unsigned long __attribute__((__stdcall__)) NdrSH_Copy(unsigned char*,unsigned char*,unsigned long);
void __attribute__((__stdcall__)) NdrSH_IfFree(PMIDL_STUB_MESSAGE,unsigned char*);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_StringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned long,int);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_StringUnMarshall(PMIDL_STUB_MESSAGE,unsigned char**,int);
typedef void *RPC_SS_THREAD_HANDLE;
typedef void* __attribute__((__stdcall__)) RPC_CLIENT_ALLOC(unsigned int);
typedef void __attribute__((__stdcall__)) RPC_CLIENT_FREE(void*);
void*__attribute__((__stdcall__)) RpcSsAllocate(unsigned int);
void __attribute__((__stdcall__)) RpcSsDisableAllocate(void);
void __attribute__((__stdcall__)) RpcSsEnableAllocate(void);
void __attribute__((__stdcall__)) RpcSsFree(void*);
RPC_SS_THREAD_HANDLE __attribute__((__stdcall__)) RpcSsGetThreadHandle(void);
void __attribute__((__stdcall__)) RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*);
void __attribute__((__stdcall__)) RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE);
void __attribute__((__stdcall__)) RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*,RPC_CLIENT_ALLOC**,RPC_CLIENT_FREE**);
void*__attribute__((__stdcall__)) RpcSmAllocate(unsigned int,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmClientFree(void*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmDestroyClientContext(void**);
RPC_STATUS __attribute__((__stdcall__)) RpcSmDisableAllocate(void);
RPC_STATUS __attribute__((__stdcall__)) RpcSmEnableAllocate(void);
RPC_STATUS __attribute__((__stdcall__)) RpcSmFree(void*);
RPC_SS_THREAD_HANDLE __attribute__((__stdcall__)) RpcSmGetThreadHandle(RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*,RPC_CLIENT_ALLOC**,RPC_CLIENT_FREE**);
void __attribute__((__stdcall__)) NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE);
void*__attribute__((__stdcall__)) NdrRpcSmClientAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrRpcSmClientFree(void*);
void*__attribute__((__stdcall__)) NdrRpcSsDefaultAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrRpcSsDefaultFree(void*);
PFULL_PTR_XLAT_TABLES __attribute__((__stdcall__)) NdrFullPointerXlatInit(unsigned long,XLAT_SIDE);
void __attribute__((__stdcall__)) NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES);
int __attribute__((__stdcall__)) NdrFullPointerQueryPointer(PFULL_PTR_XLAT_TABLES,void*,unsigned char,unsigned long*);
int __attribute__((__stdcall__)) NdrFullPointerQueryRefId(PFULL_PTR_XLAT_TABLES,unsigned long,unsigned char,void**);
void __attribute__((__stdcall__)) NdrFullPointerInsertRefId(PFULL_PTR_XLAT_TABLES,unsigned long,void*);
int __attribute__((__stdcall__)) NdrFullPointerFree(PFULL_PTR_XLAT_TABLES,void*);
void*__attribute__((__stdcall__)) NdrAllocate(PMIDL_STUB_MESSAGE,unsigned int);
void __attribute__((__stdcall__)) NdrClearOutParameters(PMIDL_STUB_MESSAGE,PFORMAT_STRING,void*);
void*__attribute__((__stdcall__)) NdrOleAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrOleFree(void*);
unsigned char*__attribute__((__stdcall__)) NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char*__attribute__((__stdcall__)) NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
void __attribute__((__stdcall__)) NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrUserMarshalFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);

}
# 5 "C:/upp/mingw/include/objbase.h" 2 3




       
# 10 "C:/upp/mingw/include/objbase.h" 3



#pragma pack(push,8)
# 54 "C:/upp/mingw/include/objbase.h" 3
typedef enum tagSTGFMT {
 STGFMT_STORAGE = 0,
 STGFMT_FILE = 3,
 STGFMT_ANY = 4,
 STGFMT_DOCFILE = 5
} STGFMT;
typedef struct tagSTGOPTIONS {
 USHORT usVersion;
 USHORT reserved;
 ULONG ulSectorSize;
 const WCHAR *pwcsTemplateFile;
} STGOPTIONS;
typedef enum tagREGCLS {
 REGCLS_SINGLEUSE = 0,
 REGCLS_MULTIPLEUSE = 1,
 REGCLS_MULTI_SEPARATE = 2
} REGCLS;
# 1 "C:/upp/mingw/include/wtypes.h" 1 3
# 1 "C:/upp/mingw/include/rpc.h" 1 3
# 2 "C:/upp/mingw/include/wtypes.h" 2 3





       
# 8 "C:/upp/mingw/include/wtypes.h" 3



extern "C" {
# 27 "C:/upp/mingw/include/wtypes.h" 3
typedef enum tagDVASPECT {
 DVASPECT_CONTENT=1,
 DVASPECT_THUMBNAIL=2,
 DVASPECT_ICON=4,
 DVASPECT_DOCPRINT=8
} DVASPECT;
typedef enum tagDVASPECT2 {
 DVASPECT_OPAQUE=16,
 DVASPECT_TRANSPARENT=32
} DVASPECT2;
typedef enum tagSTATFLAG {
 STATFLAG_DEFAULT=0,
 STATFLAG_NONAME=1
} STATFLAG;
typedef enum tagMEMCTX {
 MEMCTX_LOCAL=0,
 MEMCTX_TASK,
 MEMCTX_SHARED,
 MEMCTX_MACSYSTEM,
 MEMCTX_UNKNOWN=-1,
 MEMCTX_SAME=-2
} MEMCTX;
typedef enum tagMSHCTX {
 MSHCTX_LOCAL=0,
 MSHCTX_NOSHAREDMEM,
 MSHCTX_DIFFERENTMACHINE,
 MSHCTX_INPROC,
 MSHCTX_CROSSCTX
} MSHCTX;
typedef enum tagCLSCTX {
 CLSCTX_INPROC_SERVER=1,CLSCTX_INPROC_HANDLER=2,CLSCTX_LOCAL_SERVER=4,
 CLSCTX_INPROC_SERVER16=8,CLSCTX_REMOTE_SERVER=16
} CLSCTX;
typedef enum tagMSHLFLAGS {
 MSHLFLAGS_NORMAL,MSHLFLAGS_TABLESTRONG,MSHLFLAGS_TABLEWEAK
} MSHLFLAGS;
typedef struct _FLAGGED_WORD_BLOB {
 unsigned long fFlags;
 unsigned long clSize;
 unsigned short asData[1];
}FLAGGED_WORD_BLOB;


typedef WCHAR OLECHAR;
typedef LPWSTR LPOLESTR;
typedef LPCWSTR LPCOLESTR;







typedef unsigned short VARTYPE;
typedef short VARIANT_BOOL;
typedef VARIANT_BOOL _VARIANT_BOOL;


typedef OLECHAR *BSTR;
typedef FLAGGED_WORD_BLOB *wireBSTR;
typedef BSTR *LPBSTR;
typedef LONG SCODE;
typedef void *HCONTEXT;
typedef union tagCY {
 __extension__ struct {
  unsigned long Lo;
  long Hi;
 };
 LONGLONG int64;
} CY;
typedef double DATE;
typedef struct tagBSTRBLOB {
 ULONG cbSize;
 PBYTE pData;
}BSTRBLOB;
typedef struct tagBSTRBLOB *LPBSTRBLOB;
typedef struct tagCLIPDATA {
 ULONG cbSize;
 long ulClipFmt;
 PBYTE pClipData;
}CLIPDATA;
typedef enum tagSTGC {
 STGC_DEFAULT,STGC_OVERWRITE,STGC_ONLYIFCURRENT,
 STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE
}STGC;
typedef enum tagSTGMOVE {
 STGMOVE_MOVE,STGMOVE_COPY,STGMOVE_SHALLOWCOPY
}STGMOVE;
enum VARENUM {
 VT_EMPTY,VT_NULL,VT_I2,VT_I4,VT_R4,VT_R8,VT_CY,VT_DATE,VT_BSTR,VT_DISPATCH,
 VT_ERROR,VT_BOOL,VT_VARIANT,VT_UNKNOWN,VT_DECIMAL,VT_I1=16,VT_UI1,VT_UI2,VT_UI4,VT_I8,
 VT_UI8,VT_INT,VT_UINT,VT_VOID,VT_HRESULT,VT_PTR,VT_SAFEARRAY,VT_CARRAY,VT_USERDEFINED,
 VT_LPSTR,VT_LPWSTR,VT_RECORD=36,VT_INT_PTR=37,VT_UINT_PTR=38,VT_FILETIME=64,VT_BLOB,VT_STREAM,VT_STORAGE,VT_STREAMED_OBJECT,
 VT_STORED_OBJECT,VT_BLOB_OBJECT,VT_CF,VT_CLSID,VT_BSTR_BLOB=0xfff,VT_VECTOR=0x1000,
 VT_ARRAY=0x2000,VT_BYREF=0x4000,VT_RESERVED=0x8000,VT_ILLEGAL= 0xffff,VT_ILLEGALMASKED=0xfff,
 VT_TYPEMASK=0xfff
};

typedef struct _BYTE_SIZEDARR {
 unsigned long clSize;
 byte *pData;
}BYTE_SIZEDARR;
typedef struct _SHORT_SIZEDARR {
 unsigned long clSize;
 unsigned short *pData;
}WORD_SIZEDARR;
typedef struct _LONG_SIZEDARR {
 unsigned long clSize;
 unsigned long *pData;
}DWORD_SIZEDARR;
typedef struct _HYPER_SIZEDARR {
 unsigned long clSize;
 long long *pData;
}HYPER_SIZEDARR;
typedef double DOUBLE;
typedef struct tagDEC {
 USHORT wReserved;
 __extension__ union {
  __extension__ struct {
   BYTE scale;
   BYTE sign;
  };
  USHORT signscale;
 } ;
 ULONG Hi32;
 __extension__ union {
  __extension__ struct {
   ULONG Lo32;
   ULONG Mid32;
  };
  ULONGLONG Lo64;
 } ;
} DECIMAL;
typedef DECIMAL *LPDECIMAL;






typedef void *HMETAFILEPICT;

}
# 72 "C:/upp/mingw/include/objbase.h" 2 3
# 1 "C:/upp/mingw/include/unknwn.h" 1 3







       
# 9 "C:/upp/mingw/include/unknwn.h" 3



extern "C"{


# 1 "C:/upp/mingw/include/wtypes.h" 1 3
# 1 "C:/upp/mingw/include/rpc.h" 1 3
# 2 "C:/upp/mingw/include/wtypes.h" 2 3
# 16 "C:/upp/mingw/include/unknwn.h" 2 3

void * __attribute__((__stdcall__)) MIDL_user_allocate(size_t);
void __attribute__((__stdcall__)) MIDL_user_free(void*);
extern "C" const IID IID_IUnknown;
extern "C" const IID IID_IClassFactory;



struct IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
};

typedef IUnknown *LPUNKNOWN;




struct IClassFactory : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockServer( BOOL) =0;
};

typedef IClassFactory *LPCLASSFACTORY;

HRESULT __attribute__((__stdcall__)) IUnknown_QueryInterface_Proxy(IUnknown*,const IID&,void**);
void __attribute__((__stdcall__)) IUnknown_QueryInterface_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IUnknown_AddRef_Proxy(IUnknown*);
void __attribute__((__stdcall__)) IUnknown_AddRef_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IUnknown_Release_Proxy(IUnknown*);
void __attribute__((__stdcall__)) IUnknown_Release_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_RemoteCreateInstance_Proxy(IClassFactory*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IClassFactory_RemoteCreateInstance_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_RemoteLockServer_Proxy(IClassFactory*,BOOL);
void __attribute__((__stdcall__)) IClassFactory_RemoteLockServer_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_CreateInstance_Proxy(IClassFactory*,IUnknown*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IClassFactory_CreateInstance_Stub(IClassFactory*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IClassFactory_LockServer_Proxy(IClassFactory*,BOOL);
HRESULT __attribute__((__stdcall__)) IClassFactory_LockServer_Stub(IClassFactory*,BOOL);
# 74 "C:/upp/mingw/include/unknwn.h" 3
}
# 73 "C:/upp/mingw/include/objbase.h" 2 3
# 1 "C:/upp/mingw/include/objidl.h" 1 3



       
# 5 "C:/upp/mingw/include/objidl.h" 3
# 46 "C:/upp/mingw/include/objidl.h" 3
typedef struct tagSTATSTG {
 LPOLESTR pwcsName;
 DWORD type;
 ULARGE_INTEGER cbSize;
 FILETIME mtime;
 FILETIME ctime;
 FILETIME atime;
 DWORD grfMode;
 DWORD grfLocksSupported;
 CLSID clsid;
 DWORD grfStateBits;
 DWORD reserved;
} STATSTG;
typedef enum tagSTGTY {
 STGTY_STORAGE=1,
 STGTY_STREAM,
 STGTY_LOCKBYTES,
 STGTY_PROPERTY
} STGTY;
typedef enum tagSTREAM_SEEK {
 STREAM_SEEK_SET,
 STREAM_SEEK_CUR,
 STREAM_SEEK_END
} STREAM_SEEK;
typedef struct tagINTERFACEINFO {
 LPUNKNOWN pUnk;
 IID iid;
 WORD wMethod;
} INTERFACEINFO,*LPINTERFACEINFO;
typedef enum tagCALLTYPE {
 CALLTYPE_TOPLEVEL=1,
 CALLTYPE_NESTED,
 CALLTYPE_ASYNC,
 CALLTYPE_TOPLEVEL_CALLPENDING,
 CALLTYPE_ASYNC_CALLPENDING
} CALLTYPE;
typedef enum tagPENDINGTYPE {
 PENDINGTYPE_TOPLEVEL=1,
 PENDINGTYPE_NESTED
} PENDINGTYPE;
typedef enum tagPENDINGMSG {
 PENDINGMSG_CANCELCALL=0,
 PENDINGMSG_WAITNOPROCESS,
 PENDINGMSG_WAITDEFPROCESS
} PENDINGMSG;
typedef OLECHAR **SNB;
typedef enum tagDATADIR {
 DATADIR_GET=1,
 DATADIR_SET
} DATADIR;
typedef WORD CLIPFORMAT,*LPCLIPFORMAT;
typedef struct tagDVTARGETDEVICE {
 DWORD tdSize;
 WORD tdDriverNameOffset;
 WORD tdDeviceNameOffset;
 WORD tdPortNameOffset;
 WORD tdExtDevmodeOffset;
 BYTE tdData[1];
} DVTARGETDEVICE;
typedef struct tagFORMATETC {
 CLIPFORMAT cfFormat;
 DVTARGETDEVICE*ptd;
 DWORD dwAspect;
 LONG lindex;
 DWORD tymed;
} FORMATETC,*LPFORMATETC;
typedef struct tagRemSTGMEDIUM {
 DWORD tymed;
 DWORD dwHandleType;
 ULONG pData;
 unsigned long pUnkForRelease;
 unsigned long cbData;
 BYTE data[1];
} RemSTGMEDIUM;
typedef struct tagHLITEM {
 ULONG uHLID;
 LPWSTR pwzFriendlyName;
} HLITEM;
typedef struct tagSTATDATA {
 FORMATETC formatetc;
 DWORD grfAdvf;
 struct IAdviseSink *pAdvSink;
 DWORD dwConnection;
} STATDATA;
typedef struct tagSTATPROPSETSTG {
 FMTID fmtid;
 CLSID clsid;
 DWORD grfFlags;
 FILETIME mtime;
 FILETIME ctime;
 FILETIME atime;
} STATPROPSETSTG;
typedef enum tagEXTCONN {
 EXTCONN_STRONG=1,
 EXTCONN_WEAK=2,
 EXTCONN_CALLABLE=4
} EXTCONN;
typedef struct tagMULTI_QI {
 const IID *pIID;
 IUnknown *pItf;
 HRESULT hr;
} MULTI_QI;
typedef struct _AUTH_IDENTITY {
 USHORT *User;
 ULONG UserLength;
 USHORT *Domain;
 ULONG DomainLength;
 USHORT *Password;
 ULONG PasswordLength;
 ULONG Flags;
} AUTH_IDENTITY;
typedef struct _COAUTHINFO{
 DWORD dwAuthnSvc;
 DWORD dwAuthzSvc;
 LPWSTR pwszServerPrincName;
 DWORD dwAuthnLevel;
 DWORD dwImpersonationLevel;
 AUTH_IDENTITY *pAuthIdentityData;
 DWORD dwCapabilities;
} COAUTHINFO;
typedef struct _COSERVERINFO {
 DWORD dwReserved1;
 LPWSTR pwszName;
 COAUTHINFO *pAuthInfo;
 DWORD dwReserved2;
} COSERVERINFO;
typedef struct tagBIND_OPTS {
 DWORD cbStruct;
 DWORD grfFlags;
 DWORD grfMode;
 DWORD dwTickCountDeadline;
} BIND_OPTS,*LPBIND_OPTS;
typedef struct tagBIND_OPTS2 {
 DWORD cbStruct;
 DWORD grfFlags;
 DWORD grfMode;
 DWORD dwTickCountDeadline;
 DWORD dwTrackFlags;
 DWORD dwClassContext;
 LCID locale;
 COSERVERINFO *pServerInfo;
} BIND_OPTS2,*LPBIND_OPTS2;
typedef enum tagBIND_FLAGS {
 BIND_MAYBOTHERUSER=1,
 BIND_JUSTTESTEXISTENCE
} BIND_FLAGS;
typedef struct tagSTGMEDIUM {
 DWORD tymed;
 __extension__ union {
  HBITMAP hBitmap;
  PVOID hMetaFilePict;
  HENHMETAFILE hEnhMetaFile;
  HGLOBAL hGlobal;
  LPWSTR lpszFileName;
  LPSTREAM pstm;
  LPSTORAGE pstg;
 } ;
 LPUNKNOWN pUnkForRelease;
} STGMEDIUM,*LPSTGMEDIUM;
typedef enum tagLOCKTYPE {
 LOCK_WRITE=1,
 LOCK_EXCLUSIVE=2,
 LOCK_ONLYONCE=4
} LOCKTYPE;
typedef unsigned long RPCOLEDATAREP;
typedef struct tagRPCOLEMESSAGE {
 PVOID reserved1;
 RPCOLEDATAREP dataRepresentation;
 PVOID Buffer;
 ULONG cbBuffer;
 ULONG iMethod;
 PVOID reserved2[5];
 ULONG rpcFlags;
} RPCOLEMESSAGE, *PRPCOLEMESSAGE;
typedef enum tagMKSYS {
 MKSYS_NONE,
 MKSYS_GENERICCOMPOSITE,
 MKSYS_FILEMONIKER,
 MKSYS_ANTIMONIKER,
 MKSYS_ITEMMONIKER,
 MKSYS_POINTERMONIKER
} MKSYS;
typedef enum tagMKREDUCE {
 MKRREDUCE_ALL,
 MKRREDUCE_ONE=196608,
 MKRREDUCE_TOUSER=131072,
 MKRREDUCE_THROUGHUSER=65536
} MKRREDUCE;
typedef struct tagRemSNB {
 unsigned long ulCntStr;
 unsigned long ulCntChar;
 OLECHAR rgString[1];
} RemSNB;
typedef enum tagADVF {
 ADVF_NODATA=1,ADVF_PRIMEFIRST=2,ADVF_ONLYONCE=4,ADVF_DATAONSTOP=64,
 ADVFCACHE_NOHANDLER=8,ADVFCACHE_FORCEBUILTIN=16,ADVFCACHE_ONSAVE=32
} ADVF;
typedef enum tagTYMED {
 TYMED_HGLOBAL=1,TYMED_FILE=2,TYMED_ISTREAM=4,TYMED_ISTORAGE=8,
 TYMED_GDI=16,TYMED_MFPICT=32,TYMED_ENHMF=64,TYMED_NULL=0
} TYMED;
typedef enum tagSERVERCALL {
 SERVERCALL_ISHANDLED,SERVERCALL_REJECTED,SERVERCALL_RETRYLATER
} SERVERCALL;
typedef struct tagCAUB {
 ULONG cElems;
 unsigned char *pElems;
}CAUB;
typedef struct tagCAI {
 ULONG cElems;
 short *pElems;
}CAI;
typedef struct tagCAUI {
 ULONG cElems;
 USHORT *pElems;
}CAUI;
typedef struct tagCAL {
 ULONG cElems;
 long *pElems;
}CAL;
typedef struct tagCAUL {
 ULONG cElems;
 ULONG *pElems;
}CAUL;
typedef struct tagCAFLT {
 ULONG cElems;
 float *pElems;
}CAFLT;
typedef struct tagCADBL {
 ULONG cElems;
 double *pElems;
}CADBL;
typedef struct tagCACY {
 ULONG cElems;
 CY *pElems;
}CACY;
typedef struct tagCADATE {
 ULONG cElems;
 DATE *pElems;
}CADATE;
typedef struct tagCABSTR {
 ULONG cElems;
 BSTR *pElems;
}CABSTR;
typedef struct tagCABSTRBLOB {
 ULONG cElems;
 BSTRBLOB *pElems;
}CABSTRBLOB;
typedef struct tagCABOOL {
 ULONG cElems;
 VARIANT_BOOL *pElems;
}CABOOL;
typedef struct tagCASCODE {
 ULONG cElems;
 SCODE *pElems;
}CASCODE;
typedef struct tagCAH {
 ULONG cElems;
 LARGE_INTEGER *pElems;
}CAH;
typedef struct tagCAUH {
 ULONG cElems;
 ULARGE_INTEGER *pElems;
}CAUH;
typedef struct tagCALPSTR {
 ULONG cElems;
 LPSTR *pElems;
}CALPSTR;
typedef struct tagCALPWSTR {
 ULONG cElems;
 LPWSTR *pElems;
}CALPWSTR;
typedef struct tagCAFILETIME {
 ULONG cElems;
 FILETIME *pElems;
}CAFILETIME;
typedef struct tagCACLIPDATA {
 ULONG cElems;
 CLIPDATA *pElems;
}CACLIPDATA;
typedef struct tagCACLSID {
 ULONG cElems;
 CLSID *pElems;
}CACLSID;
typedef struct tagPROPVARIANT *LPPROPVARIANT;
typedef struct tagCAPROPVARIANT {
 ULONG cElems;
 LPPROPVARIANT pElems;
}CAPROPVARIANT;
typedef struct tagPROPVARIANT {
 VARTYPE vt;
 WORD wReserved1;
 WORD wReserved2;
 WORD wReserved3;
 __extension__ union {
  CHAR cVal;
  UCHAR bVal;
  short iVal;
  USHORT uiVal;
  VARIANT_BOOL boolVal;





  long lVal;
  ULONG ulVal;
  float fltVal;
  SCODE scode;
  LARGE_INTEGER hVal;
  ULARGE_INTEGER uhVal;
  double dblVal;
  CY cyVal;
  DATE date;
  FILETIME filetime;
  CLSID *puuid;
  BLOB blob;
  CLIPDATA *pclipdata;
  LPSTREAM pStream;
  LPSTORAGE pStorage;
  BSTR bstrVal;
  BSTRBLOB bstrblobVal;
  LPSTR pszVal;
  LPWSTR pwszVal;
  CAUB caub;
  CAI cai;
  CAUI caui;
  CABOOL cabool;
  CAL cal;
  CAUL caul;
  CAFLT caflt;
  CASCODE cascode;
  CAH cah;
  CAUH cauh;
  CADBL cadbl;
  CACY cacy;
  CADATE cadate;
  CAFILETIME cafiletime;
  CACLSID cauuid;
  CACLIPDATA caclipdata;
  CABSTR cabstr;
  CABSTRBLOB cabstrblob;
  CALPSTR calpstr;
  CALPWSTR calpwstr;
  CAPROPVARIANT capropvar;
 } ;
} PROPVARIANT;
typedef struct tagPROPSPEC {
 ULONG ulKind;
 __extension__ union {
  PROPID propid;
  LPOLESTR lpwstr;
 } ;
}PROPSPEC;
typedef struct tagSTATPROPSTG {
 LPOLESTR lpwstrName;
 PROPID propid;
 VARTYPE vt;
} STATPROPSTG;
typedef enum PROPSETFLAG {
 PROPSETFLAG_DEFAULT,PROPSETFLAG_NONSIMPLE,PROPSETFLAG_ANSI,
 PROPSETFLAG_UNBUFFERED=4
} PROPSETFLAG;
typedef struct tagSTORAGELAYOUT {
 DWORD LayoutType;
 OLECHAR* pwcsElementName;
 LARGE_INTEGER cOffset;
 LARGE_INTEGER cBytes;
} STORAGELAYOUT;
typedef struct tagSOLE_AUTHENTICATION_SERVICE {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR *pPrincipalName;
    HRESULT hr;
} SOLE_AUTHENTICATION_SERVICE;

typedef enum tagEOLE_AUTHENTICATION_CAPABILITIES {
 EOAC_NONE = 0,
 EOAC_MUTUAL_AUTH = 0x1,
 EOAC_STATIC_CLOAKING = 0x20,
 EOAC_DYNAMIC_CLOAKING = 0x40,
 EOAC_ANY_AUTHORITY = 0x80,
 EOAC_MAKE_FULLSIC = 0x100,
 EOAC_DEFAULT = 0x800,
 EOAC_SECURE_REFS = 0x2,
 EOAC_ACCESS_CONTROL = 0x4,
 EOAC_APPID = 0x8,
 EOAC_DYNAMIC = 0x10,
 EOAC_REQUIRE_FULLSIC = 0x200,
 EOAC_AUTO_IMPERSONATE = 0x400,
 EOAC_NO_CUSTOM_MARSHAL = 0x2000,
 EOAC_DISABLE_AAA = 0x1000
} EOLE_AUTHENTICATION_CAPABILITIES;
typedef struct tagSOLE_AUTHENTICATION_INFO {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    void* pAuthInfo;
} SOLE_AUTHENTICATION_INFO;

typedef struct tagSOLE_AUTHENTICATION_LIST {
    DWORD cAuthInfo;
    SOLE_AUTHENTICATION_INFO* aAuthInfo;
} SOLE_AUTHENTICATION_LIST;

extern "C" const FMTID FMTID_SummaryInformation;
extern "C" const FMTID FMTID_DocSummaryInformation;
extern "C" const FMTID FMTID_UserDefinedProperties;

struct IEnumFORMATETC : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,FORMATETC*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumFORMATETC**) =0; };
struct IEnumHLITEM : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,HLITEM*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumHLITEM**) =0; };
struct IEnumSTATDATA : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATDATA*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATDATA**) =0; };
struct IEnumSTATPROPSETSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATPROPSETSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATPROPSETSTG**) =0; };
struct IEnumSTATPROPSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATPROPSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATPROPSTG**) =0; };
struct IEnumSTATSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATSTG**) =0; };
struct IEnumString : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,LPOLESTR*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumString**) =0; };
struct IEnumMoniker : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,struct IMoniker**,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumMoniker**) =0; };
struct IEnumUnknown : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,IUnknown**,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumUnknown**) =0; };

extern "C" const IID IID_ISequentialStream;

struct ISequentialStream : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Read( void*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Write( void const*,ULONG,ULONG*) =0;
};


extern "C" const IID IID_IStream;

struct IStream : public ISequentialStream
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Read( void*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Write( void const*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Seek( LARGE_INTEGER,DWORD,ULARGE_INTEGER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyTo( IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnlockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Clone( LPSTREAM*) =0;
};


extern "C" const IID IID_IMarshal;

struct IMarshal : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUnmarshalClass ( const IID&,PVOID,DWORD,PVOID,DWORD,CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMarshalSizeMax ( const IID&,PVOID,DWORD,PVOID,PDWORD,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) MarshalInterface ( IStream*,const IID&,PVOID,DWORD,PVOID,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnmarshalInterface ( IStream*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseMarshalData ( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DisconnectObject ( DWORD) =0;
};


extern "C" const IID IID_IStdMarshalInfo;

struct IStdMarshalInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassForHandler( DWORD,PVOID,CLSID*) =0;
};


extern "C" const IID IID_IMalloc;

struct IMalloc : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void* __attribute__((__stdcall__)) Alloc( ULONG) =0;
 virtual void* __attribute__((__stdcall__)) Realloc( void*,ULONG) =0;
 virtual void __attribute__((__stdcall__)) Free( void*) =0;
 virtual ULONG __attribute__((__stdcall__)) GetSize( void*) =0;
 virtual int __attribute__((__stdcall__)) DidAlloc( void*) =0;
 virtual void __attribute__((__stdcall__)) HeapMinimize(void) =0;
};


extern "C" const IID IID_IMallocSpy;

struct IMallocSpy : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual ULONG __attribute__((__stdcall__)) PreAlloc( ULONG) =0;
 virtual void* __attribute__((__stdcall__)) PostAlloc( void*) =0;
 virtual void* __attribute__((__stdcall__)) PreFree( void*,BOOL) =0;
 virtual void __attribute__((__stdcall__)) PostFree( BOOL) =0;
 virtual ULONG __attribute__((__stdcall__)) PreRealloc( void*,ULONG,void**,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PostRealloc( void*,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PreGetSize( void*,BOOL) =0;
 virtual ULONG __attribute__((__stdcall__)) PostGetSize( ULONG,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PreDidAlloc( void*,BOOL) =0;
 virtual int __attribute__((__stdcall__)) PostDidAlloc( void*,BOOL,int) =0;
 virtual void __attribute__((__stdcall__)) PreHeapMinimize(void) =0;
 virtual void __attribute__((__stdcall__)) PostHeapMinimize(void) =0;
};


extern "C" const IID IID_IMessageFilter;

struct IMessageFilter : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual DWORD __attribute__((__stdcall__)) HandleInComingCall( DWORD,HTASK,DWORD,LPINTERFACEINFO) =0;
 virtual DWORD __attribute__((__stdcall__)) RetryRejectedCall( HTASK,DWORD,DWORD) =0;
 virtual DWORD __attribute__((__stdcall__)) MessagePending( HTASK,DWORD,DWORD) =0;
};


extern "C" const IID IID_IPersist;

struct IPersist : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
};


extern "C" const IID IID_IPersistStream;

struct IPersistStream : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( IStream*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSizeMax( PULARGE_INTEGER) =0;
};


extern "C" const IID IID_IRunningObjectTable;

struct IRunningObjectTable : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Register( DWORD,LPUNKNOWN,LPMONIKER,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revoke( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectA( LPMONIKER,LPUNKNOWN*) =0;
 virtual HRESULT __attribute__((__stdcall__)) NoteChangeTime( DWORD,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTimeOfLastChange( LPMONIKER,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumRunning( IEnumMoniker**) =0;
};


extern "C" const IID IID_IBindCtx;

struct IBindCtx : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterObjectBound( LPUNKNOWN) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeObjectBound( LPUNKNOWN) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseBoundObjects(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBindOptions( LPBIND_OPTS) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBindOptions( LPBIND_OPTS) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRunningObjectTable( IRunningObjectTable**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterObjectParam( LPOLESTR,IUnknown*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectParam( LPOLESTR,IUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjectParam( IEnumString**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeObjectParam( LPOLESTR) =0;
};


extern "C" const IID IID_IMoniker;

struct IMoniker : public IPersistStream
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( IStream*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSizeMax( PULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindToObject( IBindCtx*,IMoniker*,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindToStorage( IBindCtx*,IMoniker*,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Reduce( IBindCtx*,DWORD,IMoniker**,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) ComposeWith( IMoniker*,BOOL,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( BOOL,IEnumMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsEqual( IMoniker*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Hash( PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( IBindCtx*,IMoniker*,IMoniker*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTimeOfLastChange( IBindCtx*,IMoniker*,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) Inverse( IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CommonPrefixWith( IMoniker*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RelativePathTo( IMoniker*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDisplayName( IBindCtx*,IMoniker*,LPOLESTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,IMoniker*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsSystemMoniker( PDWORD) =0;
};


extern "C" const IID IID_IPersistStorage;

struct IPersistStorage : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitNew( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( LPSTORAGE,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveCompleted( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) HandsOffStorage(void) =0;
};


extern "C" const IID IID_IPersistFile;

struct IPersistFile : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( LPCOLESTR,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( LPCOLESTR,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveCompleted( LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCurFile( LPOLESTR*) =0;
};


extern "C" const IID IID_IAdviseSink;

struct IAdviseSink : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) OnDataChange( FORMATETC*,STGMEDIUM*) =0;
 virtual void __attribute__((__stdcall__)) OnViewChange( DWORD,LONG) =0;
 virtual void __attribute__((__stdcall__)) OnRename( IMoniker*) =0;
 virtual void __attribute__((__stdcall__)) OnSave(void) =0;
 virtual void __attribute__((__stdcall__)) OnClose(void) =0;
};


extern "C" const IID IID_IAdviseSink2;

struct IAdviseSink2 : public IAdviseSink
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) OnDataChange( FORMATETC*,STGMEDIUM*) =0;
 virtual void __attribute__((__stdcall__)) OnViewChange( DWORD,LONG) =0;
 virtual void __attribute__((__stdcall__)) OnRename( IMoniker*) =0;
 virtual void __attribute__((__stdcall__)) OnSave(void) =0;
 virtual void __attribute__((__stdcall__)) OnClose(void) =0;
 virtual void __attribute__((__stdcall__)) OnLinkSrcChange( IMoniker*);
};


extern "C" const IID IID_IDataObject;

struct IDataObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetData( FORMATETC*,STGMEDIUM*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDataHere( FORMATETC*,STGMEDIUM*) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryGetData( FORMATETC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCanonicalFormatEtc( FORMATETC*,FORMATETC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumFormatEtc( DWORD,IEnumFORMATETC**) =0;
 virtual HRESULT __attribute__((__stdcall__)) DAdvise( FORMATETC*,DWORD,IAdviseSink*,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DUnadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumDAdvise( IEnumSTATDATA**) =0;
};


extern "C" const IID IID_IDataAdviseHolder;

struct IDataAdviseHolder : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( IDataObject*,FORMATETC*,DWORD,IAdviseSink*,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( IEnumSTATDATA**) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnDataChange( IDataObject*,DWORD,DWORD) =0;
};


extern "C" const IID IID_IStorage;

struct IStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStream( LPCWSTR,DWORD,DWORD,DWORD,IStream**) =0;
 virtual HRESULT __attribute__((__stdcall__)) OpenStream( LPCWSTR,PVOID,DWORD,DWORD,IStream**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStorage( LPCWSTR,DWORD,DWORD,DWORD,IStorage**) =0;
 virtual HRESULT __attribute__((__stdcall__)) OpenStorage( LPCWSTR,IStorage*,DWORD,SNB,DWORD,IStorage**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyTo( DWORD,IID const*,SNB,IStorage*) =0;
 virtual HRESULT __attribute__((__stdcall__)) MoveElementTo( LPCWSTR,IStorage*,LPCWSTR,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumElements( DWORD,PVOID,DWORD,IEnumSTATSTG**) =0;
 virtual HRESULT __attribute__((__stdcall__)) DestroyElement( LPCWSTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) RenameElement( LPCWSTR,LPCWSTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetElementTimes( LPCWSTR,FILETIME const*,FILETIME const*,FILETIME const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClass( const CLSID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetStateBits( DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
};


extern "C" const IID IID_IRootStorage;

struct IRootStorage : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SwitchToFile( LPOLESTR) =0;
};


extern "C" const IID IID_IRpcChannelBuffer;

struct IRpcChannelBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBuffer( RPCOLEMESSAGE*,const IID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendReceive( RPCOLEMESSAGE*,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) FreeBuffer( RPCOLEMESSAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDestCtx( PDWORD,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsConnected(void) =0;
};


extern "C" const IID IID_IRpcProxyBuffer;

struct IRpcProxyBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Connect( IRpcChannelBuffer*) =0;
 virtual void __attribute__((__stdcall__)) Disconnect(void) =0;

};


extern "C" const IID IID_IRpcStubBuffer;

struct IRpcStubBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Connect( LPUNKNOWN) =0;
 virtual void __attribute__((__stdcall__)) Disconnect(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( RPCOLEMESSAGE*,LPRPCSTUBBUFFER) =0;
 virtual LPRPCSTUBBUFFER __attribute__((__stdcall__)) IsIIDSupported( const IID&) =0;
 virtual ULONG __attribute__((__stdcall__)) CountRefs(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DebugServerQueryInterface( PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DebugServerRelease( PVOID) =0;
};


extern "C" const IID IID_IPSFactoryBuffer;

struct IPSFactoryBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateProxy( LPUNKNOWN,const IID&,LPRPCPROXYBUFFER*,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStub( const IID&,LPUNKNOWN,LPRPCSTUBBUFFER*) =0;
};

typedef struct IPSFactoryBuffer *LPPSFACTORYBUFFER;

extern "C" const IID IID_ILockBytes;

struct ILockBytes : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadAt( ULARGE_INTEGER,PVOID,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WriteAt( ULARGE_INTEGER,PCVOID,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Flush(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnlockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
};


extern "C" const IID IID_IExternalConnection;

struct IExternalConnection : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddConnection( DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseConnection( DWORD,DWORD,BOOL) =0;
};


extern "C" const IID IID_IRunnableObject;

struct IRunnableObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRunningClass( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) Run( LPBC) =0;
 virtual BOOL __attribute__((__stdcall__)) IsRunning(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRunning( BOOL,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetContainedObject( BOOL) =0;
};


extern "C" const IID IID_IROTData;

struct IROTData : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetComparisonData( PVOID,ULONG,PULONG) =0;
};


extern "C" const IID IID_IChannelHook;

struct IChannelHook : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) ClientGetSize( const GUID&,const IID&,PULONG) =0;
 virtual void __attribute__((__stdcall__)) ClientFillBuffer( const GUID&,const IID&,PULONG,PVOID) =0;
 virtual void __attribute__((__stdcall__)) ClientNotify( const GUID&,const IID&,ULONG,PVOID,DWORD,HRESULT) =0;
 virtual void __attribute__((__stdcall__)) ServerNotify( const GUID&,const IID&,ULONG,PVOID,DWORD) =0;
 virtual void __attribute__((__stdcall__)) ServerGetSize( const GUID&,const IID&,HRESULT,PULONG) =0;
 virtual void __attribute__((__stdcall__)) ServerFillBuffer( const GUID&,const IID&,PULONG,PVOID,HRESULT) =0;
};


extern "C" const IID IID_IPropertyStorage;

struct IPropertyStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadMultiple( ULONG,PROPSPEC const*,PROPVARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WriteMultiple( ULONG,PROPSPEC const*,PROPVARIANT*,PROPID) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeleteMultiple( ULONG,PROPSPEC const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadPropertyNames( ULONG,PROPID const*,LPWSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WritePropertyNames( ULONG,PROPID const*,LPWSTR const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeletePropertyNames( ULONG,PROPID const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClass( const CLSID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( IEnumSTATPROPSTG**) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATPROPSTG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetTimes( FILETIME const*,FILETIME const*,FILETIME const*) =0;
};


extern "C" const IID IID_IPropertySetStorage;

struct IPropertySetStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Create( const FMTID&,CLSID*,DWORD,DWORD,LPPROPERTYSTORAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Open( const FMTID&,DWORD,LPPROPERTYSTORAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Delete( const FMTID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( IEnumSTATPROPSETSTG**) =0;
};


extern "C" const IID IID_IClientSecurity;

struct IClientSecurity : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryBlanket( PVOID,PDWORD,PDWORD,OLECHAR**,PDWORD,PDWORD,RPC_AUTH_IDENTITY_HANDLE**,PDWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBlanket( PVOID,DWORD,DWORD,LPWSTR,DWORD,DWORD,RPC_AUTH_IDENTITY_HANDLE*,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyProxy( LPUNKNOWN,LPUNKNOWN*) =0;
};


extern "C" const IID IID_IServerSecurity;

struct IServerSecurity : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryBlanket( PDWORD,PDWORD,OLECHAR**,PDWORD,PDWORD,RPC_AUTHZ_HANDLE*,PDWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ImpersonateClient(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevertToSelf(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsImpersonating(void) =0;
};


extern "C" const IID IID_IClassActivator;

struct IClassActivator : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassObject( const CLSID&,DWORD,LCID,const IID&,PVOID*) =0;
};


extern "C" const IID IID_IFillLockBytes;

struct IFillLockBytes : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) FillAppend( void const*,ULONG,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) FillAt( ULARGE_INTEGER,void const*,ULONG,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetFillSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) Terminate( BOOL) =0;
};


extern "C" const IID IID_IProgressNotify;

struct IProgressNotify : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnProgress( DWORD,DWORD,BOOL,BOOL) =0;
};


extern "C" const IID IID_ILayoutStorage;

struct ILayoutStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LayoutScript( STORAGELAYOUT*,DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) BeginMonitor(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) EndMonitor(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReLayoutDocfile( OLECHAR*) =0;
};


extern "C" const IID IID_IGlobalInterfaceTable;

struct IGlobalInterfaceTable : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterInterfaceInGlobal( IUnknown*,const IID&,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeInterfaceFromGlobal( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetInterfaceFromGlobal( DWORD,const IID&,void**) =0;
};
# 1065 "C:/upp/mingw/include/objidl.h" 3
HRESULT __attribute__((__stdcall__)) IMarshal_GetUnmarshalClass_Proxy(IMarshal*,const IID&,void*,DWORD,void*,DWORD,CLSID*);
void __attribute__((__stdcall__)) IMarshal_GetUnmarshalClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_GetMarshalSizeMax_Proxy(IMarshal*,const IID&,void*,DWORD,void*,DWORD,DWORD*);
void __attribute__((__stdcall__)) IMarshal_GetMarshalSizeMax_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_MarshalInterface_Proxy(IMarshal*,IStream*,const IID&,void*,DWORD,void*,DWORD);
void __attribute__((__stdcall__)) IMarshal_MarshalInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_UnmarshalInterface_Proxy(IMarshal*,IStream*,const IID&,void**);
void __attribute__((__stdcall__)) IMarshal_UnmarshalInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_ReleaseMarshalData_Proxy(IMarshal*,IStream*);
void __attribute__((__stdcall__)) IMarshal_ReleaseMarshalData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_DisconnectObject_Proxy(IMarshal*,DWORD);
void __attribute__((__stdcall__)) IMarshal_DisconnectObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMalloc_Alloc_Proxy(IMalloc*,ULONG);
void __attribute__((__stdcall__)) IMalloc_Alloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMalloc_Realloc_Proxy(IMalloc*,void*,ULONG);
void __attribute__((__stdcall__)) IMalloc_Realloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMalloc_Free_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_Free_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMalloc_GetSize_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_GetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
int __attribute__((__stdcall__)) IMalloc_DidAlloc_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_DidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMalloc_HeapMinimize_Proxy(IMalloc*);
void __attribute__((__stdcall__)) IMalloc_HeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PreAlloc_Proxy(IMallocSpy*,ULONG cbRequest);
void __attribute__((__stdcall__)) IMallocSpy_PreAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PostAlloc_Proxy(IMallocSpy*,void*);
void __attribute__((__stdcall__)) IMallocSpy_PostAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreFree_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreFree_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PostFree_Proxy(IMallocSpy*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostFree_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PreRealloc_Proxy(IMallocSpy*,void*,ULONG,void**,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreRealloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PostRealloc_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostRealloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreGetSize_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreGetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PostGetSize_Proxy(IMallocSpy*,ULONG,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostGetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreDidAlloc_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreDidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
int __attribute__((__stdcall__)) IMallocSpy_PostDidAlloc_Proxy(IMallocSpy*,void*,BOOL,int);
void __attribute__((__stdcall__)) IMallocSpy_PostDidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PreHeapMinimize_Proxy(IMallocSpy* );
void __attribute__((__stdcall__)) IMallocSpy_PreHeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PostHeapMinimize_Proxy(IMallocSpy*);
void __attribute__((__stdcall__)) IMallocSpy_PostHeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStdMarshalInfo_GetClassForHandler_Proxy(IStdMarshalInfo*,DWORD,void*,CLSID*);
void __attribute__((__stdcall__)) IStdMarshalInfo_GetClassForHandler_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IExternalConnection_AddConnection_Proxy(IExternalConnection*,DWORD,DWORD);
void __attribute__((__stdcall__)) IExternalConnection_AddConnection_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IExternalConnection_ReleaseConnection_Proxy(IExternalConnection*,DWORD,DWORD,BOOL);
void __attribute__((__stdcall__)) IExternalConnection_ReleaseConnection_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_RemoteNext_Proxy(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
void __attribute__((__stdcall__)) IEnumUnknown_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Skip_Proxy(IEnumUnknown*,ULONG);
void __attribute__((__stdcall__)) IEnumUnknown_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Reset_Proxy(IEnumUnknown* );
void __attribute__((__stdcall__)) IEnumUnknown_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Clone_Proxy(IEnumUnknown*,IEnumUnknown**);
void __attribute__((__stdcall__)) IEnumUnknown_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RegisterObjectBound_Proxy(IBindCtx*,IUnknown*punk);
void __attribute__((__stdcall__)) IBindCtx_RegisterObjectBound_Stub(IRpcStubBuffer*,IRpcChannelBuffer*_pRpcChannelBuffer,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RevokeObjectBound_Proxy(IBindCtx*,IUnknown*punk);
void __attribute__((__stdcall__)) IBindCtx_RevokeObjectBound_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_ReleaseBoundObjects_Proxy(IBindCtx*);
void __attribute__((__stdcall__)) IBindCtx_ReleaseBoundObjects_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_SetBindOptions_Proxy(IBindCtx*,BIND_OPTS*);
void __attribute__((__stdcall__)) IBindCtx_SetBindOptions_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetBindOptions_Proxy(IBindCtx*,BIND_OPTS*pbindopts);
void __attribute__((__stdcall__)) IBindCtx_GetBindOptions_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetRunningObjectTable_Proxy(IBindCtx*,IRunningObjectTable**);
void __attribute__((__stdcall__)) IBindCtx_GetRunningObjectTable_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RegisterObjectParam_Proxy(IBindCtx*,LPCSTR,IUnknown*);
void __attribute__((__stdcall__)) IBindCtx_RegisterObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetObjectParam_Proxy(IBindCtx*,LPCSTR,IUnknown**);
void __attribute__((__stdcall__)) IBindCtx_GetObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_EnumObjectParam_Proxy(IBindCtx*,IEnumString**);
void __attribute__((__stdcall__)) IBindCtx_EnumObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RevokeObjectParam_Proxy(IBindCtx*,LPCSTR);
void __attribute__((__stdcall__)) IBindCtx_RevokeObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_RemoteNext_Proxy(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
void __attribute__((__stdcall__)) IEnumMoniker_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Skip_Proxy(IEnumMoniker*,ULONG);
void __attribute__((__stdcall__)) IEnumMoniker_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Reset_Proxy(IEnumMoniker*);
void __attribute__((__stdcall__)) IEnumMoniker_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Clone_Proxy(IEnumMoniker*,IEnumMoniker**);
void __attribute__((__stdcall__)) IEnumMoniker_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_GetRunningClass_Proxy(IRunnableObject*,LPCLSID);
void __attribute__((__stdcall__)) IRunnableObject_GetRunningClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_Run_Proxy(IRunnableObject*,LPBINDCTX);
void __attribute__((__stdcall__)) IRunnableObject_Run_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
BOOL __attribute__((__stdcall__)) IRunnableObject_IsRunning_Proxy(IRunnableObject*);
void __attribute__((__stdcall__)) IRunnableObject_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_LockRunning_Proxy(IRunnableObject*,BOOL,BOOL);
void __attribute__((__stdcall__)) IRunnableObject_LockRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_SetContainedObject_Proxy(IRunnableObject*,BOOL);
void __attribute__((__stdcall__)) IRunnableObject_SetContainedObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_Register_Proxy(IRunningObjectTable*,DWORD,IUnknown*,IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IRunningObjectTable_Register_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_Revoke_Proxy(IRunningObjectTable*,DWORD);
void __attribute__((__stdcall__)) IRunningObjectTable_Revoke_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_IsRunning_Proxy(IRunningObjectTable*,IMoniker*);
void __attribute__((__stdcall__)) IRunningObjectTable_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_GetObject_Proxy(IRunningObjectTable*,IMoniker*,IUnknown**);
void __attribute__((__stdcall__)) IRunningObjectTable_GetObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_NoteChangeTime_Proxy(IRunningObjectTable*,DWORD,FILETIME*);
void __attribute__((__stdcall__)) IRunningObjectTable_NoteChangeTime_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_GetTimeOfLastChange_Proxy(IRunningObjectTable*,IMoniker*,FILETIME*);
void __attribute__((__stdcall__)) IRunningObjectTable_GetTimeOfLastChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_EnumRunning_Proxy(IRunningObjectTable*,IEnumMoniker**);
void __attribute__((__stdcall__)) IRunningObjectTable_EnumRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersist_GetClassID_Proxy(IPersist*,CLSID*);
void __attribute__((__stdcall__)) IPersist_GetClassID_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_IsDirty_Proxy(IPersistStream*);
void __attribute__((__stdcall__)) IPersistStream_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_Load_Proxy(IPersistStream*,IStream*);
void __attribute__((__stdcall__)) IPersistStream_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_Save_Proxy(IPersistStream*,IStream*,BOOL);
void __attribute__((__stdcall__)) IPersistStream_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_GetSizeMax_Proxy(IPersistStream*,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IPersistStream_GetSizeMax_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RemoteBindToObject_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IMoniker_RemoteBindToObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RemoteBindToStorage_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IMoniker_RemoteBindToStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Reduce_Proxy(IMoniker*,IBindCtx*,DWORD,IMoniker**,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_Reduce_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_ComposeWith_Proxy(IMoniker*,IMoniker*,BOOL,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_ComposeWith_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Enum_Proxy(IMoniker*,BOOL,IEnumMoniker**);
void __attribute__((__stdcall__)) IMoniker_Enum_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsEqual_Proxy(IMoniker*,IMoniker*);
void __attribute__((__stdcall__)) IMoniker_IsEqual_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Hash_Proxy(IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IMoniker_Hash_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsRunning_Proxy(IMoniker*,IBindCtx*,IMoniker*,IMoniker*);
void __attribute__((__stdcall__)) IMoniker_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_GetTimeOfLastChange_Proxy(IMoniker*,IBindCtx*,IMoniker*,FILETIME*);
void __attribute__((__stdcall__)) IMoniker_GetTimeOfLastChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Inverse_Proxy(IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_Inverse_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_CommonPrefixWith_Proxy(IMoniker*,IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_CommonPrefixWith_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RelativePathTo_Proxy(IMoniker*,IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_RelativePathTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_GetDisplayName_Proxy(IMoniker*,IBindCtx*,IMoniker*,LPCSTR*);
void __attribute__((__stdcall__)) IMoniker_GetDisplayName_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_ParseDisplayName_Proxy(IMoniker*,IBindCtx*,IMoniker*,LPCSTR,ULONG*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_ParseDisplayName_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsSystemMoniker_Proxy(IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IMoniker_IsSystemMoniker_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IROTData_GetComparisonData_Proxy(IROTData*,BYTE*,ULONG cbMax,ULONG*);
void __attribute__((__stdcall__)) IROTData_GetComparisonData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_RemoteNext_Proxy(IEnumString*,ULONG,LPCSTR*rgelt,ULONG*);
void __attribute__((__stdcall__)) IEnumString_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Skip_Proxy(IEnumString*,ULONG);
void __attribute__((__stdcall__)) IEnumString_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Reset_Proxy(IEnumString*);
void __attribute__((__stdcall__)) IEnumString_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Clone_Proxy(IEnumString*,IEnumString**);
void __attribute__((__stdcall__)) IEnumString_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteRead_Proxy(IStream*,BYTE*,ULONG,ULONG*);
void __attribute__((__stdcall__)) IStream_RemoteRead_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteWrite_Proxy(IStream*,BYTE*pv,ULONG,ULONG*);
void __attribute__((__stdcall__)) IStream_RemoteWrite_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteSeek_Proxy(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IStream_RemoteSeek_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_SetSize_Proxy(IStream*,ULARGE_INTEGER);
void __attribute__((__stdcall__)) IStream_SetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteCopyTo_Proxy(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IStream_RemoteCopyTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Commit_Proxy(IStream*,DWORD);
void __attribute__((__stdcall__)) IStream_Commit_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Revert_Proxy(IStream*);
void __attribute__((__stdcall__)) IStream_Revert_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_LockRegion_Proxy(IStream*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) IStream_LockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_UnlockRegion_Proxy(IStream*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) IStream_UnlockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Stat_Proxy(IStream*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) IStream_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Clone_Proxy(IStream*,IStream**);
void __attribute__((__stdcall__)) IStream_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_RemoteNext_Proxy(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
void __attribute__((__stdcall__)) IEnumSTATSTG_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Skip_Proxy(IEnumSTATSTG*,ULONG celt);
void __attribute__((__stdcall__)) IEnumSTATSTG_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Reset_Proxy(IEnumSTATSTG*);
void __attribute__((__stdcall__)) IEnumSTATSTG_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Clone_Proxy(IEnumSTATSTG*,IEnumSTATSTG**);
void __attribute__((__stdcall__)) IEnumSTATSTG_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CreateStream_Proxy(IStorage*,OLECHAR*,DWORD,DWORD,DWORD,IStream**);
void __attribute__((__stdcall__)) IStorage_CreateStream_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RemoteOpenStream_Proxy(IStorage*,const OLECHAR*,unsigned long,BYTE*,DWORD,DWORD,IStream**);
void __attribute__((__stdcall__)) IStorage_RemoteOpenStream_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CreateStorage_Proxy(IStorage*,OLECHAR*,DWORD,DWORD,DWORD,IStorage**);
void __attribute__((__stdcall__)) IStorage_CreateStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStorage_Proxy(IStorage*,OLECHAR*,IStorage*,DWORD,SNB,DWORD,IStorage**);
void __attribute__((__stdcall__)) IStorage_OpenStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CopyTo_Proxy(IStorage*,DWORD,const IID*,SNB,IStorage*);
void __attribute__((__stdcall__)) IStorage_CopyTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_MoveElementTo_Proxy(IStorage*,const OLECHAR*,IStorage*,const OLECHAR*,DWORD);
void __attribute__((__stdcall__)) IStorage_MoveElementTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Commit_Proxy(IStorage*,DWORD);
void __attribute__((__stdcall__)) IStorage_Commit_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Revert_Proxy(IStorage*);
void __attribute__((__stdcall__)) IStorage_Revert_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RemoteEnumElements_Proxy(IStorage*,DWORD,unsigned long,BYTE*,DWORD,IEnumSTATSTG**);
void __attribute__((__stdcall__)) IStorage_RemoteEnumElements_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_DestroyElement_Proxy(IStorage*,OLECHAR*);
void __attribute__((__stdcall__)) IStorage_DestroyElement_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RenameElement_Proxy(IStorage*,const OLECHAR*,const OLECHAR*);
void __attribute__((__stdcall__)) IStorage_RenameElement_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetElementTimes_Proxy(IStorage*,const OLECHAR*,const FILETIME*,const FILETIME*,const FILETIME*);
void __attribute__((__stdcall__)) IStorage_SetElementTimes_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetClass_Proxy(IStorage*,const CLSID&);
void __attribute__((__stdcall__)) IStorage_SetClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetStateBits_Proxy(IStorage*,DWORD,DWORD);
void __attribute__((__stdcall__)) IStorage_SetStateBits_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Stat_Proxy(IStorage*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) IStorage_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_IsDirty_Proxy(IPersistFile*);
void __attribute__((__stdcall__)) IPersistFile_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_Load_Proxy(IPersistFile*,LPCOLESTR,DWORD);
void __attribute__((__stdcall__)) IPersistFile_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_Save_Proxy(IPersistFile*,LPCOLESTR pszFileName,BOOL);
void __attribute__((__stdcall__)) IPersistFile_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_SaveCompleted_Proxy(IPersistFile*,LPCOLESTR);
void __attribute__((__stdcall__)) IPersistFile_SaveCompleted_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_GetCurFile_Proxy(IPersistFile*,LPCSTR*);
void __attribute__((__stdcall__)) IPersistFile_GetCurFile_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_IsDirty_Proxy(IPersistStorage*);
void __attribute__((__stdcall__)) IPersistStorage_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_InitNew_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_InitNew_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_Load_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_Save_Proxy(IPersistStorage*,IStorage*,BOOL);
void __attribute__((__stdcall__)) IPersistStorage_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_SaveCompleted_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_SaveCompleted_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_HandsOffStorage_Proxy(IPersistStorage*);
void __attribute__((__stdcall__)) IPersistStorage_HandsOffStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_RemoteReadAt_Proxy(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
void __attribute__((__stdcall__)) ILockBytes_RemoteReadAt_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_RemoteWriteAt_Proxy(ILockBytes*,ULARGE_INTEGER,BYTE*pv,ULONG,ULONG*);
void __attribute__((__stdcall__)) ILockBytes_RemoteWriteAt_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_Flush_Proxy(ILockBytes*);
void __attribute__((__stdcall__)) ILockBytes_Flush_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_SetSize_Proxy(ILockBytes*,ULARGE_INTEGER);
void __attribute__((__stdcall__)) ILockBytes_SetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_LockRegion_Proxy(ILockBytes*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) ILockBytes_LockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_UnlockRegion_Proxy(ILockBytes*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) ILockBytes_UnlockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_Stat_Proxy(ILockBytes*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) ILockBytes_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_RemoteNext_Proxy(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
void __attribute__((__stdcall__)) IEnumFORMATETC_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Skip_Proxy(IEnumFORMATETC*,ULONG);
void __attribute__((__stdcall__)) IEnumFORMATETC_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Reset_Proxy(IEnumFORMATETC*);
void __attribute__((__stdcall__)) IEnumFORMATETC_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Clone_Proxy(IEnumFORMATETC*,IEnumFORMATETC**);
void __attribute__((__stdcall__)) IEnumFORMATETC_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Next_Proxy(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Next_Stub(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_RemoteNext_Proxy(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
void __attribute__((__stdcall__)) IEnumSTATDATA_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Skip_Proxy(IEnumSTATDATA*,ULONG);
void __attribute__((__stdcall__)) IEnumSTATDATA_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Reset_Proxy(IEnumSTATDATA*);
void __attribute__((__stdcall__)) IEnumSTATDATA_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Clone_Proxy(IEnumSTATDATA*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IEnumSTATDATA_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Next_Proxy(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Next_Stub(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
HRESULT __attribute__((__stdcall__)) IRootStorage_SwitchToFile_Proxy(IRootStorage*,LPCSTR);
void __attribute__((__stdcall__)) IRootStorage_SwitchToFile_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnDataChange_Proxy(IAdviseSink*,FORMATETC*,RemSTGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnDataChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnViewChange_Proxy(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnViewChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnRename_Proxy(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnRename_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnSave_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnSave_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IAdviseSink_RemoteOnClose_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnClose_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_OnDataChange_Proxy(IAdviseSink*,FORMATETC*,STGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_OnDataChange_Stub(IAdviseSink*,FORMATETC*,RemSTGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_OnViewChange_Proxy(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_OnViewChange_Stub(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_OnRename_Proxy(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_OnRename_Stub(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_OnSave_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_OnSave_Stub(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_OnClose_Proxy(IAdviseSink*);
HRESULT __attribute__((__stdcall__)) IAdviseSink_OnClose_Stub(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink2_RemoteOnLinkSrcChange_Proxy(IAdviseSink2*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink2_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink2_OnLinkSrcChange_Proxy(IAdviseSink2*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink2_OnLinkSrcChange_Stub(IAdviseSink2*,IMoniker*);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteGetData_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
void __attribute__((__stdcall__)) IDataObject_RemoteGetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteGetDataHere_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
void __attribute__((__stdcall__)) IDataObject_RemoteGetDataHere_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_QueryGetData_Proxy(IDataObject*,FORMATETC*);
void __attribute__((__stdcall__)) IDataObject_QueryGetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_GetCanonicalFormatEtc_Proxy(IDataObject*,FORMATETC*,FORMATETC*);
void __attribute__((__stdcall__)) IDataObject_GetCanonicalFormatEtc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteSetData_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM*,BOOL);
void __attribute__((__stdcall__)) IDataObject_RemoteSetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_EnumFormatEtc_Proxy(IDataObject*,DWORD,IEnumFORMATETC**);
void __attribute__((__stdcall__)) IDataObject_EnumFormatEtc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_DAdvise_Proxy(IDataObject*,FORMATETC*,DWORD,IAdviseSink*,DWORD*);
void __attribute__((__stdcall__)) IDataObject_DAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_DUnadvise_Proxy(IDataObject*,DWORD);
void __attribute__((__stdcall__)) IDataObject_DUnadvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_EnumDAdvise_Proxy(IDataObject*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IDataObject_EnumDAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_GetData_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*);
HRESULT __attribute__((__stdcall__)) IDataObject_GetData_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
HRESULT __attribute__((__stdcall__)) IDataObject_GetDataHere_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*);
HRESULT __attribute__((__stdcall__)) IDataObject_GetDataHere_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
HRESULT __attribute__((__stdcall__)) IDataObject_SetData_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*,BOOL);
HRESULT __attribute__((__stdcall__)) IDataObject_SetData_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM*,BOOL);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_Advise_Proxy(IDataAdviseHolder*,IDataObject*,FORMATETC*,DWORD,IAdviseSink*,DWORD*);
void __attribute__((__stdcall__)) IDataAdviseHolder_Advise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_Unadvise_Proxy(IDataAdviseHolder*,DWORD);
void __attribute__((__stdcall__)) IDataAdviseHolder_Unadvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_EnumAdvise_Proxy(IDataAdviseHolder*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IDataAdviseHolder_EnumAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_SendOnDataChange_Proxy(IDataAdviseHolder*,IDataObject*,DWORD,DWORD);
void __attribute__((__stdcall__)) IDataAdviseHolder_SendOnDataChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_HandleInComingCall_Proxy(IMessageFilter*,DWORD,HTASK,DWORD,LPINTERFACEINFO);
void __attribute__((__stdcall__)) IMessageFilter_HandleInComingCall_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_RetryRejectedCall_Proxy(IMessageFilter*,HTASK,DWORD,DWORD);
void __attribute__((__stdcall__)) IMessageFilter_RetryRejectedCall_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_MessagePending_Proxy(IMessageFilter*,HTASK,DWORD,DWORD);
void __attribute__((__stdcall__)) IMessageFilter_MessagePending_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_GetBuffer_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*,const IID&);
void __attribute__((__stdcall__)) IRpcChannelBuffer_GetBuffer_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_SendReceive_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*,ULONG*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_SendReceive_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_FreeBuffer_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_FreeBuffer_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_GetDestCtx_Proxy(IRpcChannelBuffer*,DWORD*,void**);
void __attribute__((__stdcall__)) IRpcChannelBuffer_GetDestCtx_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_IsConnected_Proxy(IRpcChannelBuffer*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_IsConnected_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcProxyBuffer_Connect_Proxy(IRpcProxyBuffer*,IRpcChannelBuffer*pRpcChannelBuffer);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Connect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Disconnect_Proxy(IRpcProxyBuffer*);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Disconnect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_Connect_Proxy(IRpcStubBuffer*,IUnknown*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Connect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcStubBuffer_Disconnect_Proxy(IRpcStubBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Disconnect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_Invoke_Proxy(IRpcStubBuffer*,RPCOLEMESSAGE*,IRpcChannelBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Invoke_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
IRpcStubBuffer*__attribute__((__stdcall__)) IRpcStubBuffer_IsIIDSupported_Proxy(IRpcStubBuffer*,const IID&);
void __attribute__((__stdcall__)) IRpcStubBuffer_IsIIDSupported_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IRpcStubBuffer_CountRefs_Proxy(IRpcStubBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_CountRefs_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerQueryInterface_Proxy(IRpcStubBuffer*,void**);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerQueryInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerRelease_Proxy(IRpcStubBuffer*,void*);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerRelease_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPSFactoryBuffer_CreateProxy_Proxy(IPSFactoryBuffer*,IUnknown*,const IID&,IRpcProxyBuffer**,void**);
void __attribute__((__stdcall__)) IPSFactoryBuffer_CreateProxy_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPSFactoryBuffer_CreateStub_Proxy(IPSFactoryBuffer*,const IID&,IUnknown*,IRpcStubBuffer**);
void __attribute__((__stdcall__)) IPSFactoryBuffer_CreateStub_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) SNB_to_xmit(SNB*,RemSNB**);
void __attribute__((__stdcall__)) SNB_from_xmit(RemSNB*,SNB*);
void __attribute__((__stdcall__)) SNB_free_inst(SNB*);
void __attribute__((__stdcall__)) SNB_free_xmit(RemSNB*);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Next_Proxy(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Next_Stub(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Next_Proxy(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Next_Stub(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToObject_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToObject_Stub(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToStorage_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToStorage_Stub(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IEnumString_Next_Proxy(IEnumString*,ULONG,LPCSTR*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumString_Next_Stub(IEnumString*,ULONG,LPCSTR*,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Read_Proxy(IStream*,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Read_Stub(IStream*,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Write_Proxy(IStream*,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Write_Stub(IStream*,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Seek_Proxy(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_Seek_Stub(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_CopyTo_Proxy(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_CopyTo_Stub(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Next_Proxy(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Next_Stub(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStream_Proxy(IStorage*,OLECHAR*,void*,DWORD,DWORD,IStream**);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStream_Stub(IStorage*,OLECHAR*,unsigned long,BYTE*,DWORD,DWORD,IStream** );
HRESULT __attribute__((__stdcall__)) IStorage_EnumElements_Proxy(IStorage*,DWORD,void*,DWORD,IEnumSTATSTG**);
HRESULT __attribute__((__stdcall__)) IStorage_EnumElements_Stub(IStorage*,DWORD,unsigned long,BYTE*,DWORD,IEnumSTATSTG**);
HRESULT __attribute__((__stdcall__)) ILockBytes_ReadAt_Proxy(ILockBytes*,ULARGE_INTEGER,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_ReadAt_Stub(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_WriteAt_Proxy(ILockBytes*,ULARGE_INTEGER,const void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_WriteAt_Stub(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
# 74 "C:/upp/mingw/include/objbase.h" 2 3


inline BOOL IsEqualGUID(const GUID& rguid1, const GUID& rguid2)
 { return !memcmp(&rguid1, &rguid2, sizeof(GUID)); }
inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
 { return !memcmp(&guidOne,&guidOther,sizeof(GUID)); }
inline BOOL operator!=(const GUID& g1, const GUID& g2)
 { return !(g1 == g2); }





# 1 "C:/upp/mingw/include/cguid.h" 1 3



       
# 5 "C:/upp/mingw/include/cguid.h" 3



extern "C" {

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;
extern const CLSID CLSID_CStdPropertyFrame;
extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;
extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;
extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;
extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const GUID GUID_TRISTATE;

}
# 88 "C:/upp/mingw/include/objbase.h" 2 3

typedef enum tagCOINIT {
 COINIT_APARTMENTTHREADED = 0x2,
 COINIT_MULTITHREADED = 0x0,
 COINIT_DISABLE_OLE1DDE = 0x4,
 COINIT_SPEED_OVER_MEMORY = 0x8
} COINIT;
typedef enum tagSTDMSHLFLAGS {
    SMEXF_SERVER = 0x01,
    SMEXF_HANDLER = 0x02
} STDMSHLFLAGS;

extern "C" DWORD __attribute__((__stdcall__)) CoBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitialize(PVOID);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitializeEx(LPVOID,DWORD);
extern "C" void __attribute__((__stdcall__)) CoUninitialize(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetMalloc(DWORD,LPMALLOC*);
extern "C" DWORD __attribute__((__stdcall__)) CoGetCurrentProcess(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterMallocSpy(LPMALLOCSPY);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevokeMallocSpy(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateStandardMalloc(DWORD,IMalloc**);




extern "C" HRESULT __attribute__((__stdcall__)) CoGetClassObject(const CLSID&,DWORD,COSERVERINFO*,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterClassObject(const CLSID&,LPUNKNOWN,DWORD,DWORD,PDWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevokeClassObject(DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetMarshalSizeMax(ULONG*,const IID&,LPUNKNOWN,DWORD,PVOID,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalInterface(LPSTREAM,const IID&,LPUNKNOWN,DWORD,PVOID,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoUnmarshalInterface(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalHresult(LPSTREAM,HRESULT);
extern "C" HRESULT __attribute__((__stdcall__)) CoUnmarshalHresult(LPSTREAM,HRESULT*);
extern "C" HRESULT __attribute__((__stdcall__)) CoReleaseMarshalData(LPSTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) CoDisconnectObject(LPUNKNOWN,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoLockObjectExternal(LPUNKNOWN,BOOL,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetStandardMarshal(const IID&,LPUNKNOWN,DWORD,PVOID,DWORD,LPMARSHAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetStdMarshalEx(LPUNKNOWN,DWORD,LPUNKNOWN*);
extern "C" BOOL __attribute__((__stdcall__)) CoIsHandlerConnected(LPUNKNOWN);
extern "C" BOOL __attribute__((__stdcall__)) CoHasStrongExternalConnections(LPUNKNOWN);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalInterThreadInterfaceInStream(const IID&,LPUNKNOWN,LPSTREAM*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInterfaceAndReleaseStream(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateFreeThreadedMarshaler(LPUNKNOWN,LPUNKNOWN*);
extern "C" HINSTANCE __attribute__((__stdcall__)) CoLoadLibrary(LPOLESTR,BOOL);
extern "C" void __attribute__((__stdcall__)) CoFreeLibrary(HINSTANCE);
extern "C" void __attribute__((__stdcall__)) CoFreeAllLibraries(void);
extern "C" void __attribute__((__stdcall__)) CoFreeUnusedLibraries(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateInstance(const CLSID&,LPUNKNOWN,DWORD,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateInstanceEx(const CLSID&,IUnknown*,DWORD,COSERVERINFO*,DWORD,MULTI_QI*);
extern "C" HRESULT __attribute__((__stdcall__)) StringFromCLSID(const CLSID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) CLSIDFromString(LPOLESTR,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) StringFromIID(const IID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) IIDFromString(LPOLESTR,LPIID);
extern "C" BOOL __attribute__((__stdcall__)) CoIsOle1Class(const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) ProgIDFromCLSID(const CLSID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) CLSIDFromProgID(LPCOLESTR,LPCLSID);
extern "C" int __attribute__((__stdcall__)) StringFromGUID2(const GUID&,LPOLESTR,int);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateGuid(GUID*);
extern "C" BOOL __attribute__((__stdcall__)) CoFileTimeToDosDateTime(FILETIME*,LPWORD,LPWORD);
extern "C" BOOL __attribute__((__stdcall__)) CoDosDateTimeToFileTime(WORD,WORD,FILETIME*);
extern "C" HRESULT __attribute__((__stdcall__)) CoFileTimeNow(FILETIME*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterMessageFilter(LPMESSAGEFILTER,LPMESSAGEFILTER*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetTreatAsClass(const CLSID&,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) CoTreatAsClass(const CLSID&,const CLSID&);
typedef HRESULT (__attribute__((__stdcall__)) *LPFNGETCLASSOBJECT)(const CLSID&,const IID&,PVOID*);
typedef HRESULT (__attribute__((__stdcall__)) *LPFNCANUNLOADNOW)(void);
extern "C" HRESULT __attribute__((__stdcall__)) DllGetClassObject(const CLSID&,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) DllCanUnloadNow(void);
extern "C" PVOID __attribute__((__stdcall__)) CoTaskMemAlloc(ULONG);
extern "C" PVOID __attribute__((__stdcall__)) CoTaskMemRealloc(PVOID,ULONG);
extern "C" void __attribute__((__stdcall__)) CoTaskMemFree(PVOID);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDataAdviseHolder(LPDATAADVISEHOLDER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDataCache(LPUNKNOWN,const CLSID&,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateDocfile(const OLECHAR*,DWORD,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateDocfileOnILockBytes(ILockBytes*,DWORD,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorage(const OLECHAR*,IStorage*,DWORD,SNB,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorageOnILockBytes(ILockBytes*,IStorage*,DWORD,SNB,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgIsStorageFile(const OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) StgIsStorageILockBytes(ILockBytes*);
extern "C" HRESULT __attribute__((__stdcall__)) StgSetTimes(OLECHAR const*,FILETIME const*,FILETIME const*,FILETIME const*);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateStorageEx(const WCHAR*,DWORD,DWORD,DWORD,STGOPTIONS*,void*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorageEx(const WCHAR*,DWORD,DWORD,DWORD,STGOPTIONS*,void*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) BindMoniker(LPMONIKER,DWORD,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetObject(LPCWSTR,BIND_OPTS*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) MkParseDisplayName(LPBC,LPCOLESTR,ULONG*,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) MonikerRelativePathTo(LPMONIKER,LPMONIKER,LPMONIKER*,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) MonikerCommonPrefixWith(LPMONIKER,LPMONIKER,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateBindCtx(DWORD,LPBC*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateGenericComposite(LPMONIKER,LPMONIKER,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) GetClassFile (LPCOLESTR,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateFileMoniker(LPCOLESTR,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateItemMoniker(LPCOLESTR,LPCOLESTR,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateAntiMoniker(LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreatePointerMoniker(LPUNKNOWN,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) GetRunningObjectTable(DWORD,LPRUNNINGOBJECTTABLE*);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitializeSecurity(PSECURITY_DESCRIPTOR,LONG,SOLE_AUTHENTICATION_SERVICE*, void*,DWORD,DWORD,void*,DWORD,void*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetCallContext(const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryProxyBlanket(IUnknown*, DWORD*,DWORD*,OLECHAR**,DWORD*,DWORD*,RPC_AUTH_IDENTITY_HANDLE*,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) CoSetProxyBlanket(IUnknown*,DWORD,DWORD,OLECHAR*,DWORD,DWORD,RPC_AUTH_IDENTITY_HANDLE, DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoCopyProxy(IUnknown*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryClientBlanket(DWORD*,DWORD*,OLECHAR**, DWORD*,DWORD*,RPC_AUTHZ_HANDLE*,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) CoImpersonateClient(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevertToSelf(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryAuthenticationServices(DWORD*, SOLE_AUTHENTICATION_SERVICE**);
extern "C" HRESULT __attribute__((__stdcall__)) CoSwitchCallContext(IUnknown*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInstanceFromFile(COSERVERINFO*, CLSID*,IUnknown*,DWORD,DWORD,OLECHAR*,DWORD,MULTI_QI*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInstanceFromIStorage(COSERVERINFO*,CLSID*, IUnknown*,DWORD,struct IStorage*, DWORD,MULTI_QI*);
extern "C" ULONG __attribute__((__stdcall__)) CoAddRefServerProcess(void);
extern "C" ULONG __attribute__((__stdcall__)) CoReleaseServerProcess(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoResumeClassObjects(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoSuspendClassObjects(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetPSClsid(const IID&,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterPSClsid(const IID&,const CLSID&);

#pragma pack(pop)
# 10 "C:/upp/mingw/include/ole2.h" 2 3
# 1 "C:/upp/mingw/include/olectlid.h" 1 3



       
# 5 "C:/upp/mingw/include/olectlid.h" 3



extern "C" {


extern const GUID IID_IDispatch;
extern const GUID IID_IPropertyNotifySink;
extern const GUID IID_IClassFactory2;
extern const GUID IID_IProvideClassInfo;
extern const GUID IID_IProvideClassInfo2;
extern const GUID IID_IConnectionPointContainer;
extern const GUID IID_IEnumConnectionPoints;
extern const GUID IID_IConnectionPoint;
extern const GUID IID_IEnumConnections;
extern const GUID IID_IOleControl;
extern const GUID IID_IOleControlSite;
extern const GUID IID_ISimpleFrameSite;
extern const GUID IID_IPersistStreamInit;
extern const GUID IID_IPersistMemory;
extern const GUID IID_IPersistPropertyBag;
extern const GUID IID_IPropertyBag;
extern const GUID IID_IErrorLog;
extern const GUID IID_IPropertyFrame;
extern const GUID IID_ISpecifyPropertyPages;
extern const GUID IID_IPerPropertyBrowsing;
extern const GUID IID_IPropertyPageSite;
extern const GUID IID_IPropertyPage;
extern const GUID IID_IPropertyPage2;
extern const GUID CLSID_CFontPropPage;
extern const GUID CLSID_CColorPropPage;
extern const GUID CLSID_CPicturePropPage;
extern const GUID CLSID_PersistPropset;
extern const GUID CLSID_ConvertVBX;
extern const GUID CLSID_StdFont;
extern const GUID CLSID_StdPicture;
extern const GUID IID_IFont;
extern const GUID IID_IFontDisp;
extern const GUID IID_IPicture;
extern const GUID IID_IPictureDisp;
extern const GUID GUID_HIMETRIC;
extern const GUID GUID_COLOR;
extern const GUID GUID_XPOSPIXEL;
extern const GUID GUID_YPOSPIXEL;
extern const GUID GUID_XSIZEPIXEL;
extern const GUID GUID_YSIZEPIXEL;
extern const GUID GUID_XPOS;
extern const GUID GUID_YPOS;
extern const GUID GUID_XSIZE;
extern const GUID GUID_YSIZE;
extern const GUID GUID_TRISTATE;
extern const GUID GUID_OPTIONVALUEEXCLUSIVE;
extern const GUID GUID_CHECKVALUEEXCLUSIVE;
extern const GUID GUID_FONTNAME;
extern const GUID GUID_FONTSIZE;
extern const GUID GUID_FONTBOLD;
extern const GUID GUID_FONTITALIC;
extern const GUID GUID_FONTUNDERSCORE;
extern const GUID GUID_FONTSTRIKETHROUGH;
extern const GUID GUID_HANDLE;
extern const GUID IID_IEnumUnknown;
extern const GUID IID_IEnumString;
extern const GUID IID_IEnumMoniker;
extern const GUID IID_IEnumFORMATETC;
extern const GUID IID_IEnumOLEVERB;
extern const GUID IID_IEnumSTATDATA;
extern const GUID IID_IEnumSTATSTG;
extern const GUID IID_IEnumGeneric;
extern const GUID IID_IEnumHolder;
extern const GUID IID_IEnumCallback;
extern const GUID IID_IPersistStream;
extern const GUID IID_IPersistStorage;
extern const GUID IID_IPersistFile;
extern const GUID IID_IPersist;
extern const GUID IID_IViewObject;
extern const GUID IID_IDataObject;
extern const GUID IID_IAdviseSink;
extern const GUID IID_IDataAdviseHolder;
extern const GUID IID_IOleAdviseHolder;
extern const GUID IID_IOleObject;
extern const GUID IID_IOleInPlaceObject;
extern const GUID IID_IOleWindow;
extern const GUID IID_IOleInPlaceUIWindow;
extern const GUID IID_IOleInPlaceFrame;
extern const GUID IID_IOleInPlaceActiveObject;
extern const GUID IID_IOleClientSite;
extern const GUID IID_IOleInPlaceSite;
extern const GUID IID_IParseDisplayName;
extern const GUID IID_IOleContainer;
extern const GUID IID_IOleItemContainer;
extern const GUID IID_IOleLink;
extern const GUID IID_IOleCache;
extern const GUID IID_IOleManager;
extern const GUID IID_IOlePresObj;
extern const GUID IID_IDropSource;
extern const GUID IID_IDropTarget;
extern const GUID IID_IDebug;
extern const GUID IID_IDebugStream;
extern const GUID IID_IAdviseSink2;
extern const GUID IID_IRunnableObject;
extern const GUID IID_IViewObject2;
extern const GUID IID_IOleCache2;
extern const GUID IID_IOleCacheControl;
extern const GUID CLSID_Picture_Metafile;
extern const GUID CLSID_Picture_Dib;


}
# 11 "C:/upp/mingw/include/ole2.h" 2 3
# 1 "C:/upp/mingw/include/oleauto.h" 1 3



       
# 5 "C:/upp/mingw/include/oleauto.h" 3


#pragma pack(push,8)
# 158 "C:/upp/mingw/include/oleauto.h" 3
# 1 "C:/upp/mingw/include/oaidl.h" 1 3



       
# 5 "C:/upp/mingw/include/oaidl.h" 3




# 1 "C:/upp/mingw/include/ole2.h" 1 3
# 10 "C:/upp/mingw/include/oaidl.h" 2 3



extern "C" {
# 66 "C:/upp/mingw/include/oaidl.h" 3
typedef struct ITypeLib *LPTYPELIB;
typedef struct ITypeLib2 *LPTYPELIB2;
typedef struct ICreateTypeInfo *LPCREATETYPEINFO;
typedef struct ICreateTypeInfo2 *LPCREATETYPEINFO2;
typedef struct ICreateTypeLib *LPCREATETYPELIB;
typedef struct ICreateTypeLib2 *LPCREATETYPELIB2;
typedef struct ITypeComp *LPTYPECOMP;
typedef struct ITypeInfo *LPTYPEINFO;
typedef struct ITypeInfo2 *LPTYPEINFO2;
typedef struct IErrorInfo *LPERRORINFO;
typedef struct IDispatch *LPDISPATCH;
typedef struct IEnumVARIANT *LPENUMVARIANT;
typedef struct ICreateErrorInfo *LPCREATEERRORINFO;
typedef struct ISupportErrorInfo *LPSUPPORTERRORINFO;
typedef struct IRecordInfo *LPRECORDINFO;

extern const IID IID_ITypeLib;
extern const IID IID_ITypeLib2;
extern const IID IID_ICreateTypeInfo;
extern const IID IID_ICreateTypeInfo2;
extern const IID IID_ICreateTypeLib;
extern const IID IID_ICreateTypeLib2;
extern const IID IID_ITypeInfo;
extern const IID IID_ITypeInfo2;
extern const IID IID_IErrorInfo;
extern const IID IID_IDispatch;
extern const IID IID_IEnumVARIANT;
extern const IID IID_ICreateErrorInfo;
extern const IID IID_ISupportErrorInfo;
extern const IID IID_IRecordInfo;
extern const IID IID_ITypeMarshal;

typedef enum tagSYSKIND {
 SYS_WIN16,SYS_WIN32,SYS_MAC
} SYSKIND;
typedef enum tagLIBFLAGS {
 LIBFLAG_FRESTRICTED=1,LIBFLAG_FCONTROL=2,LIBFLAG_FHIDDEN=4,
 LIBFLAG_FHASDISKIMAGE=8
} LIBFLAGS;
typedef struct tagTLIBATTR {
 GUID guid;
 LCID lcid;
 SYSKIND syskind;
 WORD wMajorVerNum;
 WORD wMinorVerNum;
 WORD wLibFlags;
} TLIBATTR,*LPTLIBATTR;
typedef CY CURRENCY;
typedef struct tagSAFEARRAYBOUND {
 ULONG cElements;
 LONG lLbound;
}SAFEARRAYBOUND,*LPSAFEARRAYBOUND;
typedef struct _wireSAFEARR_BSTR
{
 ULONG Size;
 wireBSTR *aBstr;
}SAFEARR_BSTR;
typedef struct _wireSAFEARR_UNKNOWN {
 ULONG Size;
 IUnknown **apUnknown;
}SAFEARR_UNKNOWN;
typedef struct _wireSAFEARR_DISPATCH {
 ULONG Size;
 LPDISPATCH *apDispatch;
}SAFEARR_DISPATCH;
typedef struct _wireSAFEARR_VARIANT {
 ULONG Size;
 struct _wireVARIANT *aVariant;
}SAFEARR_VARIANT;
typedef enum tagSF_TYPE {
 SF_ERROR=VT_ERROR,
 SF_I1=VT_I1,
 SF_I2=VT_I2,
 SF_I4=VT_I4,
 SF_I8=VT_I8,
 SF_BSTR=VT_BSTR,
 SF_UNKNOWN=VT_UNKNOWN,
 SF_DISPATCH=VT_DISPATCH,
 SF_VARIANT=VT_VARIANT
}SF_TYPE;
typedef struct _wireBRECORD {
 ULONG fFlags;
 ULONG clSize;
 LPRECORDINFO* pRecInfo;
 byte* pRecord;
} *wireBRECORD;
typedef struct _wireSAFEARR_BRECORD {
    ULONG Size;
    wireBRECORD* aRecord;
    } SAFEARR_BRECORD;
typedef struct _wireSAFEARR_HAVEIID {
 ULONG Size;
 IUnknown** apUnknown;
 IID iid;
 } SAFEARR_HAVEIID;
typedef struct _wireSAFEARRAY_UNION {
 ULONG sfType;
 union {
  SAFEARR_BSTR BstrStr;
  SAFEARR_UNKNOWN UnknownStr;
  SAFEARR_DISPATCH DispatchStr;
  SAFEARR_VARIANT VariantStr;
  SAFEARR_BRECORD RecordStr;
  SAFEARR_HAVEIID HaveIidStr;
  BYTE_SIZEDARR ByteStr;
  WORD_SIZEDARR WordStr;
  DWORD_SIZEDARR LongStr;
  HYPER_SIZEDARR HyperStr;
 }u;
}SAFEARRAYUNION;
typedef struct _wireSAFEARRAY {
 USHORT cDims;
 USHORT fFeatures;
 ULONG cbElements;
 ULONG cLocks;
 SAFEARRAYUNION uArrayStructs;
 SAFEARRAYBOUND rgsabound[1];
}*wireSAFEARRAY;
typedef wireSAFEARRAY *wirePSAFEARRAY;
typedef struct tagSAFEARRAY {
 USHORT cDims;
 USHORT fFeatures;
 ULONG cbElements;
 ULONG cLocks;
 PVOID pvData;
 SAFEARRAYBOUND rgsabound[1];
}SAFEARRAY,*LPSAFEARRAY;

__extension__

typedef struct tagVARIANT {
  __extension__ union {
 struct {
 VARTYPE vt;
 WORD wReserved1;
 WORD wReserved2;
 WORD wReserved3;
 __extension__ union {
  long lVal;
  LONGLONG llVal;
  unsigned char bVal;
  short iVal;
  float fltVal;
  double dblVal;
  VARIANT_BOOL boolVal;
  SCODE scode;
  CY cyVal;
  DATE date;
  BSTR bstrVal;
  IUnknown *punkVal;
  LPDISPATCH pdispVal;
  SAFEARRAY *parray;
  unsigned char *pbVal;
  short *piVal;
  long *plVal;
  LONGLONG * pllVal;
  float *pfltVal;
  double *pdblVal;
  VARIANT_BOOL *pboolVal;
  _VARIANT_BOOL *pbool;
  SCODE *pscode;
  CY *pcyVal;
  DATE *pdate;
  BSTR *pbstrVal;
  IUnknown **ppunkVal;
  LPDISPATCH *ppdispVal;
  SAFEARRAY **pparray;
  struct tagVARIANT *pvarVal;
  void *byref;
  CHAR cVal;
  USHORT uiVal;
  ULONG ulVal;
  ULONGLONG ullVal;
  INT intVal;
  UINT uintVal;
  DECIMAL *pdecVal;
  CHAR *pcVal;
  USHORT *puiVal;
  ULONG *pulVal;
  ULONGLONG * pullVal;
  INT *pintVal;
  UINT *puintVal;
  __extension__ struct {
   PVOID pvRecord;
   struct IRecordInfo *pRecInfo;
  } ;
 } ;
    } ;
    DECIMAL decVal;
  } ;
} VARIANT,*LPVARIANT;
typedef VARIANT VARIANTARG;
typedef VARIANT *LPVARIANTARG;
typedef struct _wireVARIANT {
 DWORD clSize;
 DWORD rpcReserved;
 USHORT vt;
 USHORT wReserved1;
 USHORT wReserved2;
 USHORT wReserved3;
 __extension__ union {
  LONG lVal;
  LONGLONG llVal;
  BYTE bVal;
  SHORT iVal;
  FLOAT fltVal;
  DOUBLE dblVal;
  VARIANT_BOOL boolVal;
  SCODE scode;
  CY cyVal;
  DATE date;
  wireBSTR bstrVal;
  IUnknown *punkVal;
  LPDISPATCH pdispVal;
  wirePSAFEARRAY parray;
  wireBRECORD brecVal;
  BYTE *pbVal;
  SHORT *piVal;
  LONG *plVal;
  FLOAT *pfltVal;
  DOUBLE *pdblVal;
  VARIANT_BOOL *pboolVal;
  SCODE *pscode;
  CY *pcyVal;
  DATE *pdate;
  wireBSTR *pbstrVal;
  IUnknown **ppunkVal;
  LPDISPATCH *ppdispVal;
  wirePSAFEARRAY *pparray;
  struct _wireVARIANT *pvarVal;
  CHAR cVal;
  USHORT uiVal;
  ULONG ulVal;
  ULONGLONG ullVal;
  INT intVal;
  UINT uintVal;
  DECIMAL decVal;
  DECIMAL *pdecVal;
  CHAR *pcVal;
  USHORT *puiVal;
  ULONG *pulVal;
  INT *pintVal;
  UINT *puintVal;
 } ;
} *wireVARIANT;
typedef LONG DISPID;
typedef DISPID MEMBERID;
typedef DWORD HREFTYPE;
typedef enum tagTYPEKIND {
 TKIND_ENUM,TKIND_RECORD,TKIND_MODULE,TKIND_INTERFACE,TKIND_DISPATCH,
 TKIND_COCLASS,TKIND_ALIAS,TKIND_UNION,TKIND_MAX
}TYPEKIND;
typedef struct tagTYPEDESC {
 __extension__ union {
  struct tagTYPEDESC *lptdesc;
  struct tagARRAYDESC *lpadesc;
  HREFTYPE hreftype;
 } ;
 VARTYPE vt;
}TYPEDESC;
typedef struct tagARRAYDESC {
 TYPEDESC tdescElem;
 USHORT cDims;
 SAFEARRAYBOUND rgbounds[1];
}ARRAYDESC;
typedef struct tagPARAMDESCEX {
 ULONG cBytes;
 VARIANTARG varDefaultValue;
}PARAMDESCEX,*LPPARAMDESCEX;
typedef struct tagPARAMDESC {
 LPPARAMDESCEX pparamdescex;
 USHORT wParamFlags;
}PARAMDESC,*LPPARAMDESC;
typedef struct tagIDLDESC {
 ULONG dwReserved;
 USHORT wIDLFlags;
}IDLDESC,*LPIDLDESC;
typedef struct tagELEMDESC {
 TYPEDESC tdesc;
 __extension__ union {
  IDLDESC idldesc;
  PARAMDESC paramdesc;
 } ;
} ELEMDESC,*LPELEMDESC;
typedef struct tagTYPEATTR {
 GUID guid;
 LCID lcid;
 DWORD dwReserved;
 MEMBERID memidConstructor;
 MEMBERID memidDestructor;
 LPOLESTR lpstrSchema;
 ULONG cbSizeInstance;
 TYPEKIND typekind;
 WORD cFuncs;
 WORD cVars;
 WORD cImplTypes;
 WORD cbSizeVft;
 WORD cbAlignment;
 WORD wTypeFlags;
 WORD wMajorVerNum;
 WORD wMinorVerNum;
 TYPEDESC tdescAlias;
 IDLDESC idldescType;
}TYPEATTR,*LPTYPEATTR;
typedef struct tagDISPPARAMS {
 VARIANTARG *rgvarg;
 DISPID *rgdispidNamedArgs;
 UINT cArgs;
 UINT cNamedArgs;
}DISPPARAMS;
typedef struct tagEXCEPINFO {
 WORD wCode;
 WORD wReserved;
 BSTR bstrSource;
 BSTR bstrDescription;
 BSTR bstrHelpFile;
 DWORD dwHelpContext;
 PVOID pvReserved;
 HRESULT(__attribute__((__stdcall__)) * pfnDeferredFillIn)(struct tagEXCEPINFO*);
 SCODE scode;
} EXCEPINFO,*LPEXCEPINFO;
typedef enum tagCALLCONV {
 CC_FASTCALL,CC_CDECL,CC_MSCPASCAL,CC_PASCAL=CC_MSCPASCAL,
 CC_MACPASCAL,CC_STDCALL,CC_FPFASTCALL,CC_SYSCALL,CC_MPWCDECL,
 CC_MPWPASCAL,CC_MAX=CC_MPWPASCAL
}CALLCONV;
typedef enum tagFUNCKIND {
 FUNC_VIRTUAL,FUNC_PUREVIRTUAL,FUNC_NONVIRTUAL,
 FUNC_STATIC,FUNC_DISPATCH
}FUNCKIND;
typedef enum tagINVOKEKIND {
 INVOKE_FUNC=1,INVOKE_PROPERTYGET,INVOKE_PROPERTYPUT=4,
 INVOKE_PROPERTYPUTREF=8
}INVOKEKIND;
typedef struct tagFUNCDESC {
 MEMBERID memid;
 SCODE *lprgscode;
 ELEMDESC *lprgelemdescParam;
 FUNCKIND funckind;
 INVOKEKIND invkind;
 CALLCONV callconv;
 SHORT cParams;
 SHORT cParamsOpt;
 SHORT oVft;
 SHORT cScodes;
 ELEMDESC elemdescFunc;
 WORD wFuncFlags;
}FUNCDESC,*LPFUNCDESC;
typedef enum tagVARKIND {
 VAR_PERINSTANCE,VAR_STATIC,VAR_CONST,VAR_DISPATCH
} VARKIND;
typedef struct tagVARDESC {
 MEMBERID memid;
 LPOLESTR lpstrSchema;
 __extension__ union {
  ULONG oInst;
  VARIANT *lpvarValue;
 } ;
 ELEMDESC elemdescVar;
 WORD wVarFlags;
 VARKIND varkind;
} VARDESC,*LPVARDESC;
typedef enum tagTYPEFLAGS {
 TYPEFLAG_FAPPOBJECT=1,TYPEFLAG_FCANCREATE=2,TYPEFLAG_FLICENSED=4,
 TYPEFLAG_FPREDECLID=8,TYPEFLAG_FHIDDEN=16,TYPEFLAG_FCONTROL=32,
 TYPEFLAG_FDUAL=64,TYPEFLAG_FNONEXTENSIBLE=128,
 TYPEFLAG_FOLEAUTOMATION=256,TYPEFLAG_FRESTRICTED=512,
 TYPEFLAG_FAGGREGATABLE=1024,TYPEFLAG_FREPLACEABLE=2048,
 TYPEFLAG_FDISPATCHABLE=4096,TYPEFLAG_FREVERSEBIND=8192
} TYPEFLAGS;
typedef enum tagFUNCFLAGS {
 FUNCFLAG_FRESTRICTED=1,FUNCFLAG_FSOURCE=2,FUNCFLAG_FBINDABLE=4,
 FUNCFLAG_FREQUESTEDIT=8,FUNCFLAG_FDISPLAYBIND=16,FUNCFLAG_FDEFAULTBIND=32,
 FUNCFLAG_FHIDDEN=64,FUNCFLAG_FUSESGETLASTERROR=128,FUNCFLAG_FDEFAULTCOLLELEM=256,
 FUNCFLAG_FUIDEFAULT=512,FUNCFLAG_FNONBROWSABLE=1024,FUNCFLAG_FREPLACEABLE=2048,
 FUNCFLAG_FIMMEDIATEBIND=4096
} FUNCFLAGS;
typedef enum tagVARFLAGS {
 VARFLAG_FREADONLY=1,VARFLAG_FSOURCE=2,VARFLAG_FBINDABLE=4,VARFLAG_FREQUESTEDIT=8,
 VARFLAG_FDISPLAYBIND=16,VARFLAG_FDEFAULTBIND=32,VARFLAG_FHIDDEN=64,VARFLAG_FRESTRICTED=128,
 VARFLAG_FDEFAULTCOLLELEM=256,VARFLAG_FUIDEFAULT=512,VARFLAG_FNONBROWSABLE=1024,
 VARFLAG_FREPLACEABLE=2048,VARFLAG_FIMMEDIATEBIND=4096
} VARFLAGS;
typedef struct tagCLEANLOCALSTORAGE {
 IUnknown *pInterface;
 PVOID pStorage;
 DWORD flags;
} CLEANLOCALSTORAGE;
typedef struct tagCUSTDATAITEM {
 GUID guid;
 VARIANTARG varValue;
} CUSTDATAITEM,*LPCUSTDATAITEM;
typedef struct tagCUSTDATA {
 DWORD cCustData;
 LPCUSTDATAITEM prgCustData;
} CUSTDATA,*LPCUSTDATA;

typedef enum tagDESCKIND {
        DESCKIND_NONE=0,DESCKIND_FUNCDESC=DESCKIND_NONE+1,
        DESCKIND_VARDESC=DESCKIND_FUNCDESC+1,DESCKIND_TYPECOMP=DESCKIND_VARDESC+1,
        DESCKIND_IMPLICITAPPOBJ=DESCKIND_TYPECOMP+1,
        DESCKIND_MAX=DESCKIND_IMPLICITAPPOBJ+1
} DESCKIND;

typedef union tagBINDPTR {
        LPFUNCDESC lpfuncdesc;
        LPVARDESC lpvardesc;
        LPTYPECOMP lptcomp;
} BINDPTR,*LPBINDPTR;


struct IDispatch : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoCount( UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,LCID,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( const IID&,LPOLESTR*,UINT,LCID,DISPID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( DISPID,const IID&,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
};
# 500 "C:/upp/mingw/include/oaidl.h" 3
struct IEnumVARIANT : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,VARIANT*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) Reset(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumVARIANT**) =0;
};



struct ITypeComp : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Bind( LPOLESTR,ULONG,WORD,LPTYPEINFO*,DESCKIND*,LPBINDPTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindType( LPOLESTR,ULONG,LPTYPEINFO*,LPTYPECOMP*) =0;
};



struct ITypeInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeAttr( LPTYPEATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( LPTYPECOMP*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncDesc( UINT,LPFUNCDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarDesc( UINT,LPVARDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetNames( MEMBERID,BSTR*,UINT,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeOfImplType( UINT,HREFTYPE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeFlags( UINT,INT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( LPOLESTR*,UINT,MEMBERID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( PVOID,MEMBERID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( MEMBERID,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDllEntry( MEMBERID,INVOKEKIND,BSTR*,BSTR*,WORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeInfo( HREFTYPE,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddressOfMember( MEMBERID,INVOKEKIND,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMops( MEMBERID,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainingTypeLib( LPTYPELIB*,UINT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTypeAttr( LPTYPEATTR) =0;
 virtual void __attribute__((__stdcall__)) ReleaseFuncDesc( LPFUNCDESC) =0;
 virtual void __attribute__((__stdcall__)) ReleaseVarDesc( LPVARDESC) =0;
};
# 577 "C:/upp/mingw/include/oaidl.h" 3
struct ITypeInfo2 : public ITypeInfo
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeAttr( LPTYPEATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( LPTYPECOMP*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncDesc( UINT,LPFUNCDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarDesc( UINT,LPVARDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetNames( MEMBERID,BSTR*,UINT,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeOfImplType( UINT,HREFTYPE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeFlags( UINT,INT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( LPOLESTR*,UINT,MEMBERID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( PVOID,MEMBERID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( MEMBERID,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDllEntry( MEMBERID,INVOKEKIND,BSTR*,BSTR*,WORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeInfo( HREFTYPE,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddressOfMember( MEMBERID,INVOKEKIND,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMops( MEMBERID,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainingTypeLib( LPTYPELIB*,UINT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTypeAttr( LPTYPEATTR) =0;
 virtual void __attribute__((__stdcall__)) ReleaseFuncDesc( LPFUNCDESC) =0;
 virtual void __attribute__((__stdcall__)) ReleaseVarDesc( LPVARDESC) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeKind( TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeFlags( ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncIndexOfMemId( MEMBERID,INVOKEKIND,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarIndexOfMemId( MEMBERID,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCustData( const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetParamCustData( UINT,UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation2( MEMBERID,LCID,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllCustData( CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllFuncCustData( UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllParamCustData( UINT,UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllVarCustData( UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllImplTypeCustData( UINT,CUSTDATA*) =0;
};



struct ITypeLib : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual UINT __attribute__((__stdcall__)) GetTypeInfoCount(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoType( UINT,TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoOfGuid( const GUID&,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibAttr( TLIBATTR**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( ITypeComp*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( INT,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsName( LPOLESTR,ULONG,BOOL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) FindName( LPOLESTR,ULONG,ITypeInfo**,MEMBERID*,USHORT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTLibAttr( TLIBATTR*) =0;
};



struct ITypeLib2 : public ITypeLib
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual UINT __attribute__((__stdcall__)) GetTypeInfoCount(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoType( UINT,TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoOfGuid( const GUID&,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibAttr( TLIBATTR**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( ITypeComp*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( INT,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsName( LPOLESTR,ULONG,BOOL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) FindName( LPOLESTR,ULONG,ITypeInfo**,MEMBERID*,USHORT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTLibAttr( TLIBATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCustData( const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibStatistics( ULONG*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation2( INT,LCID,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllCustData( CUSTDATA*) =0;
};


extern "C" const IID IID_IErrorInfo;

struct IErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetGUID( GUID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSource( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDescription( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetHelpFile( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetHelpContext( DWORD*) =0;
};
# 687 "C:/upp/mingw/include/oaidl.h" 3
extern "C" const IID IID_ICreateErrorInfo;

struct ICreateErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*)=0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetGUID( const GUID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSource( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetDescription( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHelpFile( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHelpContext( DWORD) =0;
};


extern "C" const IID IID_ISupportErrorInfo;

struct ISupportErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) InterfaceSupportsErrorInfo( const IID&) =0;
};


extern "C" const IID IID_IRecordInfo;

struct IRecordInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordInit( PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordClear( PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordCopy( PVOID, PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetGuid( GUID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetName( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSize( ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetField( PVOID,LPCOLESTR,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFieldNoCopy( PVOID,LPCOLESTR,VARIANT*,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) PutField( ULONG,PVOID,LPCOLESTR, VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) PutFieldNoCopy( ULONG,PVOID,LPCOLESTR,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFieldNames( ULONG*,BSTR*) =0;
 virtual BOOL __attribute__((__stdcall__)) IsMatchingType( void) =0;
 virtual PVOID __attribute__((__stdcall__)) RecordCreate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordCreateCopy( PVOID,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordDestroy( PVOID) =0;
};
# 761 "C:/upp/mingw/include/oaidl.h" 3
extern "C" const IID IID_ITypeMarshal;

struct ITypeMarshal : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Size( PVOID,DWORD,PVOID,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Marshal( PVOID,DWORD,PVOID,ULONG,BYTE*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unmarshal( PVOID,DWORD,ULONG,BYTE*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Free( PVOID) =0;
};



}
# 159 "C:/upp/mingw/include/oleauto.h" 2 3

typedef enum tagREGKIND {
 REGKIND_DEFAULT,
 REGKIND_REGISTER,
 REGKIND_NONE
} REGKIND;
typedef struct tagPARAMDATA {
 OLECHAR *szName;
 VARTYPE vt;
} PARAMDATA,*LPPARAMDATA;
typedef struct tagMETHODDATA {
 OLECHAR *szName;
 PARAMDATA *ppdata;
 DISPID dispid;
 UINT iMeth;
 CALLCONV cc;
 UINT cArgs;
 WORD wFlags;
 VARTYPE vtReturn;
} METHODDATA,*LPMETHODDATA;
typedef struct tagINTERFACEDATA {
 METHODDATA *pmethdata;
 UINT cMembers;
} INTERFACEDATA,*LPINTERFACEDATA;

typedef struct {
 SYSTEMTIME st;
 USHORT wDayOfYear;
} UDATE;

typedef struct {
 int cDig;
 unsigned long dwInFlags;
 unsigned long dwOutFlags;
 int cchUsed;
 int nBaseShift;
 int nPwr10;
} NUMPARSE;

extern "C" BSTR __attribute__((__stdcall__)) SysAllocString(const OLECHAR*);
extern "C" int __attribute__((__stdcall__)) SysReAllocString(BSTR*,const OLECHAR*);
extern "C" BSTR __attribute__((__stdcall__)) SysAllocStringLen(const OLECHAR*,unsigned int);
extern "C" int __attribute__((__stdcall__)) SysReAllocStringLen(BSTR*,const OLECHAR*,unsigned int);
extern "C" void __attribute__((__stdcall__)) SysFreeString(BSTR);
extern "C" unsigned int __attribute__((__stdcall__)) SysStringLen(BSTR);
extern "C" unsigned int __attribute__((__stdcall__)) SysStringByteLen(BSTR);
extern "C" BSTR __attribute__((__stdcall__)) SysAllocStringByteLen(const char*,unsigned int);
extern "C" int __attribute__((__stdcall__)) DosDateTimeToVariantTime(unsigned short,unsigned short,double*);
extern "C" int __attribute__((__stdcall__)) VariantTimeToDosDateTime(double,unsigned short*,unsigned short*);
extern "C" int __attribute__((__stdcall__)) VariantTimeToSystemTime(double,LPSYSTEMTIME);
extern "C" int __attribute__((__stdcall__)) SystemTimeToVariantTime(LPSYSTEMTIME, double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUdate(UDATE*,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUdateEx(UDATE*,LCID,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUdateFromDate(DATE,ULONG,UDATE*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocDescriptor(unsigned int,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocData(SAFEARRAY*);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreate(VARTYPE,unsigned int,SAFEARRAYBOUND*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroyDescriptor(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroyData(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroy(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayRedim(SAFEARRAY*,SAFEARRAYBOUND*);
extern "C" unsigned int __attribute__((__stdcall__)) SafeArrayGetDim(SAFEARRAY*);
extern "C" unsigned int __attribute__((__stdcall__)) SafeArrayGetElemsize(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetUBound(SAFEARRAY*,unsigned int,long*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetLBound(SAFEARRAY*,unsigned int,long*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayLock(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayUnlock(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAccessData(SAFEARRAY*,void**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayUnaccessData(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetElement(SAFEARRAY*,long*,void*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayPutElement(SAFEARRAY*,long*,void*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayCopy(SAFEARRAY*,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayPtrOfIndex(SAFEARRAY*,long*,void**);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreateVector(VARTYPE,LONG,ULONG);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreateVectorEx(VARTYPE,LONG,ULONG,LPVOID);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocDescriptorEx(VARTYPE,UINT,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetVartype(SAFEARRAY*,VARTYPE*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArraySetRecordInfo(SAFEARRAY*,IRecordInfo*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetRecordInfo(SAFEARRAY*,IRecordInfo**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArraySetIID(SAFEARRAY*,const GUID&);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetIID(SAFEARRAY*,GUID*);
extern "C" void __attribute__((__stdcall__)) VariantInit(VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantClear(VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantCopy(VARIANTARG*,VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantCopyInd(VARIANT*,VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantChangeType(VARIANTARG*,VARIANTARG*,unsigned short,VARTYPE);
extern "C" HRESULT __attribute__((__stdcall__)) VariantChangeTypeEx(VARIANTARG*,VARIANTARG*,LCID,unsigned short,VARTYPE);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI2(short,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI4(long,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR4(float,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR8(double,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromCy(CY,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDate(DATE,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromStr(OLECHAR*,LCID,unsigned long,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDisp(LPDISPATCH,LCID,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromBool(VARIANT_BOOL,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI1(unsigned char,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI4(long,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR4(float,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR8(double,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromCy(CY cyIn,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDate(DATE,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromStr(OLECHAR*,LCID,unsigned long,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDisp(LPDISPATCH,LCID,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromBool(VARIANT_BOOL,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI1(unsigned char,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI2(short,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR4(float,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR8(double,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromCy(CY,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDate(DATE,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromStr(OLECHAR*,LCID,unsigned long,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDisp(LPDISPATCH,LCID,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromBool(VARIANT_BOOL,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI1(unsigned char,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI2(short,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI4(long,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromR8(double,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromCy(CY,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDate(DATE,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromStr(OLECHAR*,LCID,unsigned long,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDisp(LPDISPATCH,LCID,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromBool(VARIANT_BOOL,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI1(unsigned char,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI2(short,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI4(long,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromR4(float,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromCy(CY,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDate(DATE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromStr(OLECHAR*,LCID,unsigned long,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDisp(LPDISPATCH,LCID,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromBool(VARIANT_BOOL,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDec(DECIMAL*,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI1(unsigned char,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI2(short,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI4(long,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR4(float,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR8(double,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromCy(CY,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromStr(OLECHAR*,LCID,unsigned long,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDisp(LPDISPATCH,LCID,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromBool(VARIANT_BOOL,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI1(unsigned char,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI2(short,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI4(long,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR4(float,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR8(double,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDate(DATE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,unsigned long,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDisp(LPDISPATCH,LCID,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromBool(VARIANT_BOOL,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI1(unsigned char,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI2(short,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI4(long,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR4(float,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR8(double,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromCy(CY,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDate(DATE,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDisp(LPDISPATCH,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromBool(VARIANT_BOOL,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI1(unsigned char,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI2(short,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI4(long,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR4(float,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR8(double,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDate(DATE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromCy(CY,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromStr(OLECHAR*,LCID,unsigned long,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDisp(LPDISPATCH,LCID,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR8(double,DECIMAL*);
extern "C" ULONG __attribute__((__stdcall__)) LHashValOfNameSysA(SYSKIND,LCID,const char*);
extern "C" ULONG __attribute__((__stdcall__)) LHashValOfNameSys(SYSKIND,LCID,const OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadTypeLib(const OLECHAR*,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadTypeLibEx(LPCOLESTR,REGKIND,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadRegTypeLib(const GUID&,WORD,WORD,LCID,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) QueryPathOfRegTypeLib(const GUID&,unsigned short,unsigned short,LCID,LPBSTR);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterTypeLib(LPTYPELIB,OLECHAR*,OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) UnRegisterTypeLib(const GUID&,WORD,WORD,LCID,SYSKIND);
extern "C" HRESULT __attribute__((__stdcall__)) CreateTypeLib(SYSKIND,const OLECHAR*,LPCREATETYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) DispGetParam(DISPPARAMS*,UINT,VARTYPE,VARIANT*,UINT*);
extern "C" HRESULT __attribute__((__stdcall__)) DispGetIDsOfNames(LPTYPEINFO,OLECHAR**,UINT,DISPID*);
extern "C" HRESULT __attribute__((__stdcall__)) DispInvoke(void*,LPTYPEINFO,DISPID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDispTypeInfo(INTERFACEDATA*,LCID,LPTYPEINFO*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateStdDispatch(IUnknown*,void*,LPTYPEINFO,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterActiveObject(IUnknown*,const CLSID&,DWORD,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) RevokeActiveObject(DWORD,void*);
extern "C" HRESULT __attribute__((__stdcall__)) GetActiveObject(const CLSID&,void*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) SetErrorInfo(unsigned long,LPERRORINFO);
extern "C" HRESULT __attribute__((__stdcall__)) GetErrorInfo(unsigned long,LPERRORINFO*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateErrorInfo(LPCREATEERRORINFO*);
extern "C" unsigned long __attribute__((__stdcall__)) OaBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) VectorFromBstr (BSTR, SAFEARRAY **);
extern "C" HRESULT __attribute__((__stdcall__)) BstrFromVector (SAFEARRAY *, BSTR *);
extern "C" HRESULT __attribute__((__stdcall__)) VarParseNumFromStr(OLECHAR*,LCID,ULONG,NUMPARSE*,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarNumFromParseNum(NUMPARSE*,BYTE*,ULONG,VARIANT*);
extern "C" HRESULT __attribute__((__stdcall__)) GetRecordInfoFromTypeInfo (ITypeInfo*,IRecordInfo**);
extern "C" HRESULT __attribute__((__stdcall__)) GetRecordInfoFromGuids (const GUID&,ULONG,ULONG,LCID,const GUID&,IRecordInfo**);

extern "C" HRESULT __attribute__((__stdcall__)) VarAdd(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarSub(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMul(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarDiv(LPVARIANT, LPVARIANT, LPVARIANT);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI2(SHORT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI4(LONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI8(LONG64,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR4(FLOAT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR8(DOUBLE,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDate(DATE,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromBool(VARIANT_BOOL,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI1(signed char,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI2(USHORT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI4(ULONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI8(ULONG64,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromStr(OLECHAR*,LCID,ULONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromCy(CY,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDec(DECIMAL*,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDisp(IDispatch*,LCID,BYTE*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI1(BYTE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI4(LONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI8(LONG64,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR4(FLOAT,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR8(DOUBLE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDate(DATE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromBool(VARIANT_BOOL,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI1(signed char,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI2(USHORT,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI4(ULONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI8(ULONG64,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromStr(OLECHAR*,LCID,ULONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromCy(CY,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDec(DECIMAL*,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDisp(IDispatch*,LCID,SHORT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI1(BYTE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI2(SHORT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI8(LONG64,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR4(FLOAT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR8(DOUBLE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDate(DATE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromBool(VARIANT_BOOL,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI1(signed char,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI2(USHORT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI4(ULONG,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI8(ULONG64,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromStr(OLECHAR*,LCID,ULONG,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromCy(CY,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDec(DECIMAL*,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDisp(IDispatch*,LCID,LONG*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI1(BYTE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI2(SHORT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI4(LONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromR4(FLOAT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromR8(DOUBLE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDate(DATE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromStr(OLECHAR*,LCID,ULONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromBool(VARIANT_BOOL,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI1(signed char,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI2(USHORT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI4(ULONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI8(ULONG64,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDec(DECIMAL *pdecIn,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromInt(INT intIn,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromCy(CY,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDisp(IDispatch*,LCID,LONG64*);

extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI1(BYTE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI2(SHORT,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI4(LONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI8(LONG64,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromR8(DOUBLE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDate(DATE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromBool(VARIANT_BOOL,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI1(signed char,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI2(USHORT,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI4(ULONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI8(ULONG64,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromStr(OLECHAR*,LCID,ULONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromCy(CY,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDec(DECIMAL*,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDisp(IDispatch*,LCID,FLOAT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI1(BYTE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI2(SHORT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI4(LONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI8(LONG64,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromR4(FLOAT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDate(DATE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromBool(VARIANT_BOOL,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI1(signed char,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI2(USHORT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI4(ULONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI8(ULONG64,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromStr(OLECHAR*,LCID,ULONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromCy(CY,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDec(DECIMAL*,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDisp(IDispatch*,LCID,double*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI1(BYTE,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI2(SHORT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI4(LONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI8(LONG64,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR4(FLOAT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR8(DOUBLE,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromStr(OLECHAR*,LCID,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI1(signed char,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI2(USHORT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI4(ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI8(ULONG64,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromBool(VARIANT_BOOL,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromCy(CY,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDec(DECIMAL*,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDisp(IDispatch*,LCID,DATE*);

extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI1(BYTE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI2(SHORT sIn,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI4(LONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI8(LONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR4(FLOAT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR8(DOUBLE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDate(DATE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromBool(VARIANT_BOOL,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI1(signed char,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI2(USHORT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI4(ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI8(ULONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDec(DECIMAL*,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDisp(IDispatch*,LCID,CY*);

extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI1(BYTE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI2(SHORT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI4(LONG,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI8(LONG64,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR4(FLOAT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR8(DOUBLE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDate(DATE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromBool(VARIANT_BOOL,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI1(signed char,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI2(USHORT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI8(ULONG64,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI4(ULONG,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromCy(CY,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDec(DECIMAL*,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDisp(IDispatch*,LCID,ULONG,BSTR*);

extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI1(BYTE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI2(SHORT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI4(LONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI8(LONG64,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR4(FLOAT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR8(DOUBLE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDate(DATE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromStr(OLECHAR*,LCID,ULONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI1(signed char,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI2(USHORT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI4(ULONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI8(ULONG64,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromCy(CY,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDec(DECIMAL*,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDisp(IDispatch*,LCID,VARIANT_BOOL*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI1(BYTE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI2(SHORT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI4(LONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI8(LONG64,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromR4(FLOAT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromR8(DOUBLE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDate(DATE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromStr(OLECHAR*,LCID,ULONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromBool(VARIANT_BOOL,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI2(USHORT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI4(ULONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI8(ULONG64,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromCy(CY,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDec(DECIMAL*,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDisp(IDispatch*,LCID,signed char*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI1(BYTE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI2(SHORT,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI4(LONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI8(LONG64,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromR4(FLOAT,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromR8(DOUBLE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDate(DATE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromStr(OLECHAR*,LCID,ULONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromBool(VARIANT_BOOL,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI1(signed char,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI4(ULONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI8(ULONG64,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromCy(CY,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDec(DECIMAL*,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDisp(IDispatch*,LCID,USHORT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromStr(OLECHAR*,LCID,ULONG,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI1(BYTE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI2(SHORT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI4(LONG,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI8(LONG64,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromR4(FLOAT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromR8(DOUBLE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDate(DATE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromBool(VARIANT_BOOL,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI1(signed char,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI2(USHORT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI8(ULONG64,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromCy(CY,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDec(DECIMAL*,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDisp(IDispatch*,LCID,ULONG*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI1(BYTE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI2(SHORT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI4(LONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI8(LONG64,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromR4(FLOAT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromR8(DOUBLE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDate(DATE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromStr(OLECHAR*,LCID,ULONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromBool(VARIANT_BOOL,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI1(signed char,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI2(USHORT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI4(ULONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDec(DECIMAL*,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromInt(INT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromCy(CY,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDisp(IDispatch*,LCID,ULONG64*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI1(BYTE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI2(SHORT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI4(LONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI8(LONG64,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR4(FLOAT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR8(DOUBLE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromDate(DATE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromStr(OLECHAR*,LCID,ULONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromBool(VARIANT_BOOL,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI1(signed char,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI2(USHORT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI4(ULONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI8(ULONG64,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromCy(CY,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromDisp(IDispatch*,LCID,DECIMAL*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDecNeg(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4CmpR8(float,double);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8Pow(double,double,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8Round(double,int,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecAbs(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecAdd(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecCmp(const DECIMAL*,const DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecCmpR8(const DECIMAL*,DOUBLE);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecDiv(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFix(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecInt(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecMul(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecRound(const DECIMAL*,int,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecSub(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyAbs(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyAdd(const CY,const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyCmp(const CY,const CY);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyCmpR8(const CY,DOUBLE);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFix(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyInt(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMul(const CY,CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMulI4(const CY,LONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMulI8(const CY,LONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyNeg(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyRound(const CY,INT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCySub(const CY,const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarAdd(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarAnd(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarCat(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarDiv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarEqv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarIdiv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarImp(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMod(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMul(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarOr(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarPow(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarSub(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarXor(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarAbs(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarFix(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarInt(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarNeg(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarNot(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarRound(LPVARIANT,int,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarCmp(LPVARIANT,LPVARIANT,LCID,ULONG);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrCmp(BSTR,BSTR,LCID,ULONG);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrCat(BSTR,BSTR,BSTR*);

#pragma pack(pop)
# 12 "C:/upp/mingw/include/ole2.h" 2 3


extern "C" {
# 29 "C:/upp/mingw/include/ole2.h" 3
# 1 "C:/upp/mingw/include/oleidl.h" 1 3



       
# 5 "C:/upp/mingw/include/oleidl.h" 3



extern "C" {






typedef struct IParseDisplayName *LPPARSEDISPLAYNAME;
typedef struct IOleContainer *LPOLECONTAINER;
typedef struct IOleClientSite *LPOLECLIENTSITE;
typedef struct IOleObject *LPOLEOBJECT;
typedef struct IDropTarget *LPDROPTARGET;
typedef struct IDropSource *LPDROPSOURCE;
typedef struct IEnumOleUndoUnits *LPENUMOLEUNDOUNITS;
typedef struct IEnumOLEVERB *LPENUMOLEVERB;
typedef struct IOleWindow *LPOLEWINDOW;
typedef struct IOleInPlaceUIWindow *LPOLEINPLACEUIWINDOW;
typedef struct IOleInPlaceActiveObject *LPOLEINPLACEACTIVEOBJECT;
typedef struct IOleInPlaceFrame *LPOLEINPLACEFRAME;
typedef struct IOleAdviseHolder *LPOLEADVISEHOLDER;
typedef struct IViewObject *LPVIEWOBJECT;
typedef struct IViewObject2 *LPVIEWOBJECT2;
typedef struct IOleCache *LPOLECACHE;
typedef struct IOleCache2 *LPOLECACHE2;
typedef struct IOleCacheControl *LPOLECACHECONTROL;

typedef enum tagBINDSPEED
{
 BINDSPEED_INDEFINITE=1,
 BINDSPEED_MODERATE,
 BINDSPEED_IMMEDIATE
} BINDSPEED;
typedef enum tagOLEWHICHMK {
 OLEWHICHMK_CONTAINER=1,
 OLEWHICHMK_OBJREL,
 OLEWHICHMK_OBJFULL
} OLEWHICHMK;
typedef enum tagOLEGETMONIKER {
 OLEGETMONIKER_ONLYIFTHERE=1,
 OLEGETMONIKER_FORCEASSIGN,
 OLEGETMONIKER_UNASSIGN,
 OLEGETMONIKER_TEMPFORUSER
} OLEGETMONIKER;
typedef enum tagUSERCLASSTYPE {
 USERCLASSTYPE_FULL=1,
 USERCLASSTYPE_SHORT,
 USERCLASSTYPE_APPNAME
} USERCLASSTYPE;


__extension__

typedef enum tagDROPEFFECT {
 DROPEFFECT_NONE=0,
 DROPEFFECT_COPY=1,
 DROPEFFECT_MOVE=2,
 DROPEFFECT_LINK=4,
 DROPEFFECT_SCROLL=0x80000000
} DROPEFFECT;
typedef struct tagOleMenuGroupWidths {
 LONG width[6];
} OLEMENUGROUPWIDTHS,*LPOLEMENUGROUPWIDTHS;
typedef HGLOBAL HOLEMENU;
typedef enum tagOLECLOSE {
 OLECLOSE_SAVEIFDIRTY,
 OLECLOSE_NOSAVE,
 OLECLOSE_PROMPTSAVE
} OLECLOSE;
typedef struct tagOLEVERB {
 LONG lVerb;
 LPWSTR lpszVerbName;
 DWORD fuFlags;
 DWORD grfAttribs;
} OLEVERB,*LPOLEVERB;
typedef RECT BORDERWIDTHS;
typedef LPRECT LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;
typedef struct tagOIFI {
 UINT cb;
 BOOL fMDIApp;
 HWND hwndFrame;
 HACCEL haccel;
 UINT cAccelEntries;
}OLEINPLACEFRAMEINFO,*LPOLEINPLACEFRAMEINFO;

struct IEnumOLEVERB : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,OLEVERB*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumOLEVERB**) =0; };
typedef IEnumOLEVERB IEnumOleVerb;

extern "C" const IID IID_IParseDisplayName;

struct IParseDisplayName : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
};
# 114 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleContainer;

struct IOleContainer : public IParseDisplayName
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjects( DWORD,IEnumUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockContainer( BOOL) =0;
};


extern "C" const IID IID_IOleItemContainer;

struct IOleItemContainer : public IOleContainer
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjects( DWORD,IEnumUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockContainer( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectA( LPOLESTR,DWORD,IBindCtx*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectStorage( LPOLESTR,IBindCtx*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( LPOLESTR) =0;
};
# 155 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleClientSite;

struct IOleClientSite : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveObject(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMoniker( DWORD,DWORD,LPMONIKER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainer( LPOLECONTAINER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ShowObject(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnShowWindow( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestNewObjectLayout(void) =0;
};
# 183 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleObject;

struct IOleObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClientSite( LPOLECLIENTSITE) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClientSite( LPOLECLIENTSITE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHostNames( LPCOLESTR,LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) Close( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetMoniker( DWORD,LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMoniker( DWORD,DWORD,LPMONIKER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitFromData( LPDATAOBJECT,BOOL,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClipboardData( DWORD,LPDATAOBJECT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DoVerb( LONG,LPMSG,LPOLECLIENTSITE,LONG,HWND,LPCRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumVerbs( LPENUMOLEVERB*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Update(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsUpToDate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUserClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUserType( DWORD,LPOLESTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetExtent( DWORD,SIZEL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetExtent( DWORD,SIZEL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( LPADVISESINK,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( LPENUMSTATDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMiscStatus( DWORD,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetColorScheme( LPLOGPALETTE) =0;
};
# 241 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleWindow;

struct IOleWindow : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
};
# 261 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleInPlaceUIWindow;

struct IOleInPlaceUIWindow : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBorder( LPRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetActiveObject( LPOLEINPLACEACTIVEOBJECT,LPCOLESTR) =0;
};


extern "C" const IID IID_IOleInPlaceObject;

struct IOleInPlaceObject : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) InPlaceDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) UIDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetObjectRects( LPCRECT,LPCRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReactivateAndUndo(void) =0;
};


extern "C" const IID IID_IOleInPlaceActiveObject;

struct IOleInPlaceActiveObject : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) TranslateAcceleratorA( LPMSG) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnFrameWindowActivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnDocWindowActivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) ResizeBorder( LPCRECT,LPOLEINPLACEUIWINDOW,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnableModeless( BOOL) =0;
};


extern "C" const IID IID_IOleInPlaceFrame;

struct IOleInPlaceFrame : public IOleInPlaceUIWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBorder( LPRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetActiveObject( LPOLEINPLACEACTIVEOBJECT,LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) InsertMenus( HMENU,LPOLEMENUGROUPWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetMenu( HMENU,HOLEMENU,HWND) =0;
 virtual HRESULT __attribute__((__stdcall__)) RemoveMenus( HMENU) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetStatusText( LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnableModeless( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) TranslateAcceleratorA( LPMSG,WORD) =0;
};
# 350 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleInPlaceSite;

struct IOleInPlaceSite : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) CanInPlaceActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnInPlaceActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnUIActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindowContext( IOleInPlaceFrame**,IOleInPlaceUIWindow**,LPRECT,LPRECT,LPOLEINPLACEFRAMEINFO) =0;
 virtual HRESULT __attribute__((__stdcall__)) Scroll( SIZE) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnUIDeactivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnInPlaceDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DiscardUndoState(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeactivateAndUndo(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnPosRectChange( LPCRECT) =0;
};


extern "C" const IID IID_IOleAdviseHolder;

struct IOleAdviseHolder : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( LPADVISESINK,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( LPENUMSTATDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnRename( LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnSave(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnClose(void) =0;
};
# 400 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IDropSource;

struct IDropSource : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryContinueDrag( BOOL,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GiveFeedback( DWORD) =0;
};
# 420 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IDropTarget;

struct IDropTarget : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragEnter( LPDATAOBJECT,DWORD,POINTL,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragOver( DWORD,POINTL,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragLeave(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Drop( LPDATAOBJECT,DWORD,POINTL,PDWORD) =0;
};
# 444 "C:/upp/mingw/include/oleidl.h" 3
typedef BOOL(__attribute__((__stdcall__)) *__IView_pfncont)(DWORD);
extern "C" const IID IID_IViewObject;

struct IViewObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Draw( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,HDC,LPCRECTL,LPCRECTL,__IView_pfncont pfnContinue,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetColorSet( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,LPLOGPALETTE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Freeze( DWORD,LONG,PVOID,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unfreeze( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetAdvise( DWORD,DWORD,IAdviseSink*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAdvise( PDWORD,PDWORD,IAdviseSink**) =0;
};
# 473 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IViewObject2;

struct IViewObject2 : public IViewObject
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Draw( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,HDC,LPCRECTL,LPCRECTL,__IView_pfncont pfnContinue,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetColorSet( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,LPLOGPALETTE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Freeze( DWORD,LONG,PVOID,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unfreeze( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetAdvise( DWORD,DWORD,IAdviseSink*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAdvise( PDWORD,PDWORD,IAdviseSink**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetExtent( DWORD,LONG,DVTARGETDEVICE*,LPSIZEL) =0;
};
# 503 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleCache;

struct IOleCache : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Cache( FORMATETC*,DWORD,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Uncache( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumCache( IEnumSTATDATA**);
 virtual HRESULT __attribute__((__stdcall__)) InitCache( LPDATAOBJECT);
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL);
};
# 529 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleCache2;

struct IOleCache2 : public IOleCache
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Cache( FORMATETC*,DWORD,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Uncache( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumCache( IEnumSTATDATA**) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitCache( LPDATAOBJECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) UpdateCache( LPDATAOBJECT,DWORD,LPVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) DiscardCache( DWORD) =0;
};
# 559 "C:/upp/mingw/include/oleidl.h" 3
extern "C" const IID IID_IOleCacheControl;

struct IOleCacheControl : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnRun( LPDATAOBJECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnStop(void) =0;
};



}
# 30 "C:/upp/mingw/include/ole2.h" 2 3

typedef struct _OLESTREAMVTBL *LPOLESTREAMVTBL;
typedef struct _OLESTREAM {
 LPOLESTREAMVTBL lpstbl;
} OLESTREAM,*LPOLESTREAM;
typedef struct _OLESTREAMVTBL {
 DWORD (__attribute__((__stdcall__))* Get)(LPOLESTREAM,void*,DWORD);
 DWORD (__attribute__((__stdcall__))* Put)(LPOLESTREAM,const void*,DWORD);
} OLESTREAMVTBL;

extern "C" HRESULT __attribute__((__stdcall__)) CreateDataAdviseHolder(LPDATAADVISEHOLDER*);
extern "C" DWORD __attribute__((__stdcall__)) OleBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) ReadClassStg(LPSTORAGE,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) WriteClassStg(LPSTORAGE,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) ReadClassStm(LPSTREAM,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) WriteClassStm(LPSTREAM,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) WriteFmtUserTypeStg(LPSTORAGE,CLIPFORMAT,LPOLESTR);
extern "C" HRESULT __attribute__((__stdcall__)) ReadFmtUserTypeStg(LPSTORAGE,CLIPFORMAT*,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) OleInitialize(PVOID);
extern "C" void __attribute__((__stdcall__)) OleUninitialize(void);
extern "C" HRESULT __attribute__((__stdcall__)) OleQueryLinkFromData(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleQueryCreateFromData(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreate(const CLSID&,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLinkFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateStaticFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLink(LPMONIKER,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLinkToFile(LPCOLESTR,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateFromFile(const CLSID&,LPCOLESTR,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleLoad(LPSTORAGE,const IID&,LPOLECLIENTSITE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleSave(LPPERSISTSTORAGE,LPSTORAGE,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleLoadFromStream(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleSaveToStream(LPPERSISTSTREAM,LPSTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetContainedObject(LPUNKNOWN,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleNoteObjectVisible(LPUNKNOWN,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterDragDrop(HWND,LPDROPTARGET);
extern "C" HRESULT __attribute__((__stdcall__)) RevokeDragDrop(HWND);
extern "C" HRESULT __attribute__((__stdcall__)) DoDragDrop(LPDATAOBJECT,LPDROPSOURCE,DWORD,PDWORD);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetClipboard(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleGetClipboard(LPDATAOBJECT*);
extern "C" HRESULT __attribute__((__stdcall__)) OleFlushClipboard(void);
extern "C" HRESULT __attribute__((__stdcall__)) OleIsCurrentClipboard(LPDATAOBJECT);
extern "C" HOLEMENU __attribute__((__stdcall__)) OleCreateMenuDescriptor(HMENU,LPOLEMENUGROUPWIDTHS);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetMenuDescriptor(HOLEMENU,HWND,HWND,LPOLEINPLACEFRAME,LPOLEINPLACEACTIVEOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleDestroyMenuDescriptor(HOLEMENU);
extern "C" HRESULT __attribute__((__stdcall__)) OleTranslateAccelerator(LPOLEINPLACEFRAME,LPOLEINPLACEFRAMEINFO,LPMSG);
extern "C" HANDLE __attribute__((__stdcall__)) OleDuplicateData(HANDLE,CLIPFORMAT,UINT);
extern "C" HRESULT __attribute__((__stdcall__)) OleDraw(LPUNKNOWN,DWORD,HDC,LPCRECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleRun(LPUNKNOWN);
extern "C" BOOL __attribute__((__stdcall__)) OleIsRunning(LPOLEOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleLockRunning(LPUNKNOWN,BOOL,BOOL);
extern "C" void __attribute__((__stdcall__)) ReleaseStgMedium(LPSTGMEDIUM);
extern "C" HRESULT __attribute__((__stdcall__)) CreateOleAdviseHolder(LPOLEADVISEHOLDER*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateDefaultHandler(const CLSID&,LPUNKNOWN,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateEmbeddingHelper(const CLSID&,LPUNKNOWN,DWORD,LPCLASSFACTORY,const IID&,PVOID*);
extern "C" BOOL __attribute__((__stdcall__)) IsAccelerator(HACCEL,int,LPMSG,WORD*);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleGetIconOfFile(LPOLESTR,BOOL);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleGetIconOfClass(const CLSID&,LPOLESTR,BOOL);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleMetafilePictFromIconAndLabel(HICON,LPOLESTR,LPOLESTR,UINT);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegGetUserType(const CLSID&,DWORD,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegGetMiscStatus(const CLSID&,DWORD,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegEnumFormatEtc (const CLSID&,DWORD,LPENUMFORMATETC*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegEnumVerbs (const CLSID&,LPENUMOLEVERB*);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertOLESTREAMToIStorage(LPOLESTREAM,LPSTORAGE,const DVTARGETDEVICE*);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertIStorageToOLESTREAM(LPSTORAGE,LPOLESTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) GetHGlobalFromILockBytes(LPLOCKBYTES,HGLOBAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateILockBytesOnHGlobal(HGLOBAL,BOOL,LPLOCKBYTES*);
extern "C" HRESULT __attribute__((__stdcall__)) GetHGlobalFromStream(LPSTREAM,HGLOBAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateStreamOnHGlobal(HGLOBAL,BOOL,LPSTREAM*);
extern "C" HRESULT __attribute__((__stdcall__)) OleDoAutoConvert(LPSTORAGE,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) OleGetAutoConvert(const CLSID&,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetAutoConvert(const CLSID&,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) GetConvertStg(LPSTORAGE);
extern "C" HRESULT __attribute__((__stdcall__)) SetConvertStg(LPSTORAGE,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertIStorageToOLESTREAMEx(LPSTORAGE,CLIPFORMAT,LONG,LONG,DWORD,LPSTGMEDIUM,LPOLESTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertOLESTREAMToIStorageEx(LPOLESTREAM,LPSTORAGE,CLIPFORMAT*,LONG*,LONG*,DWORD*,LPSTGMEDIUM);

}

#pragma pack(pop)
# 115 "C:/upp/mingw/include/windows.h" 2 3
# 290 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/include/stdint.h" 1
# 24 "C:/upp/mingw/include/stdint.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 25 "C:/upp/mingw/include/stdint.h" 2


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;





typedef char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;
# 75 "C:/upp/mingw/include/stdint.h"
  typedef unsigned int uintptr_t;




typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 291 "C:/upp/uppsrc/Core/Core.h" 2
# 299 "C:/upp/uppsrc/Core/Core.h"
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 3
       
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++config.h" 1 3
# 35 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++config.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/os_defines.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++config.h" 2 3
# 57 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++config.h" 3
namespace __gnu_debug_def { }

namespace __gnu_debug
{
  using namespace __gnu_debug_def;
}
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstring" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstring" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstring" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstddef" 1 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstddef" 3
       
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstddef" 3

# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 49 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 50 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstring" 2 3
# 77 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/climits" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/climits" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/climits" 3
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 3
# 84 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 3
namespace std
{
  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;





  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
# 140 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 3
namespace __gnu_cxx
{

  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }

  inline long long
  llabs(long long __x) { return __x >= 0 ? __x : -__x; }


  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  inline lldiv_t
  lldiv(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
# 176 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;
}

namespace std
{

  using __gnu_cxx::lldiv_t;

  using __gnu_cxx::_Exit;
  using __gnu_cxx::abs;
  using __gnu_cxx::llabs;

  using __gnu_cxx::div;
  using __gnu_cxx::lldiv;

  using __gnu_cxx::atoll;
  using __gnu_cxx::strtof;
  using __gnu_cxx::strtoll;
  using __gnu_cxx::strtoull;
  using __gnu_cxx::strtold;
}
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/new" 1 3
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/new" 3
extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) throw();
}
# 82 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}
# 70 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++locale.h" 1 3
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++locale.h" 3
       
# 40 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++locale.h" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/clocale" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/clocale" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/clocale" 3

# 1 "C:/upp/mingw/include/locale.h" 1 3
# 40 "C:/upp/mingw/include/locale.h" 3
# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 41 "C:/upp/mingw/include/locale.h" 2 3




struct lconv
{
 char* decimal_point;
 char* thousands_sep;
 char* grouping;
 char* int_curr_symbol;
 char* currency_symbol;
 char* mon_decimal_point;
 char* mon_thousands_sep;
 char* mon_grouping;
 char* positive_sign;
 char* negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
};


extern "C" {


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setlocale (int, const char*);
 struct lconv* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localeconv (void);



# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 77 "C:/upp/mingw/include/locale.h" 2 3
  wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsetlocale(int, const wchar_t*);




}
# 50 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++locale.h" 2 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 3
# 97 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 153 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 3
namespace __gnu_cxx
{
# 167 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++locale.h" 2 3



namespace std
{
  typedef int* __c_locale;





  template<typename _Tv>
    int
    __convert_from_v(char* __out,
       const int __size __attribute__((__unused__)),
       const char* __fmt,
       _Tv __v, const __c_locale&, int __prec)
    {
      char* __old = std::setlocale(4, __null);
      char* __sav = __null;
      if (std::strcmp(__old, "C"))
 {
   __sav = new char[std::strlen(__old) + 1];
   std::strcpy(__sav, __old);
   std::setlocale(4, "C");
 }


      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v);




      if (__sav)
 {
   std::setlocale(4, __sav);
   delete [] __sav;
 }
      return __ret;
    }
}
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++io.h" 1 3
# 37 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++io.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr.h" 1 3
# 96 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 1 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 3
# 1 "C:/upp/mingw/include/errno.h" 1 3
# 80 "C:/upp/mingw/include/errno.h" 3
extern "C" {
# 91 "C:/upp/mingw/include/errno.h" 3
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);




}
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 2 3
# 331 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 3
extern "C" {


typedef unsigned long __gthread_key_t;

typedef struct {
  int done;
  long started;
} __gthread_once_t;

typedef struct {
  long counter;
  void *sema;
} __gthread_mutex_t;
# 356 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 3
extern int _CRT_MT;
extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));
# 383 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{

  return _CRT_MT;



}







extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));
extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));
extern int __gthr_win32_key_delete (__gthread_key_t);
extern void * __gthr_win32_getspecific (__gthread_key_t);
extern int __gthr_win32_setspecific (__gthread_key_t, const void *);
extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);
extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);

static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return __gthr_win32_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return __gthr_win32_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return __gthr_win32_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return __gthr_win32_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return __gthr_win32_setspecific (key, ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *mutex)
{
  __gthr_win32_mutex_init_function (mutex);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_unlock (mutex);
  else
    return 0;
}
# 616 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr-default.h" 3
}
# 97 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/gthr.h" 2 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++io.h" 2 3

namespace std
{
  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;



  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cctype" 1 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cctype" 3
       
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cctype" 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 49 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stringfwd.h" 1 3
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stringfwd.h" 3
       
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stringfwd.h" 3



namespace std
{
  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
# 50 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 1 3
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 3
       
# 45 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 3



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ctime" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ctime" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ctime" 3



# 1 "C:/upp/mingw/include/time.h" 1 3
# 21 "C:/upp/mingw/include/time.h" 3
# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 22 "C:/upp/mingw/include/time.h" 2 3
# 55 "C:/upp/mingw/include/time.h" 3
typedef long clock_t;
# 64 "C:/upp/mingw/include/time.h" 3
struct tm
{
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;

};




extern "C" {


 clock_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clock (void);
 time_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) time (time_t*);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) difftime (time_t, time_t);
 time_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mktime (struct tm*);
# 99 "C:/upp/mingw/include/time.h" 3
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) asctime (const struct tm*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ctime (const time_t*);
 struct tm* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gmtime (const time_t*);
 struct tm* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localtime (const time_t*);

 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strftime (char*, size_t, const char*, const struct tm*);



extern void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tzset (void);


extern void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tzset (void);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdate(char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strtime(char*);
# 135 "C:/upp/mingw/include/time.h" 3
extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__daylight (void);
extern long* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__timezone (void);
extern char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__tzname (void);

extern __attribute__ ((__dllimport__)) int _daylight;
extern __attribute__ ((__dllimport__)) long _timezone;
extern __attribute__ ((__dllimport__)) char *_tzname[2];
# 173 "C:/upp/mingw/include/time.h" 3
extern __attribute__ ((__dllimport__)) int daylight;
extern __attribute__ ((__dllimport__)) long timezone;
extern __attribute__ ((__dllimport__)) char *tzname[2];
# 198 "C:/upp/mingw/include/time.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wasctime(const struct tm*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wctime(const time_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrdate(wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrtime(wchar_t*);





 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsftime (wchar_t*, size_t, const wchar_t*, const struct tm*);




}
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ctime" 2 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 2 3


# 1 "C:/upp/mingw/include/wchar.h" 1 3
# 26 "C:/upp/mingw/include/wchar.h" 3
# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 27 "C:/upp/mingw/include/wchar.h" 2 3
# 45 "C:/upp/mingw/include/wchar.h" 3
# 1 "C:/upp/mingw/include/wctype.h" 1 3
# 32 "C:/upp/mingw/include/wctype.h" 3
# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 33 "C:/upp/mingw/include/wctype.h" 2 3
# 54 "C:/upp/mingw/include/wctype.h" 3
extern "C" {
# 67 "C:/upp/mingw/include/wctype.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);





 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);





  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];


  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
# 148 "C:/upp/mingw/include/wctype.h" 3
typedef wchar_t wctrans_t;
# 157 "C:/upp/mingw/include/wctype.h" 3
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towctrans(wint_t, wctrans_t);
wctrans_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctrans(const char*);
wctype_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctype(const char*);


}
# 46 "C:/upp/mingw/include/wchar.h" 2 3
# 63 "C:/upp/mingw/include/wchar.h" 3
extern "C" {
# 271 "C:/upp/mingw/include/wchar.h" 3
typedef wchar_t _Wint_t;


typedef int mbstate_t;

wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) btowc(int);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrlen(const char * __restrict__, size_t,
        mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrtowc(wchar_t * __restrict__, const char * __restrict__,
         size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsrtowcs(wchar_t * __restrict__, const char ** __restrict__,
    size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcrtomb(char * __restrict__, wchar_t,
         mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrtombs(char * __restrict__, const wchar_t ** __restrict__,
    size_t, mbstate_t * __restrict__);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctob(wint_t);


inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwide(FILE* ,
          int )
  {return -1;}
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsinit(const mbstate_t* )
  {return 1;}
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemset(wchar_t *, wchar_t, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemchr(const wchar_t*, wchar_t, size_t);
int wmemcmp(const wchar_t*, const wchar_t *, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemcpy(wchar_t* __restrict__,
           const wchar_t* __restrict__,
    size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemmove(wchar_t* s1, const wchar_t *, size_t);
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoll(const wchar_t * __restrict__,
     wchar_t** __restrict__, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoull(const wchar_t * __restrict__,
       wchar_t ** __restrict__, int);
# 375 "C:/upp/mingw/include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchdir (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetcwd (wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetdcwd (int, wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmkdir (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrmdir (const wchar_t*);
# 392 "C:/upp/mingw/include/wchar.h" 3
struct _stat
{
 _dev_t st_dev;
 _ino_t st_ino;
 _mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 _dev_t st_rdev;
 _off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct stat
{
 dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 dev_t st_rdev;
 off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct _stati64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
};
# 465 "C:/upp/mingw/include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstat (const wchar_t*, struct _stat*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstati64 (const wchar_t*, struct _stati64*);
# 482 "C:/upp/mingw/include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecl (const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecle (const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclp (const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclpe (const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecv (const wchar_t*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecve (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvp (const wchar_t*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvpe (const wchar_t*, const wchar_t* const*, const wchar_t* const*);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnl (int, const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnle (int, const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlp (int, const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlpe (int, const wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnv (int, const wchar_t*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnve (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvp (int, const wchar_t*, const wchar_t* const*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvpe (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);





}
# 55 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 2 3
# 69 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 141 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 3
namespace std
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}







namespace __gnu_cxx
{





  using ::wcstold;
# 258 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 2 3





namespace std
{
# 72 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }






      bool
      operator==(const fpos& __other) const
      { return _M_off == __other._M_off; }


      bool
      operator!=(const fpos& __other) const
      { return _M_off != __other._M_off; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
}
# 51 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 1 3
# 34 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/exception_defines.h" 1 3
# 35 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 136 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
# 166 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iosfwd" 3
}
# 71 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_pair.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_pair.h" 3
namespace std
{

  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y) { return pair<_T1, _T2>(__x, __y); }
}
# 72 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/type_traits.h" 1 3
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/type_traits.h" 3
       
# 53 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/type_traits.h" 3
# 90 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/type_traits.h" 3
struct __true_type {};
struct __false_type {};

template <class _Tp>
  struct __type_traits
  {
    typedef __true_type this_dummy_member_must_be_first;
# 114 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/type_traits.h" 3
    typedef __false_type has_trivial_default_constructor;
    typedef __false_type has_trivial_copy_constructor;
    typedef __false_type has_trivial_assignment_operator;
    typedef __false_type has_trivial_destructor;
    typedef __false_type is_POD_type;
  };




template<>
  struct __type_traits<bool>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<signed char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<wchar_t>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<short>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned short>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<int>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned int>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned long long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<float>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<double>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long double>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template <class _Tp>
  struct __type_traits<_Tp*>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };




template <class _Tp>
  struct _Is_integer
  {
    typedef __false_type _Integral;
  };

template<>
  struct _Is_integer<bool>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<signed char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<wchar_t>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<short>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned short>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<int>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned int>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<long long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned long long>
  {
    typedef __true_type _Integral;
  };

template<typename _Tp>
  struct _Is_normal_iterator
  {
    typedef __false_type _Normal;
  };


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
}

template<typename _Iterator, typename _Container>
  struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
          _Container> >
  {
    typedef __true_type _Normal;
  };
# 73 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_types.h" 1 3
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_types.h" 3
       
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 74 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 1 3
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 3
       
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/concept_check.h" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/concept_check.h" 3
       
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/concept_check.h" 3
# 69 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 170 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      std::__advance(__i, __n, std::__iterator_category(__i));
    }
}
# 75 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 1 3
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
namespace std
{
# 89 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 275 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 335 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 361 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 395 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 410 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 469 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 488 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 530 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 565 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        inline __normal_iterator(const __normal_iterator<_Iter,
     _Container>& __i)
 : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 678 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 76 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/debug/debug.h" 1 3
# 272 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/debug/debug.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cassert" 1 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cassert" 3
       
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cassert" 3

# 1 "C:/upp/mingw/include/assert.h" 1 3
# 23 "C:/upp/mingw/include/assert.h" 3
extern "C" {
# 38 "C:/upp/mingw/include/assert.h" 3
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _assert (const char*, const char*, int) __attribute__ ((__noreturn__));
# 48 "C:/upp/mingw/include/assert.h" 3
}
# 49 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cassert" 2 3
# 273 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/debug/debug.h" 2 3

# 1 "C:/upp/mingw/include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2 3
# 275 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/debug/debug.h" 2 3



namespace __gnu_debug
{
  template<typename _Iterator, typename _Sequence>
    class _Safe_iterator;


  inline bool
  __check_singular_aux(const void*) { return false; }



  template<typename _Iterator>
    inline bool
    __check_singular(_Iterator& __x)
    { return __gnu_debug::__check_singular_aux(&__x); }


  template<typename _Tp>
    inline bool
    __check_singular(const _Tp* __ptr)
    { return __ptr == 0; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_singular(); }



  template<typename _Iterator>
    inline bool
    __check_dereferenceable(_Iterator&)
    { return true; }


  template<typename _Tp>
    inline bool
    __check_dereferenceable(const _Tp* __ptr)
    { return __ptr; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_dereferenceable(); }




  template<typename _RandomAccessIterator>
    inline bool
    __valid_range_aux2(const _RandomAccessIterator& __first,
         const _RandomAccessIterator& __last,
         std::random_access_iterator_tag)
    { return __last - __first >= 0; }





  template<typename _InputIterator>
    inline bool
    __valid_range_aux2(const _InputIterator&, const _InputIterator&,
         std::input_iterator_tag)
    { return true; }





  template<typename _Integral>
    inline bool
    __valid_range_aux(const _Integral&, const _Integral&, __true_type)
    { return true; }




  template<typename _InputIterator>
    inline bool
    __valid_range_aux(const _InputIterator& __first,
        const _InputIterator& __last, __false_type)
  {
    typedef typename std::iterator_traits<_InputIterator>::iterator_category
      _Category;
    return __gnu_debug::__valid_range_aux2(__first, __last, _Category());
  }






  template<typename _InputIterator>
    inline bool
    __valid_range(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());
    }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,
    const _Safe_iterator<_Iterator, _Sequence>& __last)
    { return __first._M_valid_range(__last); }





  template<typename _InputIterator>
    inline _InputIterator
    __check_valid_range(const _InputIterator& __first,
   const _InputIterator& __last)
    {
      ;
      return __first;
    }


  template<typename _CharT, typename _Integer>
    inline const _CharT*
    __check_string(const _CharT* __s, const _Integer& __n)
    {



      return __s;
    }


  template<typename _CharT>
    inline const _CharT*
    __check_string(const _CharT* __s)
    {



      return __s;
    }



  template<typename _InputIterator>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (*__next < *__first)
          return false;
      }

      return true;
    }



  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       _Predicate, std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       _Predicate __pred, std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (__pred(*__next, *__first))
          return false;
      }

      return true;
    }


  template<typename _InputIterator>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());
    }

  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,
                   _Predicate __pred)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,
          _Category());
    }




  template<typename _ForwardIterator, typename _Tp>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value)
    {
      while (__first != __last && *__first < __value)
 ++__first;
      while (__first != __last && !(*__first < __value))
 ++__first;
      return __first == __last;
    }


  template<typename _ForwardIterator, typename _Tp, typename _Pred>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value, _Pred __pred)
    {
      while (__first != __last && __pred(*__first, __value))
 ++__first;
      while (__first != __last && !__pred(*__first, __value))
 ++__first;
      return __first == __last;
    }
}
# 78 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 2 3

namespace std
{
# 90 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      const _ValueType1 __tmp = *__a;
      *__a = *__b;
      *__b = __tmp;
    }
# 123 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      const _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
# 148 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 170 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 192 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 212 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, input_iterator_tag)
    {
      for (; __first != __last; ++__result, ++__first)
 *__result = *__first;
      return __result;
    }

  template<typename _RandomAccessIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _OutputIterator __result, random_access_iterator_tag)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n)
 {
   *__result = *__first;
   ++__first;
   ++__result;
 }
      return __result;
    }

  template<typename _Tp>
    inline _Tp*
    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)
    {
      std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
      return __result + (__last - __first);
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_aux2(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, __false_type)
    { return std::__copy(__first, __last, __result,
    std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_aux2(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, __true_type)
    { return std::__copy(__first, __last, __result,
    std::__iterator_category(__first)); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result, __true_type)
    { return std::__copy_trivial(__first, __last, __result); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,
  __true_type)
    { return std::__copy_trivial(__first, __last, __result); }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni2(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __true_type)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename __type_traits<
 _ValueType>::has_trivial_assignment_operator _Trivial;
      return _OutputIterator(std::__copy_aux2(__first, __last, __result.base(),
           _Trivial()));
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni2(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __false_type)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      typedef typename __type_traits<
 _ValueType>::has_trivial_assignment_operator _Trivial;
      return std::__copy_aux2(__first, __last, __result, _Trivial());
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni1(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_OutputIterator>::_Normal __Normal;
      return std::__copy_ni2(__first.base(), __last.base(),
        __result, __Normal());
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni1(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_OutputIterator>::_Normal __Normal;
      return std::__copy_ni2(__first, __last, __result, __Normal());
    }
# 346 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

      ;

       typedef typename _Is_normal_iterator<_InputIterator>::_Normal __Normal;
       return std::__copy_ni1(__first, __last, __result, __Normal());
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    inline _BidirectionalIterator2
    __copy_backward(_BidirectionalIterator1 __first,
      _BidirectionalIterator1 __last,
      _BidirectionalIterator2 __result,
      bidirectional_iterator_tag)
    {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }

  template<typename _RandomAccessIterator, typename _BidirectionalIterator>
    inline _BidirectionalIterator
    __copy_backward(_RandomAccessIterator __first, _RandomAccessIterator __last,
      _BidirectionalIterator __result, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type __n;
      for (__n = __last - __first; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
           typename _BoolType>
    struct __copy_backward_dispatch
    {
      static _BidirectionalIterator2
      copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
    _BidirectionalIterator2 __result)
      { return std::__copy_backward(__first, __last, __result,
        std::__iterator_category(__first)); }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
 const ptrdiff_t _Num = __last - __first;
 std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
 return __result - _Num;
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
 return std::__copy_backward_dispatch<_Tp*, _Tp*, __true_type>
   ::copy(__first, __last, __result);
      }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
       ::has_trivial_assignment_operator _Trivial;
      return
 std::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first,
          __last,
          __result);
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
        _BI2 __result, __true_type)
    { return _BI2(std::__copy_backward_aux(__first, __last, __result.base())); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
        _BI2 __result, __false_type)
    { return std::__copy_backward_aux(__first, __last, __result); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
       _BI2 __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return std::__copy_backward_output_normal_iterator(__first.base(),
        __last.base(),
        __result, __Normal());
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
       _BI2 __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return std::__copy_backward_output_normal_iterator(__first, __last,
        __result, __Normal());
    }
# 485 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;
      return std::__copy_backward_input_normal_iterator(__first, __last,
       __result, __Normal());
    }
# 514 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      for ( ; __first != __last; ++__first)
 *__first = __value;
    }
# 538 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {

     

      for ( ; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 612 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 647 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 677 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {

     
     
     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 709 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 741 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;

      for (;__first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 780 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {

     
     
      ;
      ;

      for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_construct.h" 1 3
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_construct.h" 3
namespace std
{






  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    { for ( ; __first != __last; ++__first) std::_Destroy(&*__first); }
# 131 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 143 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename __type_traits<_Value_type>::has_trivial_destructor
                       _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
}
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 1 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 3
namespace std
{

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for ( ; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 105 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for ( ; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 167 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { return std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    _ForwardIterator
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for ( ; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 213 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
# 230 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result)
    {
      _ForwardIterator __mid = std::uninitialized_copy(__first1, __last1,
             __result);
      try
 {
   return std::uninitialized_copy(__first2, __last2, __mid);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last)
    {
      std::uninitialized_fill(__result, __mid, __x);
      try
 {
   return std::uninitialized_copy(__first, __last, __mid);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x)
    {
      _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1,
       __first2);
      try
 {
   std::uninitialized_fill(__mid2, __last2, __x);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2);
   throw;
 }
    }

}
# 69 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 1 3
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;


      while (__last - __first > 1)
 std::pop_heap(__first, __last--);
    }
# 446 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, __last--, __comp);
    }

}
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tempbuf.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tempbuf.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 1 3
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
       
# 53 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/allocator.h" 1 3
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/allocator.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++allocator.h" 1 3
# 34 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++allocator.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ext/new_allocator.h" 1 3
# 35 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ext/new_allocator.h" 3
namespace __gnu_cxx
{
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      { return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp))); }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
}
# 35 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/c++allocator.h" 2 3
# 53 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/allocator.h" 2 3

namespace std
{
  template<typename _Tp>
    class allocator;

  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };






  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& a) throw()
      : __gnu_cxx::new_allocator<_Tp>(a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;




}
# 56 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 2 3



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_raw_storage_iter.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
}
# 60 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 2 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 1 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 3
       
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 3
# 150 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 3
namespace std
{





  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 285 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };



  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 1.40129846e-45F ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 4.9406564584124654e-324 ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 3.64519953188247460253e-4951L ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 62 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 2 3

namespace std
{
# 73 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 109 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 121 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 174 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 200 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 212 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 223 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 240 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 260 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 270 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 300 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 314 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 329 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 350 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }

  };
}
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tempbuf.h" 2 3

namespace std
{







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

 public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename __type_traits<_Tp>::has_trivial_default_constructor
       _Trivial;

      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 2 3




namespace std
{
# 84 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 118 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 150 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    find(_RandomAccessIterator __first, _RandomAccessIterator __last,
  const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 304 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::find(__first, __last, __val,
         std::__iterator_category(__first));
    }
# 326 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::find_if(__first, __last, __pred,
     std::__iterator_category(__first));
    }
# 348 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 379 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 410 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

     
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 435 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 474 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 545 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 623 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

     
      ;

      if (__count <= 0)
 return __first;
      else
 {
   __first = std::find(__first, __last, __val);
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && *__i == __val)
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  __first = std::find(__i, __last, __val);
     }
   return __last;
 }
    }
# 675 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      else
 {
   while (__first != __last)
     {
       if (__binary_pred(*__first, __val))
  break;
       ++__first;
     }
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  {
    while (__i != __last)
      {
        if (__binary_pred(*__i, __val))
   break;
        ++__i;
      }
    __first = __i;
  }
     }
   return __last;
 }
    }
# 737 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

     


     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 775 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 810 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 842 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 873 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 906 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 939 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 970 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 996 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1023 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1059 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1098 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1159 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1184 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1206 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    _BinaryPredicate __binary_pred,
    output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1238 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    _BinaryPredicate __binary_pred,
    forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1270 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result, _IterType());
    }
# 1305 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result,
    __binary_pred, _IterType());
    }
# 1339 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1378 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1412 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
     bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   std::iter_swap(__first++, __last);
    }
# 1431 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
     random_access_iterator_tag)
    {
      while (__first < __last)
 std::iter_swap(__first++, --__last);
    }
# 1451 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1477 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1505 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
       forward_iterator_tag)
    {
      if ((__first == __middle) || (__last == __middle))
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first++, *__first2++);
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first++, *__first2++);
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 swap(*__first++, *--__last);

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   const _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1677 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1710 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1735 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 1762 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1856 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1967 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > _S_threshold)
 {
   std::__insertion_sort(__first, __first + _S_threshold);
   std::__unguarded_insertion_sort(__first + _S_threshold, __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > _S_threshold)
 {
   std::__insertion_sort(__first, __first + _S_threshold, __comp);
   std::__unguarded_insertion_sort(__first + _S_threshold, __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2256 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
      std::sort_heap(__first, __middle);
    }
# 2297 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2339 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     
     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2403 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > _S_threshold)
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > _S_threshold)
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2538 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2572 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2605 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2660 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2707 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2759 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2957 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3015 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3435 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3489 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3598 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType>
 buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()));
    }
# 3639 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()), __comp);
    }
# 3680 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
# 3731 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
             __comp)), __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 3784 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3846 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3904 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {


     
     

     
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3936 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     

      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3974 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4020 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {

     
     
     


     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4066 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4128 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4189 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4243 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4297 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4355 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4409 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4470 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4523 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4550 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4602 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4637 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4693 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4748 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4804 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4863 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4899 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4929 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5079 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5124 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 70 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/algorithm" 2 3
# 300 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 3



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 3





namespace __gnu_cxx
{
# 62 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 3
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
}

namespace std
{
# 224 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits
    : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((wchar_t)(0xFFFF)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


  template<typename _CharT, typename _Traits>
    struct _Char_traits_match
    {
      _CharT _M_c;
      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }

      bool
      operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }
    };
}
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 2 3




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
namespace std
{
# 101 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 195 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 256 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 311 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 391 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };


  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };


  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
# 480 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 590 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_function.h" 3
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };


  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };


  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp>
    class mem_fun_t<void, _Tp> : public unary_function<_Tp*, void>
    {
    public:
      explicit
      mem_fun_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*, void>
    {
    public:
      explicit
      const_mem_fun_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp>
    class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      mem_fun_ref_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      const_mem_fun_ref_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*, _Arg, void>
    {
    public:
      explicit
      mem_fun1_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_t<void, _Tp, _Arg>
    : public binary_function<const _Tp*, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      mem_fun1_ref_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };



  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}
# 53 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/atomicity.h" 1 3
# 33 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/atomicity.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/atomic_word.h" 1 3
# 33 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 34 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/atomicity.h" 2 3

namespace __gnu_cxx
{
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val);

  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word* __mem, int __val);
}
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 2 3


namespace std
{
# 109 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 144 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 169 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add(&this->_M_refcount, -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:





      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const { return iterator(_M_data()); }

      iterator
      _M_iend() const { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 388 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      {
 this->assign(__str);
 return *this;
      }





      basic_string&
      operator=(const _CharT* __s)
      {
 this->assign(__s);
 return *this;
      }
# 449 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const { return _M_rep()->_M_length; }



      size_type
      length() const { return _M_rep()->_M_length; }


      size_type
      max_size() const { return _Rep::_S_max_size; }
# 557 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 570 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      void
      resize(size_type __n) { this->resize(__n, _CharT()); }





      size_type
      capacity() const { return _M_rep()->_M_capacity; }
# 597 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() { _M_mutate(0, this->size(), 0); }




      bool
      empty() const { return this->size() == 0; }
# 623 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 640 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {
 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 658 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 677 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str) { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s) { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c) { return this->append(size_type(1), __c); }






      basic_string&
      append(const basic_string& __str);
# 731 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 763 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
# 775 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      { _M_replace_aux(this->size(), size_type(0), size_type(1), __c); }






      basic_string&
      assign(const basic_string& __str);
# 808 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 824 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 836 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 852 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 864 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 881 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 896 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      template<class _InputIterator>
        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 911 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 933 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 956 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 974 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 997 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1014 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return this->_M_ibegin() + __pos;
      }
# 1038 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { return _M_replace_safe(_M_check(__pos, "basic_string::erase"),
          _M_limit(__pos, __n), __null, size_type(0)); }
# 1051 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_replace_safe(__pos, size_type(1), __null, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1071 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 ;

        const size_type __pos = __first - _M_ibegin();
 _M_replace_safe(__pos, __last - __first, __null, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1098 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1120 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1144 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1163 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1186 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1204 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1222 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1243 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1264 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1286 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
        replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1, __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2,
  const _CharT* __k1, const _CharT* __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1, __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1.base(), __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2,
  const_iterator __k1, const_iterator __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1.base(), __k2 - __k1);
 }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c)
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error(("basic_string::_M_replace_aux"));
 _M_mutate(__pos1, __n1, __n2);
 if (__n2 == 1)
   _M_data()[__pos1] = __c;
 else if (__n2)
   traits_type::assign(_M_data() + __pos1, __n2, __c);
 return *this;
      }

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2)
      {
 _M_mutate(__pos1, __n1, __n2);
 if (__n2 == 1)
   _M_data()[__pos1] = *__s;
 else if (__n2)
   traits_type::copy(_M_data() + __pos1, __s, __n2);
 return *this;
      }



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename _Is_integer<_InIterator>::_Integral _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1435 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1445 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1455 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      const _CharT*
      c_str() const { return _M_data(); }







      const _CharT*
      data() const { return _M_data(); }




      allocator_type
      get_allocator() const { return _M_dataplus; }
# 1484 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1497 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1511 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1528 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1541 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1556 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1569 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1586 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1599 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1614 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1627 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1646 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1660 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1675 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1688 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1707 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1721 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1736 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1750 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1767 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1780 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1796 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1809 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1826 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1841 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1859 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = __size - __osize;
 return __r;
      }
# 1889 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1913 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 1931 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 1954 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 1979 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2000 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2071 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2108 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
# 2145 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2182 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2219 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
  { return __rhs.compare(__lhs) >= 0; }
# 2256 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2293 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2310 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
# 2324 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str);
# 2342 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2359 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str);
}
# 54 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 2 3



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 1 3
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 3
       
# 45 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 3

namespace std
{
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 traits_type::copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      traits_type::copy(__another->_M_refdata(),
          __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_length = __len;
 __r->_M_refdata()[__len] = _Rep::_S_terminal;
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_length = __dnew;
 __r->_M_refdata()[__dnew] = _Rep::_S_terminal;
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 traits_type::assign(__r->_M_refdata(), __n, __c);

      __r->_M_length = __n;
      __r->_M_refdata()[__n] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const _CharT* __s, size_type __n)
     {
       ;
       if (__n > this->max_size())
  __throw_length_error(("basic_string::assign"));
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
    || less<const _CharT*>()(_M_data() + this->size(), __s))
  return _M_replace_safe(size_type(0), this->size(), __s, __n);
       else
  {

    const size_type __pos = __s - _M_data();
    if (__pos >= __n)
      traits_type::copy(_M_data(), __s, __n);
    else if (__pos)
      traits_type::move(_M_data(), __s, __n);
    _M_rep()->_M_set_sharable();
    _M_rep()->_M_length = __n;
    _M_data()[__n] = _Rep::_S_terminal;
    return *this;
  }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       if (this->max_size() - this->size() < __n)
  __throw_length_error(("basic_string::insert"));
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {



           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             traits_type::copy(__p, __s, __n);
           else if (__s >= __p)
             traits_type::copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               traits_type::copy(__p, __s, __nleft);
               traits_type::copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       if (this->max_size() - (this->size() - __n1) < __n2)
         __throw_length_error(("basic_string::replace"));
       bool __left;
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
    || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    const size_type __off = __s - _M_data();
    _M_mutate(__pos, __n1, __n2);
    if (__left)
      traits_type::copy(_M_data() + __pos,
          _M_data() + __off, __n2);
    else
      traits_type::copy(_M_data() + __pos,
          _M_data() + __off + __n2 - __n1, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {

      if (this == &_S_empty_rep())
 return;

      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, capacity(), __a);

   if (__pos)
     traits_type::copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     traits_type::copy(__r->_M_refdata() + __pos + __len2,
         _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   traits_type::move(_M_data() + __pos + __len2,
       _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_sharable();
      _M_rep()->_M_length = __new_size;
      _M_data()[__new_size] = _Rep::_S_terminal;

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   if (__res > this->max_size())
     __throw_length_error(("basic_string::reserve"));

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 501 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __subpagesize = 128;
      const size_type __malloc_header_size = 4 * sizeof (void*);
# 513 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 3
      const size_type __page_capacity = ((__pagesize - __malloc_header_size
       - sizeof(_Rep) - sizeof(_CharT))
      / sizeof(_CharT));

      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity
   && __capacity > __page_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
      else if (__size > __subpagesize)
 {
   const size_type __extra = __subpagesize - __adj_size % __subpagesize;
   __capacity += __extra / sizeof(_CharT);
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      __p->_M_length = 0;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 traits_type::copy(__r->_M_refdata(), _M_refdata(),
     this->_M_length);

      __r->_M_length = this->_M_length;
      __r->_M_refdata()[this->_M_length] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)
    {
      if (__n > max_size())
 __throw_length_error(("basic_string::resize"));
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 if (this->max_size() - (this->size() - __n1) < __s.size())
   __throw_length_error(("basic_string::_M_replace_dispatch"));
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {



      const size_type __size = __str.size();
      const size_type __len = __size + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __str._M_data(),
        __str.size());
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {



      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      const size_type __len = __n + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __str._M_data()
        + __pos, __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      const size_type __len = __n + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __s, __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 traits_type::copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();
      for (; __pos + __n <= __size; ++__pos)
 if (traits_type::compare(__data + __pos, __s, __n) == 0)
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      const size_type __size = this->size();
      size_type __ret = npos;
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = __n - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = __size - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 973 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_string.tcc" 3
}
# 58 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/string" 2 3
# 301 "C:/upp/uppsrc/Core/Core.h" 2
# 315 "C:/upp/uppsrc/Core/Core.h"
namespace Upp {};
# 327 "C:/upp/uppsrc/Core/Core.h"
namespace Upp {

# 1 "C:/upp/uppsrc/Core/Defs.h" 1
# 15 "C:/upp/uppsrc/Core/Defs.h"
bool IsPanicMode();

void Panic(const char *msg);

void AssertFailed(const char *file, int line, const char *cond);
# 107 "C:/upp/uppsrc/Core/Defs.h"
struct Callinit {
 Callinit(void (*fn)()) { fn(); }
};

struct Callexit {
 Callexit(void (*fn)()) { atexit(fn); }
};
# 151 "C:/upp/uppsrc/Core/Defs.h"
template <class T> inline const T& min(const T& a, const T& b) { return a < b ? a : b; }
template <class T> inline const T& max(const T& a, const T& b) { return a > b ? a : b; }

template <class T>
inline T minmax(T x, T _min, T _max) { return min(max(x, _min), _max); }

typedef unsigned char byte;
typedef signed char int8;
typedef unsigned char uint8;

typedef short unsigned word;
typedef short int int16;
typedef short unsigned uint16;


typedef unsigned long dword;
typedef long int32;
typedef unsigned long uint32;
# 178 "C:/upp/uppsrc/Core/Defs.h"
typedef word wchar;






typedef long long int int64;
typedef long long unsigned uint64;


typedef uint64 qword;
# 243 "C:/upp/uppsrc/Core/Defs.h"
int RegisterTypeNo__(const char *type);

template <class T>
int RegisterTypeNo___()
{
 return RegisterTypeNo__(typeid(T).name());
}

template <class T>
inline int StaticTypeNo() {
 static int typeno = -1;
 if(typeno < 0)
  typeno = RegisterTypeNo___<T>();
 return typeno;
}

size_t HeapRoundUp(size_t size);







void *MemoryAllocPermanent(size_t size);

void *MemoryAlloc(size_t size);
void MemoryFree(void *ptr);

void MemoryShrink();


void *MemoryAllocDebug(size_t size);
void MemoryFreeDebug(void *ptr);

void MemoryWatch(void *leak);
inline void MemoryWatch(uintptr_t leak) { MemoryWatch((void *)leak); }
void MemoryWatchFree(void *ptr);
inline void MemoryWatchFree(uintptr_t leak) { MemoryWatchFree((void *)leak); }

void MemoryInitDiagnostics();
void MemoryDumpLeaks();
void MemoryCheck();

enum MemoryProbeFlags {
 MEMORY_PROBE_FULL = 1,
 MEMORY_PROBE_FREE = 2,
 MEMORY_PROBE_MIXED = 4,
 MEMORY_PROBE_LARGE = 8,
 MEMORY_PROBE_SUMMARY = 16,
};

void MemoryCheckDebug();

int MemoryUsedKb();

struct MemoryProfile {
 int allocated[1024];
 int fragmented[1024];
 int freepages;
 int large_count;
 int large_size[1024];
 int large_total;
 int large_free_count;
 int large_free_size[1024];
 int large_free_total;

 MemoryProfile();
};

MemoryProfile *PeakMemoryProfile();
# 348 "C:/upp/uppsrc/Core/Defs.h"
bool CPU_MMX();
bool CPU_SSE();
bool CPU_SSE2();
bool CPU_SSE3();







inline const char *FromSysChrSet(const char *s) { return s; }
inline const char *ToSysChrSet(const char *s) { return s; }
# 330 "C:/upp/uppsrc/Core/Core.h" 2

};
# 346 "C:/upp/uppsrc/Core/Core.h"
inline void *operator new(size_t size) throw(std::bad_alloc) { void *ptr = Upp::MemoryAlloc(size); return ptr; }
inline void operator delete(void *ptr) throw() { Upp::MemoryFree(ptr); }

inline void *operator new[](size_t size) throw(std::bad_alloc) { void *ptr = Upp::MemoryAlloc(size); return ptr; }
inline void operator delete[](void *ptr) throw() { Upp::MemoryFree(ptr); }





namespace Upp {

# 1 "C:/upp/uppsrc/Core/Mt.h" 1




typedef LONG Atomic;

inline int AtomicRead(const volatile Atomic& t) { return t; }
inline void AtomicWrite(volatile Atomic& t, int val) { t = val; }

inline int AtomicInc(volatile Atomic& t) { return InterlockedIncrement((Atomic *)&t); }
inline int AtomicDec(volatile Atomic& t) { return InterlockedDecrement((Atomic *)&t); }
inline int AtomicXAdd(volatile Atomic& t, int incr) { return InterlockedExchangeAdd((Atomic *)&t, incr); }

class CriticalSection {
protected:
 CRITICAL_SECTION section;




 CriticalSection(int) {}

public:
 void Enter();
 void Leave();

 CriticalSection();
 ~CriticalSection() { DeleteCriticalSection(&section); }

 struct Lock;
};


inline void CriticalSection::Enter() { EnterCriticalSection(&section); }
inline void CriticalSection::Leave() { LeaveCriticalSection(&section); }
inline CriticalSection::CriticalSection() { InitializeCriticalSection(&section); }
# 70 "C:/upp/uppsrc/Core/Mt.h"
struct CriticalSection::Lock {
 CriticalSection& s;
 Lock(CriticalSection& s) : s(s) { s.Enter(); }
 ~Lock() { s.Leave(); }
};

class StaticCriticalSection {
 volatile CriticalSection *section;
 byte buffer[sizeof(CriticalSection)];

 void Initialize();

public:
 CriticalSection& Get() { if(!section) Initialize(); return *const_cast<CriticalSection *>(section); }
 operator CriticalSection&() { return Get(); }
 void Enter() { Get().Enter(); }
 void Leave() { Get().Leave(); }
};
# 359 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Global.h" 1
# 54 "C:/upp/uppsrc/Core/Global.h"
void Set__(volatile bool& b);
# 360 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Topt.h" 1
class NoCopy {
private:
 NoCopy(const NoCopy&);
 void operator=(const NoCopy&);
public:
 NoCopy() {}
};

template <class T>
inline void Swap(T& a, T& b) { T tmp = a; a = b; b = tmp; }

template <class I>
inline void IterSwap(I a, I b) { if(a != b) Swap(*a, *b); }

class EmptyClass
{
public:

};

template <class T, class B = EmptyClass>
class RelOps : public B
{
public:
 friend bool operator > (const T& a, const T& b) { return b < a; }
 friend bool operator != (const T& a, const T& b) { return !(a == b); }
 friend bool operator <= (const T& a, const T& b) { return !(b < a); }
 friend bool operator >= (const T& a, const T& b) { return !(a < b); }


};

template <class U, class V, class B = EmptyClass>
class AddOps : public B
{
public:
 friend U& operator -= (U& a, const V& b) { a += -b; return a; }
 friend U operator + (const U& a, const V& b) { U x(a); x += b; return x; }
 friend U operator - (const U& a, const V& b) { U x(a); x += -b; return x; }


};

template <class T, class B = EmptyClass>
class PostfixOps : public B
{
public:
 friend T operator ++ (T& i, int) { T x = i; ++i; return x; }
 friend T operator -- (T& i, int) { T x = i; --i; return x; }


};

template <class T, int (*compare)(T a, T b), class B = EmptyClass>
class CompareRelOps : public B
{
public:
 friend bool operator < (T a, T b) { return (*compare)(a, b) < 0; }
 friend bool operator > (T a, T b) { return (*compare)(a, b) > 0; }
 friend bool operator == (T a, T b) { return (*compare)(a, b) == 0; }
 friend bool operator != (T a, T b) { return (*compare)(a, b) != 0; }
 friend bool operator <= (T a, T b) { return (*compare)(a, b) <= 0; }
 friend bool operator >= (T a, T b) { return (*compare)(a, b) >= 0; }


};

template <class T, class B = EmptyClass>
struct Comparable : public B
{
public:
 friend bool operator < (const T& a, const T& b) { return a.Compare(b) < 0; }
 friend bool operator > (const T& a, const T& b) { return a.Compare(b) > 0; }
 friend bool operator == (const T& a, const T& b) { return a.Compare(b) == 0; }
 friend bool operator != (const T& a, const T& b) { return a.Compare(b) != 0; }
 friend bool operator <= (const T& a, const T& b) { return a.Compare(b) <= 0; }
 friend bool operator >= (const T& a, const T& b) { return a.Compare(b) >= 0; }
 friend int SgnCompare(const T& a, const T& b) { return a.Compare(b); }
};

template <class T>
int NumberCompare__(const T& a, const T& b)
{
 if(a < b) return -1;
 if(a > b) return 1;
 return 0;
}

inline int SgnCompare(const char& a, const char& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const signed char& a, const signed char& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const unsigned char& a, const unsigned char& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const short& a, const short& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const unsigned short& a, const unsigned short& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const int& a, const int& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const unsigned int& a, const unsigned int& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const long& a, const long& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const unsigned long& a, const unsigned long& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const bool& a, const bool& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const int64& a, const int64& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const uint64& a, const uint64& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const float& a, const float& b) { return NumberCompare__(a, b); }
inline int SgnCompare(const double& a, const double& b) { return NumberCompare__(a, b); }

template<class T>
inline int SgnCompare(const T& a, const T& b)
{
 return a.Compare(b);
}

struct CombineCompare {
 int result;

 template <class T>
 CombineCompare& operator()(const T& a, const T& b) { if(!result) result = SgnCompare(a, b); return *this; }

 operator int() const { return result; }

 CombineCompare() { result = 0; }

 template <class T>
 CombineCompare(const T& a, const T& b) { result = 0; operator()(a, b); }
};

template <class T>
inline void Fill(T *dst, const T *lim, const T& x) {
 while(dst < lim)
  *dst++ = x;
}

template <class T>
inline void Copy(T *dst, const T *src, const T *lim) {
 while(src < lim)
  *dst++ = *src++;
}

template <class T>
inline void Copy(T *dst, const T *src, int n) {
 Copy(dst, src, src + n);
}

inline void Fill(char *t, const char *lim, const char& x)
{ memset(t, x, size_t(lim - t)); }
inline void Copy(char *dst, const char *src, const char *lim)
{ memcpy(dst, src, size_t((byte *)lim - (byte *)src)); }

inline void Fill(signed char *t, const signed char *lim, const signed char& x)
{ memset(t, x, size_t(lim - t)); }
inline void Copy(signed char *dst, const signed char *src, const signed char *lim)
{ memcpy(dst, src, size_t((byte *)lim - (byte *)src)); }

inline void Fill(unsigned char *t, const unsigned char *lim, const unsigned char& x)
{ memset(t, x, size_t(lim - t)); }
inline void Copy(unsigned char *dst, const unsigned char *src, const unsigned char *lim)
{ memcpy(dst, src, size_t((byte *)lim - (byte *)src)); }

template <class T>
inline void DeepCopyConstruct(void *p, const T& x) {
 ::new(p) T(x);
}

template <class T>
inline T *DeepCopyNew(const T& x) {
 return new T(x);
}

template <class T>
inline void ConstructArray(T *t, const T *lim) {
 while(t < lim)
  ::new(t++) T;
}

template <class T>
inline void DestroyArray(T *t, const T *lim) {
 while(t < lim) {
  t->T::~T();
  t++;
 }
}

template <class T>
inline void DeepCopyConstructArray(T *t, const T *s, const T *lim) {
 while(s < lim)
  DeepCopyConstruct(t++, *s++);
}

template <class T>
inline void DeepCopyConstructFill(T *t, const T *lim, const T& x) {
 while(t < lim)
  DeepCopyConstruct(t++, x);
}
# 210 "C:/upp/uppsrc/Core/Topt.h"
template <class T>
inline void AssertMoveablePtr(T, T) {}

template <class T>
inline void AssertMoveable0(T *t) { AssertMoveablePtr(&**t, *t); }

template <class T, class B = EmptyClass>
struct Moveable : public B {
 friend void AssertMoveable0(T *) {}

};

template <class T>
inline void AssertMoveable(T *t = 0) { if(t) AssertMoveable0(t); }
# 233 "C:/upp/uppsrc/Core/Topt.h"
inline void AssertMoveable0(bool *) {};
inline void AssertMoveable0(char *) {};
inline void AssertMoveable0(signed char *) {};
inline void AssertMoveable0(unsigned char *) {};
inline void AssertMoveable0(short *) {};
inline void AssertMoveable0(unsigned short *) {};
inline void AssertMoveable0(int *) {};
inline void AssertMoveable0(unsigned int *) {};
inline void AssertMoveable0(long *) {};
inline void AssertMoveable0(unsigned long *) {};
inline void AssertMoveable0(int64 *) {};
inline void AssertMoveable0(uint64 *) {};
inline void AssertMoveable0(float *) {};
inline void AssertMoveable0(double *) {};
inline void AssertMoveable0(void * *) {};
inline void AssertMoveable0(const void * *) {};

template <class T, class B = EmptyClass>
class DeepCopyOption : public B {
public:
 friend T& operator<<=(T& dest, const T& src)
 { (&dest)->T::~T(); ::new(&dest) T(src, 1); return dest; }
 friend void DeepCopyConstruct(void *dest, const T& src)
 { ::new (dest) T(src, 0); }
 friend T *DeepCopyNew(const T& src)
 { return ::new T(src, 0); }

};

template <class T, class B = EmptyClass>
class MoveableAndDeepCopyOption : public Moveable< T, DeepCopyOption<T, B> > {
public:

};

template <class T, class B = EmptyClass>
class PolyDeepCopyNew : public B
{
public:
 friend T *DeepCopyNew(const T& t) { return t.Copy(); }

};

template <class T>
class WithDeepCopy : public T {
public:
 WithDeepCopy(const T& a) : T(a, 1) {}
 WithDeepCopy(const WithDeepCopy& a) : T(a, 1) {}
 WithDeepCopy& operator=(const WithDeepCopy& a) { (T&)*this <<= a; return *this; }
 WithDeepCopy(int, const T& a) : T(a) {}
 WithDeepCopy& operator^=(const T& a) { (T&)*this = a; return *this; }
 WithDeepCopy() {}
};

template <class V>
class ConstIIterator {
protected:
 const V *cont;
 int ii;
 typedef typename V::ValueType T;
 struct NP { int dummy; };

public:
 const T& operator*() const { return (*cont)[ii]; }
 const T *operator->() const { return &(*cont)[ii]; }
 const T& operator[](int i) const { return (*cont)[ii + i]; }

 ConstIIterator& operator++() { ++ii; return *this; }
 ConstIIterator& operator--() { --ii; return *this; }
 ConstIIterator operator++(int) { ConstIIterator t = *this; ++ii; return t; }
 ConstIIterator operator--(int) { ConstIIterator t = *this; --ii; return t; }

 ConstIIterator& operator+=(int d) { ii += d; return *this; }
 ConstIIterator& operator-=(int d) { ii -= d; return *this; }

 ConstIIterator operator+(int d) const { return ConstIIterator(cont, ii + d); }
 ConstIIterator operator-(int d) const { return ConstIIterator(cont, ii - d); }

 int operator-(const ConstIIterator& b) const { return ii - b.ii; }

 bool operator==(const ConstIIterator& b) const { return ii == b.ii; }
 bool operator!=(const ConstIIterator& b) const { return ii != b.ii; }
 bool operator<(const ConstIIterator& b) const { return ii < b.ii; }
 bool operator>(const ConstIIterator& b) const { return ii > b.ii; }
 bool operator<=(const ConstIIterator& b) const { return ii <= b.ii; }
 bool operator>=(const ConstIIterator& b) const { return ii >= b.ii; }

 operator bool() const { return ii < 0; }

 ConstIIterator() {}
 ConstIIterator(NP *null) { ; ii = -1; }
 ConstIIterator(const V& _cont, int ii) : cont(&_cont), ii(ii) {}
};

template <class V>
class IIterator {
protected:
 V *cont;
 int ii;
 typedef typename V::ValueType T;
 struct NP { int dummy; };

public:
 T& operator*() { return (*cont)[ii]; }
 T *operator->() { return &(*cont)[ii]; }
 T& operator[](int i) { return (*cont)[ii + i]; }

 const T& operator*() const { return (*cont)[ii]; }
 const T *operator->() const { return &(*cont)[ii]; }
 const T& operator[](int i) const { return (*cont)[ii + i]; }

 IIterator& operator++() { ++ii; return *this; }
 IIterator& operator--() { --ii; return *this; }
 IIterator operator++(int) { IIterator t = *this; ++ii; return t; }
 IIterator operator--(int) { IIterator t = *this; --ii; return t; }

 IIterator& operator+=(int d) { ii += d; return *this; }
 IIterator& operator-=(int d) { ii -= d; return *this; }

 IIterator operator+(int d) const { return IIterator(*cont, ii + d); }
 IIterator operator-(int d) const { return IIterator(*cont, ii - d); }

 int operator-(const IIterator& b) const { return ii - b.ii; }

 bool operator==(const IIterator& b) const { return ii == b.ii; }
 bool operator!=(const IIterator& b) const { return ii != b.ii; }
 bool operator<(const IIterator& b) const { return ii < b.ii; }
 bool operator>(const IIterator& b) const { return ii > b.ii; }
 bool operator<=(const IIterator& b) const { return ii <= b.ii; }
 bool operator>=(const IIterator& b) const { return ii >= b.ii; }

 operator bool() const { return ii < 0; }

 IIterator() {}
 IIterator(NP *null) { ; ii = -1; }
 IIterator(V& _cont, int ii) : cont(&_cont), ii(ii) {}
};

int Pow2Bound(int i);

unsigned memhash(const void *ptr, size_t size);

template <class T>
inline unsigned GetHashValue(const T& x) { return x.GetHashValue(); }

struct CombineHash {
 unsigned hash;

 enum { INIT = 1234567890 };

 template <class T> CombineHash& Do(const T& x) { Put(GetHashValue(x)); return *this; }

public:
 CombineHash& Put(unsigned h) { hash = ((hash << 4) + hash) ^ h; return *this; }

 operator unsigned() const { return hash; }

 CombineHash() { hash = INIT; }
 template <class T>
 CombineHash(const T& h1) { hash = INIT; Do(h1); }
 template <class T, class U>
 CombineHash(const T& h1, const U& h2) { hash = INIT; Do(h1); Do(h2); }
 template <class T, class U, class V>
 CombineHash(const T& h1, const U& h2, const V& h3) { hash = INIT; Do(h1); Do(h2); Do(h3); }
 template <class T, class U, class V, class W>
 CombineHash(const T& h1, const U& h2, const V& h3, const W& h4) { hash = INIT; Do(h1); Do(h2); Do(h3); Do(h4); }

 template <class T> CombineHash& operator<<(const T& x) { Do(x); return *this; }
};

template<> inline unsigned GetHashValue(const char& a) { return (unsigned)a; }
template<> inline unsigned GetHashValue(const signed char& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const unsigned char& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const short& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const unsigned short& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const int& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const unsigned int& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const long& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const unsigned long& a) { return (const unsigned)a; }
template<> inline unsigned GetHashValue(const bool& a) { return (const unsigned)a; }

template<> inline unsigned GetHashValue(const int64& a) { return CombineHash((unsigned)a, (unsigned)(a >> 32)); }
template<> inline unsigned GetHashValue(const uint64& a) { return GetHashValue((int64)a); }

unsigned GetHashValue0(const double& a);

template<> inline unsigned GetHashValue(const double& a) { return GetHashValue0(a); }
template<> inline unsigned GetHashValue(const float& a) { double x = a; return GetHashValue0(x); }


inline unsigned GetPtrHashValue(const void *a) { return (int)a; }
# 435 "C:/upp/uppsrc/Core/Topt.h"
template <class T> inline const T& ntl_max(const T& a, const T& b) { return a > b ? a : b; }
# 361 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Profile.h" 1
class String;

class TimingInspector {
protected:
 static bool active;

 const char *name;
 int call_count;
 dword total_time;
 dword min_time;
 dword max_time;
 int nesting_depth;
 int max_nesting;
 int all_count;
 dword start_time;

public:
 TimingInspector(const char *name = __null);
 ~TimingInspector();

 void Start();
 void End();

 String Dump() const;

 class Routine {
 public:
  Routine(TimingInspector& stat) : stat(stat) { stat.Start(); }
  ~Routine() { stat.End(); }

 protected:
  TimingInspector& stat;
 };

 static void Activate(bool b) { active = b; }
};

class HitCountInspector
{
public:
 HitCountInspector(const char *name, int hitcount = 0) : name(name), hitcount(hitcount) {}
 ~HitCountInspector();

 void Step() { hitcount++; }
 void Add(int i) { hitcount += i; }
 void operator ++ () { Step(); }
 void operator += (int i) { Add(i); }

private:
 const char *name;
 int hitcount;
};
# 362 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/String.h" 1
class Nuller;



int wstrlen(const wchar *s);
# 17 "C:/upp/uppsrc/Core/String.h"
template <class T, class St>
class AStringBuffer;

inline int strlen__(const char *s) { return strlen(s); }
inline int strlen__(const wchar *s) { return wstrlen(s); }

template <class T, class S>
class AString : public Moveable<S> {
protected:
 struct Data {
  Atomic refcount;
  int length;
  int alloc;

  T *GetPtr() const { return (T*)(this + 1); }
  void Release() { ; if(AtomicDec(refcount) == 0) delete[] (byte *)this; }
  void Retain() { ; AtomicInc(refcount); }
 };

 T *ptr;

 static Data *GetData(const T *ptr) { return (Data *)ptr - 1; }

 static Data *Alloc(int len);
 static Data *Clone(const Data *data, int newalloc);

 static T *CreateEmpty(Data *kind);
 static T *Create(int len);
 static T *Create(const T *data, int len);

 void Retain() const { GetData(ptr)->Retain(); }
 void Release() { GetData(ptr)->Release(); }

 void Chk() const { ; }

 void Cat(int c);
 void Cat(int c, int count);
 void Cat(const T *s, int len);

 void Insert(int at, int c);
 void Insert(int at, const T *s, int len);

 void Assign(const AString& s);
 void Assign(const T *s, int len);
 void DeepAssign(const AString& s);

 T *Mid(int pos, int length) const;
 T *Mid(int pos) const;
 T *Right(int count) const;
 T *Left(int count) const;

 bool IsEqual(const T *ptr, int len) const;

 AString(int, T *p) { ptr = p; }

public:
 void Remove(int at, int count = 1);

 void Set(int at, int chr);

 void Trim(int at);

 int GetLength() const { return GetData(ptr)->length; }
 int GetCount() const { return GetData(ptr)->length; }
 bool IsEmpty() const { return GetCount() == 0; }

 int Find(int chr, int from = 0) const;
 int ReverseFind(int chr, int from) const;
 int ReverseFind(int chr) const;

 int Find(int len, const T *s, int from) const;
 int Find(const T *s, int from = 0) const;
 int Find(const S& s, int from = 0) const { return Find(s.GetCount(), s.Begin(), from); }

 bool StartsWith(const T *s, int len) const;
 bool StartsWith(const T *s) const { return StartsWith(s, strlen(s)); }
 bool StartsWith(const S& s) const { return StartsWith(s, s.GetLength()); }

 bool EndsWith(const T *s, int len) const;
 bool EndsWith(const T *s) const { return EndsWith(s, strlen(s)); }
 bool EndsWith(const S& s) const { return EndsWith(s, s.GetLength()); }

 void Clear();

 void Shrink();
 void Reserve(int len);
 int GetAlloc() const { return GetData(ptr)->alloc; }

 T *GetBuffer(int minlen);
 void ReleaseBuffer(int newlen = -1);

 AString() { ptr = S::CreateNull(); }
 AString(const AString& a) { ptr = a.ptr; Retain(); }
 AString(const T *s, int len) { ptr = Create(s, len); }
 AString(const T *s) { ptr = s ? Create(s, strlen__(s)) : S::CreateNull(); }
 AString(int chr, int count);

 ~AString() { Chk(); Release(); }
 typedef T ValueType;
 typedef const T* ConstIterator;
 const T *Begin() const { return ptr; }
 const T *End() const { return ptr + GetCount(); }
 const T *Last() const { return End() - 1; }
 const T *GetIter(int i) const { ; return ptr + i; }

 friend class AStringBuffer<T, S>;

 friend bool operator<(const S& a, const S& b) { return a.Compare(b) < 0; }
 friend bool operator<(const S& a, const T *b) { return a.Compare(b) < 0; }
 friend bool operator<(const T *a, const S& b) { return b.Compare(a) > 0; }

 friend bool operator<=(const S& a, const S& b) { return a.Compare(b) <= 0; }
 friend bool operator<=(const S& a, const T *b) { return a.Compare(b) <= 0; }
 friend bool operator<=(const T *a, const S& b) { return b.Compare(a) >= 0; }

 friend bool operator>(const S& a, const S& b) { return a.Compare(b) > 0; }
 friend bool operator>(const S& a, const T *b) { return a.Compare(b) > 0; }
 friend bool operator>(const T *a, const S& b) { return b.Compare(a) < 0; }

 friend bool operator>=(const S& a, const S& b) { return a.Compare(b) >= 0; }
 friend bool operator>=(const S& a, const T *b) { return a.Compare(b) >= 0; }
 friend bool operator>=(const T *a, const S& b) { return b.Compare(a) <= 0; }





 friend bool operator==(const S& a, const S& b) { return a.Compare(b) == 0; }
 friend bool operator!=(const S& a, const S& b) { return a.Compare(b) != 0; }

 friend bool operator==(const S& a, const T *b) { return a.Compare(b) == 0; }
 friend bool operator==(const T *a, const S& b) { return b.Compare(a) == 0; }

 friend bool operator!=(const S& a, const T *b) { return a.Compare(b) != 0; }
 friend bool operator!=(const T *a, const S& b) { return b.Compare(a) != 0; }

 friend S operator+(const S& a, const S& b) { S c(a); c += b; return c; }
 friend S operator+(const S& a, const T *b) { S c(a); c += b; return c; }
 friend S operator+(const T *a, const S& b) { S c(a); c += b; return c; }
 friend S operator+(const S& a, int b) { S c(a); c += b; return c; }
 friend S operator+(int a, const S& b) { S c; c.Cat(a); c += b; return c; }
 friend S operator+(const S& a, T b) { S c(a); c += b; return c; }
 friend S operator+(T a, const S& b) { S c; c.Cat(a); c += b; return c; }
};

template <class T, class S>
class AStringBuffer {
protected:
 T *begin;
 T *end;
 T *alloc;

 void Reads() { typename S::Data *d = S::GetData(begin); end = begin + d->length; alloc = begin + d->alloc; }
 void Realloc(int newalloc);
 void Expand(int len);
 void Expand();
 void Init(int len);
 void Init(S& text, int minalloc);
 void Free() { if(begin) S::GetData(begin)->Release(); }
 T *Get();
 void Set(S& s);
 T *Ptr() { *end = '\0'; return begin; }

 friend class String;
 friend class WString;

public:
 AStringBuffer();
 AStringBuffer(int length) { Init(length); }
 AStringBuffer(S& text) { Init(text, text.GetCount()); }
 AStringBuffer(S& text, int length) { Init(text, length); end = begin + length; }

 operator T*() { return Ptr(); }
 operator void*() { return Ptr(); }
 T *operator~() { return Ptr(); }

 void Cat(int c) { if(end >= alloc) Expand(); *end++ = c; }
 void Cat(int c, int count) { if(end + count >= alloc) Expand(count);
                                          Fill(end, end + count, (T)c); end += count; }
 void Cat(const T *s, int len) { if(end + len >= alloc) Expand(len);
                                          memcpy(end, s, sizeof(T) * len); end += len; }

 int GetLength() const { return end - begin; }
 T *SetLength(int len);
 int GetCount() const { return GetLength(); }
 T *SetCount(int len) { return SetLength(len); }
 T *Begin() { return begin; }
 T *End() { return end; }

 void Clear();
 void Reserve(int alloc);

 ~AStringBuffer();

private:
 AStringBuffer(const AStringBuffer&);
 void operator=(const AStringBuffer&);
};

class WString;

class String : public AString<char, String> {
 typedef AString<char, String> B;

 String(Data *data) { ptr = CreateEmpty(data); }
 String(int, char *p) : B(0, p) {}

 static Data *Void();
 static Data *Zero();

 static char *CreateNull();

 void Slice(const char *a, int n);


 friend class AString<char, String>;
 friend class AStringBuffer<char, String>;

public:
 class Buffer;
 friend class String::Buffer;

 void Cat(int c) { B::Cat(c); }
 void Cat(const char *s);
 void Cat(const String& s);

 void Cat(int c, int count) { B::Cat(c, count); }
 void Cat(const char *s, int len) { B::Cat(s, len); }
 void Cat(const char *s, const char *lim) { ; Cat(s, lim - s); }
 void Cat(const String& s, int len) { B::Cat(~s, len); }
 void Cat(const byte *s, int len) { B::Cat((const char *) s, len); }

 String& Cat() { return *this; }

 const String& operator+=(char c) { Cat(c); return *this; }
 const String& operator+=(const char *s) { Cat(s); return *this; }
 const String& operator+=(const String& s) { Cat(s); return *this; }

 String& operator=(const char *s);
 String& operator=(const String& s) { B::Assign(s); return *this; }
 String& operator=(Buffer& b) { *this = String(b); return *this; }
 String& operator<<=(const String& s) { B::DeepAssign(s); return *this; }

 void Insert(int at, int c) { B::Insert(at, c); }
 void Insert(int at, const String& s);
 void Insert(int at, const char *s, int l) { B::Insert(at, s, l); }
 void Insert(int at, const char *s);

 String Mid(int pos, int length) const { return String(0, B::Mid(pos, length)); }
 String Mid(int pos) const { return String(0, B::Mid(pos)); }
 String Right(int count) const { return String(0, B::Right(count)); }
 String Left(int count) const { return String(0, B::Left(count)); }

 bool IsEqual(const String& s) const;
 bool IsEqual(const char *s) const;

 int Compare(const String& s) const;
 int Compare(const char *s) const;

 const char *operator~() const { return B::ptr; }
 operator const char*() const { return B::ptr; }
 operator const void*() const { return B::ptr; }
 operator const byte*() const { return (byte *) B::ptr; }

 int operator*() const { return *B::ptr; }
 int operator[](int i) const { ; return (byte)ptr[i]; }
 bool IsVoid() const;
 bool IsZero() const;

 static String GetVoid();
 static String GetZero();



 WString ToWString() const;
 const String& ToString() const { return *this; }

 String();
 String(const Nuller&);
 String(const String& s);
 String(const char *s);
 String(const String& s, int n);
 String(const char *s, int n);
 String(const byte *s, int n);



 String(const char *s, const char *lim);

 String(int chr, int count);
 String(Buffer& b) : B(0, b.Get()) {};
 ~String();

 friend void Swap(String& a, String& b) { char *h = a.ptr; a.ptr = b.ptr; b.ptr = h; }

 class Buffer : public AStringBuffer<char, String> {
  typedef AStringBuffer<char, String> B;

 public:
  Buffer() {}
  Buffer(int length) : B(length) {}
  Buffer(String& text) : B(text) {}
  Buffer(String& text, int length) : B(text, length) {}

  void Cat(int c) { B::Cat(c); }
  void Cat(int c, int count) { B::Cat(c, count); }
  void Cat(const char *s, int len) { B::Cat(s, len); }

  void Cat(const char *s) { Cat(s, strlen(s)); }
  void Cat(const String& s) { Cat(s, s.GetLength()); }
  void Cat(const char *s, const char *lim) { ; Cat(s, lim - s); }
  void Cat(const String& s, int len) { Cat(~s, len); }
  void Cat(const byte *s, int len) { Cat((const char *) s, len); }

  void operator=(String& s) { Set(s); }

  void Strlen();
 };

 String(const std::string& s);
 operator std::string() const;
};

typedef String::Buffer StringBuffer;

inline bool IsEmpty(const String& s) { return s.IsEmpty(); }

template <class T> bool IsNull(const T& x) { return x.IsNullInstance(); }

String FormatPtr(const void *p);

template <class T>
inline String AsString(const T& x)
{
 return x.ToString();
}
# 369 "C:/upp/uppsrc/Core/String.h"
inline String& operator<<(String& s, const char *x)
{
 s.Cat(x);
 return s;
}

inline String& operator<<(String& s, char *x)
{
 s.Cat(x);
 return s;
}

inline String& operator<<(String& s, const String &x)
{
 s.Cat(x);
 return s;
}

inline String& operator<<(String& s, char x)
{
 s.Cat((int) x);
 return s;
}

inline String& operator<<(String& s, const void *x)
{
 s << FormatPtr(x);
 return s;
}

inline String& operator<<(String& s, void *x)
{
 s << FormatPtr(x);
 return s;
}

template <class T>
inline String& operator<<(String& s, const T& x)
{
 s.Cat(AsString(x));
 return s;
}

template<>
inline String& operator<<(String& s, const char * const &x)
{
 s.Cat(x);
 return s;
}

template<>
inline String& operator<<(String& s, const String &x)
{
 s.Cat(x);
 return s;
}

template<>
inline String& operator<<(String& s, const char& x)
{
 s.Cat(x);
 return s;
}

template<>
inline bool IsNull(const String& s) { return s.IsEmpty(); }

template<>
inline String AsString(const String& s) { return s; }

template<>
inline unsigned GetHashValue(const String& s) { return memhash(~s, s.GetLength()); }

int CompareNoCase(const String& a, const String& b, byte encoding = 0);
int CompareNoCase(const String& a, const char *b, byte encoding = 0);

inline
int CompareNoCase(const char *a, const String& b, byte encoding = 0) {
 return -CompareNoCase(b, a, encoding);
}

String TrimLeft(const String& s);
String TrimRight(const String& s);

inline StringBuffer& operator<<(StringBuffer& s, const char *x)
{
 s.Cat(x);
 return s;
}

inline StringBuffer& operator<<(StringBuffer& s, char *x)
{
 s.Cat(x);
 return s;
}

inline StringBuffer& operator<<(StringBuffer& s, const String &x)
{
 s.Cat(x);
 return s;
}

inline StringBuffer& operator<<(StringBuffer& s, char x)
{
 s.Cat((int) x);
 return s;
}

inline StringBuffer& operator<<(StringBuffer& s, const void *x)
{
 s << FormatPtr(x);
 return s;
}

inline StringBuffer& operator<<(StringBuffer& s, void *x)
{
 s << FormatPtr(x);
 return s;
}

template <class T>
inline StringBuffer& operator<<(StringBuffer& s, const T& x)
{
 s.Cat(AsString(x));
 return s;
}

template<>
inline StringBuffer& operator<<(StringBuffer& s, const char * const &x)
{
 s.Cat(x);
 return s;
}

template<>
inline StringBuffer& operator<<(StringBuffer& s, const String &x)
{
 s.Cat(x);
 return s;
}

template<>
inline StringBuffer& operator<<(StringBuffer& s, const char& x)
{
 s.Cat(x);
 return s;
}

class Value;

class WString : public AString<wchar, WString> {
 typedef AString<wchar, WString> B;

 WString(Data *data) { ptr = CreateEmpty(data); }
 WString(int, wchar *p) : B(0, p) {}

 static Data *Void();
 static Data *Zero();

 static wchar *CreateNull();


 friend class AString<wchar, WString>;
 friend class AStringBuffer<wchar, WString>;

public:
 class Buffer;
 friend class WString::Buffer;

 void Cat(int c) { B::Cat(c); }
 void Cat(const wchar *s);
 void Cat(const WString& s);

 void Cat(int c, int count) { B::Cat(c, count); }
 void Cat(const wchar *s, int len) { B::Cat(s, len); }
 void Cat(const wchar *s, const wchar *lim) { ; Cat(s, lim - s); }
 void Cat(const WString& s, int len) { B::Cat(~s, len); }

 WString& Cat() { return *this; }

 const WString& operator+=(wchar c) { Cat(c); return *this; }
 const WString& operator+=(const wchar *s) { Cat(s); return *this; }
 const WString& operator+=(const WString& s) { Cat(s); return *this; }

 WString& operator<<(wchar c) { Cat(c); return *this; }
 WString& operator<<(const WString& s) { Cat(s); return *this; }
 WString& operator<<(const wchar *s) { Cat(s); return *this; }

 WString& operator=(const wchar *s);
 WString& operator=(const WString& s) { B::Assign(s); return *this; }
 WString& operator=(Buffer& b) { *this = WString(b); return *this; }
 WString& operator<<=(const WString& s) { B::DeepAssign(s); return *this; }

 void Insert(int at, int c) { B::Insert(at, c); }
 void Insert(int at, const WString& s);
 void Insert(int at, const wchar *s, int l) { B::Insert(at, s, l); }
 void Insert(int at, const wchar *s);

 WString Mid(int pos, int length) const { return WString(0, B::Mid(pos, length)); }
 WString Mid(int pos) const { return WString(0, B::Mid(pos)); }
 WString Right(int count) const { return WString(0, B::Right(count)); }
 WString Left(int count) const { return WString(0, B::Left(count)); }

 bool IsEqual(const WString& s) const;
 bool IsEqual(const wchar *s) const;

 int Compare(const WString& s) const;
 int Compare(const wchar *s) const;

 const wchar *operator~() const { return B::ptr; }
 operator const wchar*() const { return B::ptr; }
 operator const void*() const { return B::ptr; }

 int operator*() const { return *B::ptr; }
 int operator[](int i) const { ; return ptr[i]; }

 bool IsVoid() const;
 bool IsZero() const;

 static WString GetVoid();
 static WString GetZero();

 String ToString() const;

 WString();
 WString(const Nuller&);
 WString(const WString& s);
 WString(const wchar *s);
 WString(const WString& s, int n);
 WString(const wchar *s, int n);
 WString(const wchar *s, const wchar *lim);
 WString(const char *s);
 WString(const char *s, int n);
 WString(const char *s, const char *lim);
 WString(int chr, int count);
 WString(Buffer& b) : B(0, b.Get()) {};
 ~WString();

 friend void Swap(WString& a, WString& b) { wchar *h = a.ptr; a.ptr = b.ptr; b.ptr = h; }

 class Buffer : public AStringBuffer<wchar, WString> {
  typedef AStringBuffer<wchar, WString> B;

 public:
  Buffer() {}
  Buffer(int length) : B(length) {}
  Buffer(WString& text) : B(text) {}
  Buffer(WString& text, int length) : B(text, length) {}

  void Cat(int c) { B::Cat(c); }
  void Cat(int c, int count) { B::Cat(c, count); }
  void Cat(const wchar *s, int len) { B::Cat(s, len); }

  void Cat(const char *s) { Cat(WString(s)); }
  void Cat(const wchar *s) { Cat(s, wstrlen(s)); }
  void Cat(const WString& s) { Cat(s, s.GetLength()); }
  void Cat(const wchar *s, const wchar *lim) { ; Cat(s, lim - s); }
  void Cat(const WString& s, int len) { Cat(~s, len); }

  void operator=(WString& s) { Set(s); }

  void Strlen();
 };

 WString(const std::wstring& s);
 operator std::wstring() const;
};

typedef WString::Buffer WStringBuffer;

inline bool IsEmpty(const WString& s) { return s.IsEmpty(); }

template<>
inline bool IsNull(const WString& s) { return s.IsEmpty(); }




template<>
inline unsigned GetHashValue(const WString& s) { return memhash(~s, 2 * s.GetLength()); }

WString TrimLeft(const WString& str);
WString TrimRight(const WString& s);

int CompareNoCase(const WString& a, const WString& b);
int CompareNoCase(const WString& a, const wchar *b);

inline
int CompareNoCase(const wchar *a, const WString& b) {
 return -CompareNoCase(b, a);
}

template<> inline String AsString(const char * const &s) { return s; }
template<> inline String AsString(char * const &s) { return s; }
template<> inline String AsString(const char& a) { return String(a, 1); }
template<> inline String AsString(const signed char& a) { return String(a, 1); }
template<> inline String AsString(const unsigned char& a) { return String(a, 1); }
template<> inline String AsString(const bool& a) { return a ? "true" : "false"; }

unsigned ctoi(int c);

typedef int (*CharFilter)(int);

int CharFilterAscii(int c);
int CharFilterAscii128(int c);
int CharFilterUnicode(int c);
int CharFilterDigit(int c);
int CharFilterWhitespace(int c);
int CharFilterAlpha(int c);
int CharFilterAlphaToUpper(int c);
int CharFilterAlphaToLower(int c);
int CharFilterInt(int c);
int CharFilterDouble(int c);
int CharFilterDefaultToUpperAscii(int c);

String Filter(const char *s, int (*filter)(int));
String FilterWhile(const char *s, int (*filter)(int));
# 363 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/String.hpp" 1
template <class T, class S>
typename AString<T, S>::Data *AString<T, S>::Alloc(int alloc)
{

 alloc = (HeapRoundUp((max(alloc, 5) + 1) * sizeof(T) + sizeof(Data)) - sizeof(Data)) / sizeof(T) - 1;

 Data *newdata = (Data *) new byte[sizeof(Data) + sizeof(T) * (alloc + 1)];
 newdata->alloc = alloc;
 newdata->length = 0;
 AtomicWrite(newdata->refcount, 1);
 return newdata;
}

template <class T, class S>
typename AString<T, S>::Data *AString<T, S>::Clone(const typename AString<T, S>::Data *data, int newalloc)
{
 Data *newdata = Alloc(newalloc);
 newdata->length = min(data->length, newalloc);
 memcpy(newdata->GetPtr(), data->GetPtr(), sizeof(T) * newdata->length);
 newdata->GetPtr()[newdata->length] = 0;
 return newdata;
}

template <class T, class S>
T *AString<T, S>::CreateEmpty(typename AString<T, S>::Data *data)
{
 AtomicInc(data->refcount);
 return (T *)(data + 1);
}

template <class T, class S>
T *AString<T, S>::Create(int len)
{
 if(!len)
  return S::CreateNull();
 Data *n = Alloc(len);
 n->length = len;
 T *p = (T *)(n + 1);
 *(p + len) = 0;
 return p;
}

template <class T, class S>
T *AString<T, S>::Create(const T *data, int len)
{
 if(!len)
  return S::CreateNull();
 T *ptr = Create(len);
 memcpy(ptr, data, sizeof(T) * len);
 ptr[len] = 0;
 return ptr;
}

template <class T, class S>
void AString<T, S>::Cat(const T *s, int len)
{
 Chk();
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) == 1 && d->length + len <= d->alloc) {
  memcpy(ptr + d->length, s, sizeof(T) * len);
  d->length += len;
  ptr[d->length] = 0;
 }
 else {
  Data *nd = Clone(d, d->length + max(d->length, len));
  ptr = nd->GetPtr();
  memcpy(ptr + d->length, s, sizeof(T) * len);
  d->Release();
  nd->length += len;
  ptr[nd->length] = 0;
 }
}

template <class T, class S>
void AString<T, S>::Cat(int c)
{
 Chk();
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1 || d->length >= d->alloc) {
  Data *nd = Clone(d, d->length + max(d->length, 1));
  ptr = nd->GetPtr();
  d->Release();
  d = nd;
 }
 ptr[d->length++] = c;
 ptr[d->length] = 0;
}

template <class T, class S>
void AString<T, S>::Cat(int c, int count)
{
 Chk();
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1 || d->length + count > d->alloc) {
  Data *nd = Clone(d, d->length + max(d->length, count));
  ptr = nd->GetPtr();
  d->Release();
  d = nd;
 }
 Fill(ptr + d->length, ptr + d->length + count, (T)c);
 d->length += count;
 ptr[d->length] = 0;
}

template <class T, class S>
void AString<T, S>::Insert(int at, const T *s, int len)
{
 Chk();
 ;
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) == 1 && d->length + len <= d->alloc &&
    !(s >= ptr && s < ptr + d->length)) {
  memmove(ptr + at + len, ptr + at, sizeof(T) * (d->length - at + 1));
  memcpy(ptr + at, s, sizeof(T) * len);
  d->length += len;
 }
 else {
  Data *nd = Alloc(d->length + max(d->length, len));
  T *nptr = nd->GetPtr();
  memcpy(nptr, ptr, sizeof(T) * at);
  memcpy(nptr + at, s, sizeof(T) * len);
  memcpy(nptr + at + len, ptr + at, sizeof(T) * (d->length - at + 1));
  ptr = nd->GetPtr();
  nd->length += d->length + len;
  d->Release();
 }
}

template <class T, class S>
void AString<T, S>::Insert(int at, int c)
{
 T x = c;
 Insert(at, &x, 1);
}

template <class T, class S>
void AString<T, S>::Remove(int at, int count)
{
 Chk();
 ;
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1) {
  Data *nd = Clone(d, d->length + max(d->length, count));
  ptr = nd->GetPtr();
  d->Release();
  d = nd;
 }
 memmove(ptr + at, ptr + at + count, sizeof(T) * (d->length - at - count + 1));
 d->length -= count;
}

template <class T, class S>
void AString<T, S>::Trim(int at)
{
 Chk();
 ;
 if(at >= GetLength()) return;
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1) {
  Data *nd = Clone(d, at);
  ptr = nd->GetPtr();
  d->Release();
  d = nd;
 }
 d->length = at;
 ptr[d->length] = 0;
}

template <class T, class S>
void AString<T, S>::Clear()
{
 Chk();
 Release();
 ptr = S::CreateNull();
}

template <class T, class S>
void AString<T, S>::Shrink()
{
 Chk();
 Data *d = GetData(ptr);
 Data *nd = Clone(d, d->length);
 ptr = nd->GetPtr();
 d->Release();
}

template <class T, class S>
void AString<T, S>::Reserve(int len)
{
 Chk();
 Data *d = GetData(ptr);
 if(len < d->alloc) return;
 Data *nd = Clone(d, len);
 ptr = nd->GetPtr();
 d->Release();
}

template <class T, class S>
T *AString<T, S>::GetBuffer(int len)
{
 ;
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1 || len >= d->alloc) {
  Data *nd = Clone(d, len);
  d->Release();
  d = nd;
  ptr = d->GetPtr();
 }



 return ptr;
}

template <class T, class S>
void AString<T, S>::ReleaseBuffer(int len)
{
 Data *d = GetData(ptr);
 if(len < 0) len = strlen__(ptr);
 ;
 ptr[len] = 0;
 d->length = len;



}

template <class T, class S>
void AString<T, S>::Assign(const AString<T, S>& s)
{
 Chk();
 s.Retain();
 Release();
 ptr = s.ptr;
}

template <class T, class S>
void AString<T, S>::Assign(const T *s, int len)
{
 Chk();
 T *q = Create(s, len);
 Release();
 ptr = q;
}

template <class T, class S>
void AString<T, S>::DeepAssign(const AString<T, S>& s)
{
 Chk();
 T *q = Create(s.ptr, s.GetLength());
 Release();
 ptr = q;
}

template <class T, class S>
void AString<T, S>::Set(int i, int chr)
{
 ;
 Data *d = GetData(ptr);
 if(AtomicRead(d->refcount) != 1) {
  Data *nd = Clone(d, d->length + max(d->length, GetCount()));
  ptr = nd->GetPtr();
  d->Release();
  d = nd;
 }
 ptr[i] = chr;
}

template <class T, class S>
T *AString<T, S>::Mid(int from, int count) const
{
 Chk();
 int l = GetLength();
 if(from > l) from = l;
 if(from < 0) from = 0;
 if(count < 0)
  count = 0;
 if(from + count > l)
  count = l - from;
 if(from == 0 && count == l) {
  Retain();
  return ptr;
 }
 else
  return Create(ptr + from, count);
}

template <class T, class S>
T *AString<T, S>::Mid(int from) const
{
 Chk();
 return Mid(from, GetLength() - from);
}

template <class T, class S>
T *AString<T, S>::Right(int count) const
{
 Chk();
 return Mid(GetLength() - count);
}

template <class T, class S>
T *AString<T, S>::Left(int count) const
{
 Chk();
 return Mid(0, count);
}

template <class T, class S>
int AString<T, S>::Find(int chr, int from) const
{
 ;
 const T *e = End();
 for(const T *s = ptr + from; s < e; s++)
  if(*s == chr)
   return s - ptr;
 return -1;
}

template <class T, class S>
int AString<T, S>::ReverseFind(int chr, int from) const
{
 ;
 if(from < GetLength())
  for(const T *s = ptr + from; s >= ptr; s--)
   if(*s == chr)
    return s - ptr;
 return -1;
}

template <class T, class S>
int AString<T, S>::ReverseFind(int chr) const
{
 return GetCount() ? ReverseFind(chr, GetCount() - 1) : -1;
}

template <class T, class S>
int AString<T, S>::Find(int len, const T *s, int from) const
{
 ;
 const T *p = ptr + from;
 int l = GetLength() - len - from;
 if(l < 0)
  return -1;
 const T *e = p + l;
 len *= sizeof(T);
 while(p <= e) {
  if(memcmp(s, p, len) == 0)
   return p - ptr;
  p++;
 }
 return -1;
}

template <class T, class S>
bool AString<T, S>::StartsWith(const T *s, int len) const
{
 if(len > GetLength()) return false;
 return memcmp(s, ptr, len * sizeof(T)) == 0;
}

template <class T, class S>
bool AString<T, S>::EndsWith(const T *s, int len) const
{
 int l = GetLength();
 if(len > l) return false;
 return memcmp(s, ptr + l - len, len * sizeof(T)) == 0;
}

template <class T, class S>
int AString<T, S>::Find(const T *s, int from) const
{
 return Find(strlen(s), s, from);
}

template <class T, class S>
bool AString<T, S>::IsEqual(const T *p, int len) const
{
 if(len != GetLength()) return false;
 if(len == 0 || p == ptr) return true;
 return memcmp(ptr, p, len * sizeof(T)) == 0;
}

template <class T, class S>
AString<T, S>::AString(int chr, int count)
{
 ptr = Create(count);
 Fill(ptr, ptr + count, (T)chr);
}

template <class T, class S>
void AStringBuffer<T, S>::Init(int len)
{
 begin = S::Create(len);
 Reads();
}

template <class T, class S>
void AStringBuffer<T, S>::Init(S& text, int alloc)
{
 typename S::Data *d = S::GetData(text.ptr);
 if(AtomicRead(d->refcount) != 1 || d->alloc < alloc) {
  typename S::Data *nd = S::Clone(d, alloc);
  d->Release();
  begin = nd->GetPtr();
 }
 else
  begin = text.ptr;
 text.ptr = S::CreateNull();
 Reads();
}

template <class T, class S>
AStringBuffer<T, S>::AStringBuffer()
{
 begin = S::CreateNull();
 Reads();
}

template <class T, class S>
void AStringBuffer<T, S>::Clear()
{
 Free();
 begin = S::CreateNull();
 Reads();
}

template <class T, class S>
void AStringBuffer<T, S>::Realloc(int newalloc)
{
 typename S::Data *d = S::GetData(begin);
 d->length = end - begin;
 typename S::Data *nd = S::Clone(d, newalloc);
 d->Release();
 begin = nd->GetPtr();
 Reads();
}

template <class T, class S>
void AStringBuffer<T, S>::Expand()
{
 typename S::Data *d = S::GetData(begin);
 Realloc(max(8, 2 * (int)(intptr_t)(alloc - begin)));
}

template <class T, class S>
void AStringBuffer<T, S>::Expand(int len)
{
 typename S::Data *d = S::GetData(begin);
 Realloc(max(8, max((int)(intptr_t)(alloc - begin + len), 2 * (int)(intptr_t)(alloc - begin))));
}

template <class T, class S>
void AStringBuffer<T, S>::Reserve(int len)
{
 if((len -= (int)(intptr_t)(alloc - begin)) > 0)
  Expand(len);
}

template <class T, class S>
T *AStringBuffer<T, S>::SetLength(int len)
{
 if(alloc - begin < len)
  Realloc(len);
 end = begin + len;
 return begin;
}

template <class T, class S>
T *AStringBuffer<T, S>::Get()
{
 int l = GetLength();
 begin[l] = 0;
 S::GetData(begin)->length = l;
 T *p = begin;
 begin = S::CreateNull();
 Reads();
 return p;
}

template <class T, class S>
void AStringBuffer<T, S>::Set(S& s)
{
 Free();
 Init(s, s.GetLength());
}

template <class T, class S>
AStringBuffer<T, S>::~AStringBuffer()
{
 Free();
}
# 364 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/CharSet.h" 1
# 34 "C:/upp/uppsrc/Core/CharSet.h"
enum {
 DEFAULTCHAR = 0x1f
};



extern word CHRTAB_ISO8859_1[128];
extern word CHRTAB_ISO8859_2[128];
extern word CHRTAB_ISO8859_3[128];
extern word CHRTAB_ISO8859_4[128];
extern word CHRTAB_ISO8859_5[128];
extern word CHRTAB_ISO8859_6[128];
extern word CHRTAB_ISO8859_7[128];
extern word CHRTAB_ISO8859_8[128];
extern word CHRTAB_ISO8859_9[128];
extern word CHRTAB_ISO8859_10[128];
extern word CHRTAB_ISO8859_13[128];
extern word CHRTAB_ISO8859_14[128];
extern word CHRTAB_ISO8859_15[128];
extern word CHRTAB_ISO8859_16[128];
extern word CHRTAB_WIN1250[128];
extern word CHRTAB_WIN1251[128];
extern word CHRTAB_WIN1252[128];
extern word CHRTAB_WIN1253[128];
extern word CHRTAB_WIN1254[128];
extern word CHRTAB_WIN1255[128];
extern word CHRTAB_WIN1256[128];
extern word CHRTAB_WIN1257[128];
extern word CHRTAB_WIN1258[128];
extern word CHRTAB_KOI8_R[128];
extern word CHRTAB_CP852[128];
extern word CHRTAB_MJK[128];



void SetDefaultCharset(byte charset);
byte GetDefaultCharset();

byte ResolveCharset(byte charset);

byte AddCharSet(const char *name, const word *table, byte systemcharset = 0);
byte AddCharSetE(const char *name, word *table, byte systemcharset = 0);

const char *CharsetName(byte charset);
int CharsetCount();
int CharsetByName(const char *name);

byte SystemCharset(byte charset);

int ToUnicode(int chr, byte charset);
int FromUnicode(wchar wchr, byte charset, int defchar = DEFAULTCHAR);

void ToUnicode(wchar *ws, const char *s, int n, byte charset);
void FromUnicode(char *s, const wchar *ws, int n, byte charset, int defchar = DEFAULTCHAR);

void ConvertCharset(char *t, byte tcharset, const char *s, byte scharset, int n);

inline bool IsUtf8Lead(int c)
{
 return (c & 0xc0) != 0x80;
}

String ToUtf8(wchar code);
String ToUtf8(const wchar *s, int len);
String ToUtf8(const wchar *s);
String ToUtf8(const WString& w);

WString FromUtf8(const char *_s, int len);
WString FromUtf8(const char *_s);
WString FromUtf8(const String& s);

bool utf8check(const char *_s, int len);

int utf8len(const char *s, int len);
int utf8len(const char *s);
int lenAsUtf8(const wchar *s, int len);
int lenAsUtf8(const wchar *s);

bool CheckUtf8(const String& src);

WString ToUnicode(const String& src, byte charset);
WString ToUnicode(const char *src, int n, byte charset);
String FromUnicode(const WString& src, byte charset = 0, int defchar = DEFAULTCHAR);

String ToCharset(byte charset, const String& s, byte scharset = 0, int defchar = DEFAULTCHAR);


extern dword uni__info[2048];

inline bool IsLetter(int c) { return (dword)c < 2048 ? uni__info[c] & 0xc0000000 : 0; }
inline bool IsUpper(int c) { return (dword)c < 2048 ? uni__info[c] & 0x40000000 : 0; }
inline bool IsLower(int c) { return (dword)c < 2048 ? uni__info[c] & 0x80000000 : 0; }
inline int ToUpper(int c) { return (dword)c < 2048 ? (uni__info[c] >> 11) & 2047 : c; }
inline int ToLower(int c) { return (dword)c < 2048 ? uni__info[c] & 2047 : c; }
inline int ToAscii(int c) { return (dword)c < 2048 ? (uni__info[c] >> 22) & 0x7f : 0; }
# 138 "C:/upp/uppsrc/Core/CharSet.h"
inline bool IsLetter(char c) { return IsLetter((byte) c); }
inline bool IsUpper(char c) { return IsUpper((byte) c); }
inline bool IsLower(char c) { return IsLower((byte) c); }
inline int ToUpper(char c) { return ToUpper((byte) c); }
inline int ToLower(char c) { return ToLower((byte) c); }
inline int ToAscii(char c) { return ToAscii((byte) c); }

inline bool IsLetter(signed char c) { return IsLetter((byte) c); }
inline bool IsUpper(signed char c) { return IsUpper((byte) c); }
inline bool IsLower(signed char c) { return IsLower((byte) c); }
inline int ToUpper(signed char c) { return ToUpper((byte) c); }
inline int ToLower(signed char c) { return ToLower((byte) c); }
inline int ToAscii(signed char c) { return ToAscii((byte) c); }

inline bool IsLetter(wchar c) { return IsLetter((int) c); }
inline bool IsUpper(wchar c) { return IsUpper((int) c); }
inline bool IsLower(wchar c) { return IsLower((int) c); }
inline int ToUpper(wchar c) { return ToUpper((int) c); }
inline int ToLower(wchar c) { return ToLower((int) c); }
inline int ToAscii(wchar c) { return ToAscii((int) c); }

inline bool IsDigit(int c) { return c >= '0' && c <= '9'; }
inline bool IsAlpha(int c) { return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'; }
inline bool IsAlNum(int c) { return IsDigit(c) || IsAlpha(c); }
inline bool IsLeNum(int c) { return IsDigit(c) || IsLetter(c); }
inline bool IsPunct(int c) { return c != ' ' && !IsAlNum(c); }
inline bool IsSpace(int c) { return c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\v' || c == '\t'; }
inline bool IsXDigit(int c) { return IsDigit(c) || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }

inline bool IsCJKIdeograph(int c) { return c >= 0x2e80 && c <= 0xdfaf || c >= 0xf900 && c <= 0xfaff; }

word UnicodeCombine(word chr, word combine);

void ToUpper(wchar *t, const char *s, int len);
void ToLower(wchar *t, const char *s, int len);
void ToAscii(wchar *t, const char *s, int len);

void ToUpper(wchar *s, int len);
void ToLower(wchar *s, int len);
void ToAscii(wchar *s, int len);

bool IsLetter(int c, byte charset);
bool IsUpper(int c, byte charset);
bool IsLower(int c, byte charset);
int ToUpper(int c, byte charset);
int ToLower(int c, byte charset);
int ToAscii(int c, byte charset);

void ToUpper(char *t, const char *s, int len, byte charset = 0);
void ToLower(char *t, const char *s, int len, byte charset = 0);
void ToAscii(char *t, const char *s, int len, byte charset = 0);

void ToUpper(char *s, int len, byte charset = 0);
void ToLower(char *s, int len, byte charset = 0);
void ToAscii(char *s, int len, byte charset = 0);

WString InitCaps(const wchar *s);
WString ToUpper(const WString& w);
WString ToLower(const WString& w);
WString ToAscii(const WString& w);

String InitCaps(const char *s, byte charset = 0);
String ToUpper(const String& s, byte charset = 0);
String ToLower(const String& s, byte charset = 0);
String ToAscii(const String& s, byte charset = 0);
String ToUpper(const char *s, byte charset = 0);
String ToLower(const char *s, byte charset = 0);
String ToAscii(const char *s, byte charset = 0);
# 366 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/TimeDate.h" 1
class Nuller;
class Stream;
struct FileTime;

struct Date : RelOps< Date, Moveable<Date> > {
 byte day;
 byte month;
 int16 year;

 void Serialize(Stream& s);

 bool IsValid() const;
 void Set(int scalar);
 int Get() const;

 static Date Low() { return Date(-4000, 1, 1); }
 static Date High() { return Date(4000, 1, 1); }

 Date() { year = -32768; day = month = 0; }
 Date(const Nuller&) { year = -32768; day = month = 0; }
 Date(int y, int m, int d) { day = d; month = m; year = y; }
};

inline unsigned GetHashValue(Date t) {
 return 512 * t.year + 32 * t.month + t.day;
}

inline bool operator==(Date a, Date b) {
 return a.day == b.day && a.month == b.month && a.year == b.year;
}

bool operator<(Date a, Date b);

int operator-(Date a, Date b);
Date operator+(Date a, int b);
Date operator+(int a, Date b);
Date operator-(Date a, int b);
Date& operator+=(Date& a, int b);
Date& operator-=(Date& a, int b);

int GetDaysOfMonth(int m, int y);

int DayOfWeek(Date date);
Date LastDayOfMonth(Date d);
Date FirstDayOfMonth(Date d);

Date AddMonths(Date date, int months);
Date AddYears(Date date, int years);

Date GetSysDate();

String DayName(int i, int lang = 0);
String DyName(int i, int lang = 0);
String MonthName(int i, int lang = 0);
String MonName(int i, int lang = 0);

void SetDateFormat(const char *fmt);
void SetDateScan(const char *scan);
void SetDateFilter(const char *seps);

const char *StrToDate(Date& d, const char *s);
String Format(Date date);
int CharFilterDate(int c);

template<>
inline String AsString(const Date& date) { return Format(date); }

struct Time : Date, RelOps< Time, Moveable<Time> > {
 byte hour;
 byte minute;
 byte second;

 void Serialize(Stream& s);

 static Time High() { return Time(4000, 1, 1); }
 static Time Low() { return Time(-4000, 1, 1); }

 void Set(int64 scalar);
 int64 Get();

 Time() { hour = minute = second = 0; }
 Time(const Nuller&) { hour = minute = second = 0; }
 Time(int y, int m, int d, int h = 0, int n = 0, int s = 0)
  { day = d; month = m; year = y; hour = h; minute = n; second = s; }

 Time(FileTime filetime);
 FileTime AsFileTime() const;
};

inline Time ToTime(const Date& d) {
 return Time(d.year, d.month, d.day);
}

inline unsigned GetHashValue(Time t) {
 return t.second +
     32 * (t.minute + 32 * (t.hour + 16 * (t.day + 32 * (t.month + 8 * t.year))));
}

bool operator==(Time a, Time b);
bool operator<(Time a, Time b);

int64 operator-(Time a, Time b);
Time operator+(Time a, int64 seconds);
Time operator+(int64 seconds, Time a);
Time operator-(Time a, int64 secs);
Time& operator+=(Time& a, int64 secs);
Time& operator-=(Time& a, int64 secs);

inline Time operator+(Time a, int i) { return a + int64(i); }
inline Time operator-(Time a, int i) { return a - int64(i); }
inline Time& operator+=(Time& a, int i) { return a += int64(i); }
inline Time& operator-=(Time& a, int i) { return a -= int64(i); }

inline Time operator+(Time a, double i) { return a + int64(i); }
inline Time operator-(Time a, double i) { return a - int64(i); }
inline Time& operator+=(Time& a, double i) { return a += int64(i); }
inline Time& operator-=(Time& a, double i) { return a -= int64(i); }

Time GetSysTime();

String Format(Time time);

template<>
inline String AsString(const Time& time) { return Format(time); }
# 367 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Path.h" 1
bool PatternMatch(const char *p, const char *s);
bool PatternMatchMulti(const char *p, const char *s);

const char *GetFileNamePos(const char *fileName);
const char *GetFileExtPos(const char *fileName);

bool HasFileName(const char *fp);
bool HasFileExt(const char *fp);
bool HasWildcards(const char *fp);
bool IsFullPath(const char *fp);

String GetFileDirectory(const char *fp);
String GetFileFolder(const char *fileName);
String GetFileTitleA(const char *fp);
String GetFileExt(const char *fp);
String GetFileName(const char *fp);

String AppendFileName(const String& path, const char *fp);

bool PathIsEqual(const char *p1, const char *p2);

int ComparePath(const char *a, const char *b, int length);
int ComparePath(String fa, String fb);

inline bool LessPath(String fa, String fb) { return ComparePath(fa, fb) < 0; }

String WinPath(const char *path);
String UnixPath(const char *path);


inline String NativePath(const char *path) { return WinPath(path); }






String AppendExt(const char *fn, const char *ext);
String ForceExt(const char *fn, const char *ext);

String GetFileOnPath(const char *file, const char *paths, bool current = true, const char *curdir = __null);


String GetFullPath(const char *path);
String GetCurrentDirectoryA();


struct FileTime;

int Compare_FileTime(const FileTime& fa, const FileTime& fb);



struct FileTime : FILETIME, CompareRelOps<const FileTime&, &Compare_FileTime> {
 FileTime() {}
 FileTime(const FILETIME& ft) { dwLowDateTime = ft.dwLowDateTime;
                                       dwHighDateTime = ft.dwHighDateTime; }
};

class FindFile : public WIN32_FIND_DATA {
protected:
 HANDLE handle;

public:
 bool Search(const char *name);
 bool Next();
 void Close();

 dword GetAttributes() const { return dwFileAttributes; }
 String GetName() const;
 int64 GetLength() const { return (int64)nFileSizeLow | ((int64)nFileSizeHigh << 32); }
 FileTime GetCreationTime() const { return ftCreationTime; }
 FileTime GetLastAccessTime() const{ return ftLastAccessTime; }
 FileTime GetLastWriteTime() const { return ftLastWriteTime; }


 const char *GetMSDOSName() const { return cAlternateFileName; }


 bool IsDirectory() const { return dwFileAttributes & 0x00000010; }
 bool IsFolder() const;
 bool IsFile() const { return !IsDirectory(); }
 bool IsArchive() const { return dwFileAttributes & 0x00000020; }
 bool IsCompressed() const { return dwFileAttributes & 0x00000800; }
 bool IsHidden() const { return dwFileAttributes & 0x00000002; }
 bool IsReadOnly() const { return dwFileAttributes & 0x00000001; }
 bool IsSystem() const { return dwFileAttributes & 0x00000004; }
 bool IsTemporary() const { return dwFileAttributes & 0x00000100; }

 operator bool() const { return handle != (HANDLE)(-1); }

 FindFile() { handle = (HANDLE)(-1); }
 FindFile(const char *name);
 ~FindFile() { Close(); }
};
# 160 "C:/upp/uppsrc/Core/Path.h"
int64 GetFileLength(const char *name);
bool FileExists(const char *name);
bool IsFolder(String path);

String NormalizePath(const char *path);
String NormalizePath(const char *path, const char *currdir);

bool FileCopy(const char *oldname, const char *newname);
bool FileMove(const char *oldname, const char *newname);
bool FileDelete(const char *filename);

bool DirectoryExists(const char *name);



bool DirectoryCreate(const char *dirname);

bool DirectoryDelete(const char *dirname);
void RealizeDirectory(String dir);
void RealizePath(String file);

struct Time;
Time FileGetTime(const char *filename);
bool SetFileTime(const char *filename, FileTime ft);
bool FileSetTime(const char *filename, Time time);
FileTime TimeToFileTime(Time time);





bool DeleteFolderDeep(const char *dir);


String GetTempPathA();
String GetTempFileNameA(const char *prefix = __null);


template <class T>
class Array;

class FileSystemInfo
{
public:
 enum
 {
  ROOT_UNKNOWN = 0,
  ROOT_NO_ROOT_DIR = 1,
  ROOT_REMOVABLE = 2,
  ROOT_FIXED = 3,
  ROOT_REMOTE = 4,
  ROOT_CDROM = 5,
  ROOT_RAMDISK = 6,
  ROOT_NETWORK = 7,
  ROOT_COMPUTER = 8,
 };

 enum
 {
  STYLE_WIN32 = 0x0001,
  STYLE_POSIX = 0x0002,
 };

 struct FileInfo
 {
  FileInfo();

  operator bool () const { return !IsNull(filename); }

  String filename;
  String msdos_name;
  String root_desc;
  int64 length;
  Time last_access_time;
  Time last_write_time;
  Time creation_time;
  bool read_only;
  bool is_directory;
  bool is_folder;
  bool is_file;
  bool is_symlink;
  bool is_archive;
  bool is_compressed;
  bool is_hidden;
  bool is_read_only;
  bool is_system;
  bool is_temporary;
  char root_style;
 };

 virtual int GetStyle() const;
 bool IsWin32() const { return GetStyle() & STYLE_WIN32; }
 bool IsPosix() const { return GetStyle() & STYLE_POSIX; }

 virtual Array<FileInfo> Find(String mask, int max_count = 1000000) const;
 virtual bool CreateFolder(String path, String& error) const;

 bool FolderExists(String path) const;
};

FileSystemInfo& StdFileSystemInfo();
# 368 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Stream.h" 1




enum {
 STRM_ERROR = 0x20,
 STRM_READ = 0x10,
 STRM_WRITE = 0x08,
 STRM_SEEK = 0x04,
 STRM_LOADING = 0x02,
 STRM_THROW = 0x01,

 ERROR_NOT_ENOUGH_SPACE = -1,
 ERROR_LOADING_FAILED = -2
};

struct StreamError {};
struct LoadingError : StreamError {};

enum BeginIndentEnum { BeginIndent };
enum EndIndentEnum { EndIndent };

class Stream {
protected:
 int64 pos;
 byte *buffer;
 byte *ptr;
 byte *rdlim;
 byte *wrlim;

 unsigned style:6;
 unsigned beginofline:1;
 unsigned depth:9;
 unsigned errorcode:16;

 enum {
  BEGINOFLINE = 0x02,
 };

 virtual void _Put(int w);
 virtual int _Term();
 virtual int _Get();
 virtual void _Put(const void *data, dword size);
 virtual dword _Get(void *data, dword size);

private:
 int _Get8();
 int _Get16();
 int _Get32();
 int64 _Get64();
 bool _IsEof() const;

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual void SetSize(int64 size);
 virtual void Flush();
 virtual void Close();
 virtual bool IsOpen() const = 0;

 Stream();
 virtual ~Stream();

 word GetStyle() const { return style; }

 bool IsError() const { return style & STRM_ERROR; }
 bool IsOK() const { return !IsError(); }
 void SetError(int c = 0) { style |= STRM_ERROR; errorcode = c; }

 void SetLastError() { SetError(GetLastError()); }




 int GetError() const { return errorcode; }
 void ClearError() { style &= ~STRM_ERROR; errorcode = 0; }

 int64 GetPos() const { return dword(ptr - buffer) + pos; }
 bool IsEof() const { return ptr >= rdlim && _IsEof(); }
 int64 GetLeft() const { return GetSize() - GetPos(); }
 void SeekEnd(int64 rel = 0) { Seek(GetSize() + rel); }
 void SeekCur(int64 rel) { Seek(GetPos() + rel); }

 void Put(int c) { if(ptr < wrlim) *ptr++ = c; else _Put(c); }
 int Term() { return ptr < rdlim ? *ptr : _Term(); }
 int Get() { return ptr < rdlim ? *ptr++ : _Get(); }

 void Put(const void *data, dword size) { _Put(data, size); }
 dword Get(void *data, dword size) { return _Get(data, size); }

 void LoadThrowing() { style |= STRM_THROW; }
 void LoadError();

 bool GetAll(void *data, dword size);

 int Get8() { return ptr < rdlim ? *ptr++ : _Get8(); }

 int Get16() { if(ptr >= rdlim - 1) return _Get16(); int q = *(word *)ptr; ptr += 2; return q; }
 int Get32() { if(ptr >= rdlim - 3) return _Get32(); int q = *(dword *)ptr; ptr += 4; return q; }
 int64 Get64() { if(ptr >= rdlim - 7) return _Get64(); int64 q = *(int64 *)ptr; ptr += 8; return q; }







 int Get16le() { return Get16(); }
 int Get32le() { return Get32(); }
 int64 Get64le() { return Get64(); }
 int Get16be();
 int Get32be();
 int64 Get64be();
# 123 "C:/upp/uppsrc/Core/Stream.h"
 int GetUtf8();

 String GetLine();


 void Put16(word q) { if(ptr < wrlim - 1) { *(word *)ptr = q; ptr += 2; } else Put(&q, 2); }
 void Put32(dword q) { if(ptr < wrlim - 3) { *(dword *)ptr = q; ptr += 4; } else Put(&q, 4); }
 void Put64(int64 q) { if(ptr < wrlim - 7) { *(int64 *)ptr = q; ptr += 8; } else Put(&q, 8); }







 void Put16le(word q) { Put(&q, 2); }
 void Put32le(dword q) { Put(&q, 4); }
 void Put64le(int64 q) { Put(&q, 8); }
 void Put16be(word q);
 void Put32be(dword q);
 void Put64be(int64 q);
# 153 "C:/upp/uppsrc/Core/Stream.h"
 void PutUtf8(int c);

 void Put(const char *s);
 void Put(const String& s);
 void Put(int c, int count);
 void Put0(int count) { Put(0, count); }

 void PutCrLf() { Put('\r'); Put('\n'); }

 void PutEol() { PutCrLf(); }




 void PutLine(const char *s);
 void PutLine(const String& s);

 void PutW(const wchar *s, int count) { Put(s, count * 2); }
 dword GetW(wchar *s, int count) { return Get(s, count * 2) / 2; }
 bool GetAllW(wchar *s, int count) { return GetAll(s, count * 2); }

 void Put(Stream& s, int64 size = ((int64)+0x7FFFFFFFFFFFFFFFLL), dword click = 4096);



 void Putf(int c);
 void Putf(const char *s);
 void Putf(const String& s);

 void Begin() { depth++; }
 void End() { depth--; }

 Stream& operator<<(BeginIndentEnum) { Begin(); return *this; }
 Stream& operator<<(EndIndentEnum) { End(); return *this; }


 void SetLoading() { ; style |= STRM_LOADING; }
 void SetStoring() { ; style &= ~STRM_LOADING; }
 bool IsLoading() { return style & STRM_LOADING; }
 bool IsStoring() { return !IsLoading(); }

 void SerializeRaw(byte *data, dword count);
 void SerializeRaw(word *data, dword count);
 void SerializeRaw(dword *data, dword count);
 void SerializeRaw(uint64 *data, dword count);

 void SerializeRLE(byte *data, dword count);

 Stream& operator%(bool& d);
 Stream& operator%(char& d);
 Stream& operator%(signed char& d);
 Stream& operator%(unsigned char& d);
 Stream& operator%(short& d);
 Stream& operator%(unsigned short& d);
 Stream& operator%(int& d);
 Stream& operator%(unsigned int& d);
 Stream& operator%(long& d);
 Stream& operator%(unsigned long& d);
 Stream& operator%(float& d);
 Stream& operator%(double& d);
 Stream& operator%(int64& d);
 Stream& operator%(uint64& d);

 Stream& operator%(String& s);
 Stream& operator/(String& s);

 Stream& operator%(WString& s);
 Stream& operator/(WString& s);

 void Pack(dword& i);
 Stream& operator/(int& i) { dword w = i + 1; Pack(w); i = w - 1; return *this; }
 Stream& operator/(unsigned int& i) { Pack(*(dword *)&i); return *this; }
 Stream& operator/(long& i) { dword w = i + 1; Pack(w); i = w - 1; return *this; }
 Stream& operator/(unsigned long& i) { dword w = i + 1; Pack(w); i = w - 1; return *this; }

 void Magic(dword magic = 0x7d674d7b);

 void Pack(bool& a, bool& b, bool& c, bool& d, bool& e, bool& f, bool& g, bool& h);
 void Pack(bool& a, bool& b, bool& c, bool& d, bool& e, bool& f, bool& g);
 void Pack(bool& a, bool& b, bool& c, bool& d, bool& e, bool& f);
 void Pack(bool& a, bool& b, bool& c, bool& d, bool& e);
 void Pack(bool& a, bool& b, bool& c, bool& d);
 void Pack(bool& a, bool& b, bool& c);
 void Pack(bool& a, bool& b);


 int GetW() { return Get16(); }
 int GetL() { return Get32(); }
 int GetIW() { return Get16le(); }
 int GetIL() { return Get32le(); }
 int GetMW() { return Get16be(); }
 int GetML() { return Get32be(); }
 void PutW(int c) { Put16(c); }
 void PutL(int c) { Put32(c); }
 void PutIW(int c) { Put16le(c); }
 void PutIL(int c) { Put32le(c); }
 void PutMW(int c) { Put16be(c); }
 void PutML(int c) { Put32be(c); }

private:
 Stream(const Stream& s);
 void operator=(const Stream& s);
};

class StringStream : public Stream {
protected:
 virtual void _Put(int w);
 virtual int _Term();
 virtual int _Get();
 virtual void _Put(const void *data, dword size);
 virtual dword _Get(void *data, dword size);

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual void SetSize(int64 size);
 virtual bool IsOpen() const;

protected:
 bool writemode;
 String data;
 StringBuffer wdata;
 dword size;

 void InitReadMode();
 void SetWriteBuffer();
 void SetReadMode();
 void SetWriteMode();

public:
 void Open(const String& data);
 void Create();

 String GetResult();
 operator String() { return GetResult(); }

 StringStream() { Create(); }
 StringStream(const String& data) { Open(data); }
};

class MemStream : public Stream {
protected:
 virtual void _Put(const void *data, dword size);
 virtual dword _Get(void *data, dword size);

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual bool IsOpen() const;

public:
 MemStream(void *data, int size);



};

class MemReadStream : public MemStream {
public:
 MemReadStream(const void *data, int size);
};

class BlockStream : public Stream {
protected:
 virtual void _Put(int w);
 virtual int _Term();
 virtual int _Get();
 virtual void _Put(const void *data, dword size);
 virtual dword _Get(void *data, dword size);

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual void SetSize(int64 size);
 virtual void Flush();

private:
 int pagesize;
 int64 pagemask;
 int64 pagepos;
 bool pagedirty;

 int64 streamsize;

 void SetPos(int64 p);
 void SyncSize();
 bool SyncPage();
 bool SyncPos();
 void ReadData(void *data, int64 at, int size);

protected:
 virtual dword Read(int64 at, void *ptr, dword size);
 virtual void Write(int64 at, const void *data, dword size);
 virtual void SetStreamSize(int64 size);

public:
 enum {
  READ, CREATE, APPEND, READWRITE,

  NOWRITESHARE = 0x10,
  DELETESHARE = 0x20,
  NOREADSHARE = 0x40,
  SHAREMASK = 0x70,
 };


 dword GetBufferSize() const { return pagesize; }
 void SetBufferSize(dword newsize);
 int64 GetStreamSize() const { return streamsize; }

 BlockStream();
 virtual ~BlockStream();

protected:
 void OpenInit(dword mode, int64 file_size);
};

class FileStream : public BlockStream {
protected:
 virtual void SetStreamSize(int64 size);
 virtual dword Read(int64 at, void *ptr, dword size);
 virtual void Write(int64 at, const void *data, dword size);

public:
 virtual void Close();
 virtual bool IsOpen() const;

protected:

 HANDLE handle;





 void SetPos(int64 pos);
 void Init(int64 size);

public:
 operator bool() const { return IsOpen(); }
 FileTime GetTime() const;


 void SetTime(const FileTime& tm);
 bool Open(const char *filename, dword mode);

 FileStream(const char *filename, dword mode);
# 408 "C:/upp/uppsrc/Core/Stream.h"
 FileStream();
 ~FileStream();


 HANDLE GetHandle() const { return handle; }




};

class FileOut : public FileStream {
public:





 bool Open(const char *fn) { return FileStream::Open(fn, FileStream::CREATE); }



 FileOut(const char *fn) { Open(fn); }
 FileOut() {}
};

class FileAppend : public FileStream {
public:
 bool Open(const char *fn) { return FileStream::Open(fn, FileStream::APPEND); }

 FileAppend(const char *fn) { Open(fn); }
 FileAppend() {}
};

class FileIn : public FileStream {
public:
 bool Open(const char *fn) { return FileStream::Open(fn, FileStream::READ); }

 FileIn(const char *fn) { Open(fn); }
 FileIn() {}
};

class SizeStream : public Stream {
protected:
 virtual void _Put(int w);
 virtual void _Put(const void *data, dword size);

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual void SetSize(int64 size);
 virtual bool IsOpen() const;

protected:
 int64 size;
 byte h[128];

public:
 operator int64() const { return GetSize(); }

 void Open() { ptr = buffer; size = 0; }

 SizeStream();
};

class CompareStream : public Stream {
protected:
 virtual void _Put(int w);
 virtual void _Put(const void *data, dword size);

public:
 virtual void Seek(int64 pos);
 virtual int64 GetSize() const;
 virtual void SetSize(int64 size);
 virtual void Close();
 virtual bool IsOpen() const;
 virtual void Flush();

private:
 Stream *stream;
 bool equal;
 int64 size;
 byte h[128];

 void Compare(int64 pos, const void *data, dword size);

public:
 void Open(Stream& aStream);

 bool IsEqual() { Flush(); return equal; }
 operator bool() { Flush(); return equal; }

 CompareStream();
 CompareStream(Stream& aStream);
};

class FileMapping
{
public:
 FileMapping(const char *file = __null, bool delete_share = false, int64 mapoffset = 0, dword maplen = ~0);
 ~FileMapping() { Close(); }

 bool Open(const char *file, bool delete_share = false, int64 mapoffset = 0, dword maplen = ~0);
 bool Create(const char *file, int64 filesize, bool delete_share = false, int64 mapoffset = 0, dword maplen = ~0);
 bool Expand(int64 filesize, int64 mapoffset = 0, dword maplen = ~0);
 bool Map(int64 offset, dword len);
 bool Unmap();
 bool Close();

 bool IsOpen() const { return hfile != (HANDLE)(-1); }

 int64 GetFileSize() const { return filesize; }
 Time GetTime() const;
 String GetData() const { ; return String(base, size); }

 int64 GetOffset() const { return offset; }
 dword GetCount() const { return size; }

 int64 GetRawOffset() const { return rawoffset; }
 dword GetRawCount() const { return rawsize; }

 const byte *operator ~ () const { ; return base; }
 const byte *Begin() const { ; return base; }
 const byte *End() const { ; return base + size; }
 const byte *GetIter(int i) const { ; return base + i; }
 const byte& operator [] (int i) const { ; return base[i]; }

 byte *operator ~ () { ; return base; }
 byte *Begin() { ; return base; }
 byte *End() { ; return base + size; }
 byte *GetIter(int i) { ; return base + i; }
 byte& operator [] (int i) { ; return base[i]; }

private:

 HANDLE hfile;
 HANDLE hmap;






 byte *base;
 byte *rawbase;
 int64 filesize;
 int64 offset;
 int64 rawoffset;
 dword size;
 dword rawsize;
 bool write;
};


String LoadStream(Stream& in);
bool SaveStream(Stream& out, const String& data);

int64 CopyStream(Stream& dest, Stream& src, int64 count);
inline int64 CopyStream(Stream& dest, Stream& src) { return CopyStream(dest, src, src.GetLeft()); }


Stream& Cout();
String ReadStdIn();


Stream& NilStream();

String LoadFile(const char *filename);
bool SaveFile(const char *filename, const String& data);

template <class T>
inline Stream& operator%(Stream& s, T& x)
{
 x.Serialize(s);
 return s;
}

inline Stream& operator<<(Stream& s, const char *x)
{
 s.Putf(x);
 return s;
}

inline Stream& operator<<(Stream& s, char *x)
{
 s.Putf(x);
 return s;
}

inline Stream& operator<<(Stream& s, const String &x)
{
 s.Putf(x);
 return s;
}

inline Stream& operator<<(Stream& s, char x)
{
 s.Putf((int) x);
 return s;
}

inline Stream& operator<<(Stream& s, const void *x)
{
 s << FormatPtr(x);
 return s;
}

inline Stream& operator<<(Stream& s, void *x)
{
 s << FormatPtr(x);
 return s;
}

template <class T>
inline Stream& operator<<(Stream& s, const T& x) {
 s << AsString(x);
 return s;
}



Stream& Pack16(Stream& s, int& i);
Stream& Pack16(Stream& s, int& i1, int& i2);
Stream& Pack16(Stream& s, int& i1, int& i2, int& i3);
Stream& Pack16(Stream& s, int& i1, int& i2, int& i3, int& i4);
Stream& Pack16(Stream& s, int& i1, int& i2, int& i3, int& i4, int& i5);

int StreamHeading(Stream& stream, int ver, int minver, int maxver, const char* tag);
# 369 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Diag.h" 1
class LogStream : public Stream {

 HANDLE hfile;






 CriticalSection cs;
 char filename[512];
 char backup[512];
 byte buffer[512];
 int filesize;
 byte *p;

 int sizelimit;
 int part;

 void Flush();
 void Put0(int w);

protected:
 virtual void _Put(int w);
 virtual void _Put(const void *data, dword size);
 virtual int64 GetSize() const { return filesize; }

public:
 virtual bool IsOpen() const;
 void Create(const char *path, bool append);
 void SetLimit(int maxsize) { sizelimit = maxsize; }

 bool Delete();
 void Close();

 LogStream();
 ~LogStream();
};

void ActivateUsrLog();
void ActivatePersistentUsrLog();
bool IsUsrLog();
Stream& UsrLog();
Stream& UsrLog(const char *line);
Stream& UsrLogT(const char *line);
Stream& UsrLogT(int indent, const char *line);
void DeleteUsrLog();

Stream& BugLog();

Stream& StdLog();

Stream& VppLog();
void SetVppLog(Stream& log);
void SetVppLogName(const String& file);
void SetVppLogSizeLimit(int filesize);
void SetVppLogNoDeleteOnStartup();

void HexDump(Stream& s, const void *ptr, int size, int maxsize = 2147483647);

int msecs(int from = 0);

String GetTypeName(const char *type_name);
inline String GetTypeName(const ::std::type_info& tinfo) { return GetTypeName(tinfo.name()); }

void __LOGF__(const char *format, ...);
# 111 "C:/upp/uppsrc/Core/Diag.h"
inline void LOGF(const char *format, ...) {}
# 137 "C:/upp/uppsrc/Core/Diag.h"
struct DebugLogBlock
{
 DebugLogBlock(const char *name) : name(name) { VppLog() << name << "\n" << BeginIndent; }
 ~DebugLogBlock() { VppLog() << EndIndent << "//" << name << "\n"; }
 const char *name;
};
# 156 "C:/upp/uppsrc/Core/Diag.h"
void InstallCrashDump(const char *app_info = __null);



template <class T>
void DumpContainer(Stream& s, T ptr, T end) {
 int i = 0;
 s.Begin();
 while(ptr != end)
  s << '[' << i++ << "] = " << *ptr++ << '\n';
 s.End();
}

template <class C>
void DumpContainer(Stream& s, const C& c) {
 DumpContainer(s, c.Begin(), c.End());
}

template <class T>
void DumpContainer2(Stream& s, T ptr, T end) {
 int i = 0;
 s.Begin();
 while(ptr != end) {
  s << '[' << i++ << "] =\n";
  DumpContainer(s, (*ptr).Begin(), (*ptr).End());
  ptr++;
 }
 s.End();
}

template <class C>
void DumpContainer2(Stream& s, const C& c) {
 DumpContainer2(s, c.Begin(), c.End());
}

template <class T>
void DumpContainer3(Stream& s, T ptr, T end) {
 int i = 0;
 s.Begin();
 while(ptr != end) {
  s << '[' << i++ << "] =\n";
  DumpContainer2(s, (*ptr).Begin(), (*ptr).End());
  ptr++;
 }
 s.End();
}

template <class C>
void DumpContainer3(Stream& s, const C& c) {
 DumpContainer3(s, c.Begin(), c.End());
}
# 370 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Vcont.h" 1
template <class T>
class Vector : public MoveableAndDeepCopyOption< Vector<T> > {
 T *vector;
 int items;
 int alloc;

 static void RawFree(T *ptr) { if(ptr) delete (byte *) ptr; }
 static T *RawAlloc(int n) { return (T *) new byte[n * sizeof(T)]; }
 static Vector& SetPicked(const Vector& v) { Vector& p = (Vector&)(v); p.items = -1; p.vector = __null; return p; }

 void Pick(const Vector<T>& v);

 T *Rdd() { return vector + items++; }

 void Free();
 void __DeepCopy(const Vector& src);
 T& Get(int i) const { ; return vector[i]; }
 void Chk() const { ; }
 void ReAlloc(int alloc);
 void ReAllocF(int alloc);
 void Grow();
 void GrowF();
 void GrowAdd(const T& x);
 void GrowAddPick(const T& x);
 void RawInsert(int q, int count);

public:
 T& Add() { Chk(); if(items >= alloc) GrowF(); return *(::new(vector + items++) T); }
 void Add(const T& x) { Chk(); if(items < alloc) DeepCopyConstruct(Rdd(), x); else GrowAdd(x); }
 void AddPick(const T& x) { Chk(); if(items < alloc) ::new(Rdd()) T(x); else GrowAddPick(x); }
 void AddN(int n);
 const T& operator[](int i) const { return Get(i); }
 T& operator[](int i) { return Get(i); }
 int GetCount() const { Chk(); return items; }
 bool IsEmpty() const { Chk(); return items == 0; }
 void Trim(int n);
 void SetCount(int n);
 void SetCount(int n, const T& init);
 void SetCountR(int n);
 void SetCountR(int n, const T& init);
 void Clear();

 T& At(int i) { if(i >= items) SetCountR(i + 1); return (*this)[i]; }
 T& At(int i, const T& x) { if(i >= items) SetCountR(i + 1, x); return (*this)[i]; }

 void Shrink() { if(items != alloc) ReAllocF(items); }
 void Reserve(int n);
 int GetAlloc() const { return alloc; }

 void Set(int i, const T& x, int count = 1);
 void Remove(int i, int count = 1);
 void Remove(const int *sorted_list, int n);
 void Remove(const Vector<int>& sorted_list);
 void InsertN(int i, int count = 1);
 T& Insert(int i) { InsertN(i); return Get(i); }
 void Insert(int i, const T& x, int count = 1);
 void Insert(int i, const Vector& x);
 void Insert(int i, const Vector& x, int offset, int count);
 void InsertPick(int i, const Vector& x);
 void Append(const Vector& x) { Insert(GetCount(), x); }
 void Append(const Vector& x, int o, int c) { Insert(GetCount(), x, o, c); }
 void AppendPick(const Vector& x) { InsertPick(GetCount(), x); }
 int GetIndex(const T& item) const;

 void Drop(int n = 1) { ; Trim(items - n); }
 T& Top() { ; return Get(items - 1); }
 const T& Top() const { ; return Get(items - 1); }
 T Pop() { T h = Top(); Drop(); return h; }

 operator T*() { return (T*)vector; }
 operator const T*() const { return (T*)vector; }

 Vector& operator<<(const T& x) { Add(x); return *this; }
 Vector& operator|(const T& x) { AddPick(x); return *this; }


 void Serialize(Stream& s) { StreamContainer(s, *this); }


 Vector() { vector = __null; items = alloc = 0; }
 ~Vector() {
  Free();
  return;
  T t(*vector);
  AssertMoveable(&t);
 }


 Vector(const Vector& v) { Pick(v); }
 void operator=(const Vector& v) { Free(); Pick(v); }
 bool IsPicked() const { return items < 0; }


 Vector(const Vector& v, int) { __DeepCopy(v); }


 typedef T ValueType;
 typedef T *Iterator;
 typedef const T *ConstIterator;

 ConstIterator Begin() const { return (T*)vector; }
 ConstIterator End() const { return (T*)vector + items; }
 ConstIterator GetIter(int i) const { ; return Begin() + i; }
 Iterator Begin() { return (T*)vector; }
 Iterator End() { return (T*)vector + items; }
 Iterator GetIter(int i) { ; return Begin() + i; }


 friend void Swap(Vector& a, Vector& b) { Upp::Swap(a.items, b.items); Upp::Swap(a.alloc, b.alloc); Upp::Swap(a.vector, b.vector); }
 friend void Append(Vector& dst, const Vector& src) { dst.Append(src); }


 T& DoIndex(int i) { return At(i); }
 T& DoIndex(int i, const T& x) { return At(i, x); }

 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return Begin(); } const_iterator end() const { return End(); } void clear() { Clear(); } size_type size() { return GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return Begin(); } iterator end() { return End(); } reference front() { return (*this)[0]; } const_reference front() const { return (*this)[0]; } reference back() { return Top(); } const_reference back() const { return Top(); } void push_back(const T& x) { Add(x); } void pop_back() { Drop(); }
};

template <class T>
class Array : public MoveableAndDeepCopyOption< Array<T> > {
protected:
 Vector<void *> vector;

 void Free();
 void __DeepCopy(const Array& v);
 T& Get(int i) const { return *(T *)vector[i]; }
 void Del(void **ptr, void **lim) { while(ptr < lim) delete (T *) *ptr++; }
 void Init(void **ptr, void **lim) { while(ptr < lim) *ptr++ = new T; }
 void Init(void **ptr, void **lim, const T& x) { while(ptr < lim) *ptr++ = DeepCopyNew(x); }

public:
 T& Add() { T *q = new T; vector.Add(q); return *q; }
 void Add(const T& x) { vector.Add(DeepCopyNew(x)); }
 void AddPick(const T& x) { vector.Add(new T(x)); }
 T& Add(T *newt) { vector.Add(newt); return *newt; }
 template<class TT> TT& Create() { TT *q = new TT; Add(q); return *q; }
 const T& operator[](int i) const { return Get(i); }
 T& operator[](int i) { return Get(i); }
 int GetCount() const { return vector.GetCount(); }
 bool IsEmpty() const { return vector.IsEmpty(); }
 void Trim(int n);
 void SetCount(int n);
 void SetCount(int n, const T& init);
 void SetCountR(int n);
 void SetCountR(int n, const T& init);
 void Clear() { Free(); vector.Clear(); }

 T& At(int i) { if(i >= GetCount()) SetCountR(i + 1); return Get(i); }
 T& At(int i, const T& x) { if(i >= GetCount()) SetCountR(i + 1, x); return Get(i); }

 void Shrink() { vector.Shrink(); }
 void Reserve(int xtra) { vector.Reserve(xtra); }
 int GetAlloc() const { return vector.GetAlloc(); }

 void Set(int i, const T& x, int count = 1);
 void Remove(int i, int count = 1);
 void Remove(const int *sorted_list, int n);
 void Remove(const Vector<int>& sorted_list);
 void InsertN(int i, int count = 1);
 T& Insert(int i) { InsertN(i); return Get(i); }
 void Insert(int i, const T& x, int count = 1);
 void Insert(int i, const Array& x);
 void Insert(int i, const Array& x, int offset, int count);
 void Append(const Array& x) { Insert(GetCount(), x); }
 void Append(const Array& x, int o, int c) { Insert(GetCount(), x, o, c); }
 void InsertPick(int i, const Array& x) { vector.InsertPick(i, x.vector); }
 void AppendPick(const Array& x) { Insert(GetCount(), x); }
 int GetIndex(const T& item) const;
 void Swap(int i1, int i2) { Upp::Swap(vector[i1], vector[i2]); }
 void Move(int i1, int i2);

 T *Detach(int i) { T *t = &Get(i); vector.Remove(i); return t; }
 T& Set(int i, T *newt) { delete (T *)vector[i]; vector[i] = newt; return *newt; }
 void Insert(int i, T *newt);

 void Drop(int n = 1) { Trim(GetCount() - n); }
 T& Top() { return Get(GetCount() - 1); }
 const T& Top() const { return Get(GetCount() - 1); }

 T *PopDetach() { return (T *) vector.Pop(); }

 void Swap(Array& b) { Swap(vector, b.vector); }

 Array& operator<<(const T& x) { Add(x); return *this; }
 Array& operator<<(T *newt) { Add(newt); return *this; }
 Array& operator|(const T& x) { AddPick(x); return *this; }

 bool IsPicked() const { return vector.IsPicked(); }


 void Serialize(Stream& s) { StreamContainer(s, *this); }


 Array() {}
 ~Array() { Free(); }


 Array(const Array& v) : vector(v.vector) {}
 void operator=(const Array& v) { Free(); vector = v.vector; }


 Array(const Array& v, int) { __DeepCopy(v); }

 class Iterator;

 class ConstIterator {
 protected:
  T **ptr;
  ConstIterator(T **p) { ptr = p; }

  friend class Array<T>;
  struct NP { int dummy; };

 public:
  const T& operator*() const { return **ptr; }
  const T *operator->() const { return *ptr; }
  const T& operator[](int i) const { return *ptr[i]; }

  ConstIterator& operator++() { ptr++; return *this; }
  ConstIterator& operator--() { ptr--; return *this; }
  ConstIterator operator++(int) { ConstIterator t = *this; ++*this; return t; }
  ConstIterator operator--(int) { ConstIterator t = *this; --*this; return t; }

  ConstIterator& operator+=(int i) { ptr += i; return *this; }
  ConstIterator& operator-=(int i) { ptr -= i; return *this; }

  ConstIterator operator+(int i) const { return ptr + i; }
  ConstIterator operator-(int i) const { return ptr - i; }

  int operator-(ConstIterator x) const { return ptr - x.ptr; }

  bool operator==(ConstIterator x) const { return ptr == x.ptr; }
  bool operator!=(ConstIterator x) const { return ptr != x.ptr; }
  bool operator<(ConstIterator x) const { return ptr < x.ptr; }
  bool operator>(ConstIterator x) const { return ptr > x.ptr; }
  bool operator<=(ConstIterator x) const { return ptr <= x.ptr; }
  bool operator>=(ConstIterator x) const { return ptr >= x.ptr; }

  operator bool() const { return ptr; }

  ConstIterator() {}
  ConstIterator(NP *null) { ; ptr = __null; }
 };

 class Iterator : public ConstIterator {
  friend class Array<T>;
  Iterator(T **p) : ConstIterator(p) {}
  typedef ConstIterator B;
  struct NP { int dummy; };

 public:
  T& operator*() { return **B::ptr; }
  T *operator->() { return *B::ptr; }
  T& operator[](int i) { return *B::ptr[i]; }

  const T& operator*() const { return **B::ptr; }
  const T *operator->() const { return *B::ptr; }
  const T& operator[](int i) const { return *B::ptr[i]; }

  Iterator& operator++() { B::ptr++; return *this; }
  Iterator& operator--() { B::ptr--; return *this; }
  Iterator operator++(int) { Iterator t = *this; ++*this; return t; }
  Iterator operator--(int) { Iterator t = *this; --*this; return t; }

  Iterator& operator+=(int i) { B::ptr += i; return *this; }
  Iterator& operator-=(int i) { B::ptr -= i; return *this; }

  Iterator operator+(int i) const { return B::ptr + i; }
  Iterator operator-(int i) const { return B::ptr - i; }

  int operator-(Iterator x) const { return B::operator-(x); }

  Iterator() {}
  Iterator(NP *null) : ConstIterator(null) {}



 };


 typedef T ValueType;
 Iterator Begin() { return (T **)vector.Begin(); }
 Iterator End() { return (T **)vector.End(); }
 Iterator GetIter(int pos) { return (T **)vector.GetIter(pos); }
 ConstIterator Begin() const { return (T **)vector.Begin(); }
 ConstIterator End() const { return (T **)vector.End(); }
 ConstIterator GetIter(int pos) const { return (T **)vector.GetIter(pos); }


 friend void Swap(Array& a, Array& b) { Upp::Swap(a.vector, b.vector); }

private:
 static void IterSwap0(Iterator a, Iterator b) { Upp::Swap(*a.ptr, *b.ptr); }
public:
 friend void IterSwap(Iterator a, Iterator b) { Array<T>::IterSwap0(a, b); }


 T& DoIndex(int i) { return At(i); }
 T& DoIndex(int i, const T& x) { return At(i, x); }

 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return Begin(); } const_iterator end() const { return End(); } void clear() { Clear(); } size_type size() { return GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return Begin(); } iterator end() { return End(); } reference front() { return (*this)[0]; } const_reference front() const { return (*this)[0]; } reference back() { return Top(); } const_reference back() const { return Top(); } void push_back(const T& x) { Add(x); } void pop_back() { Drop(); }
};

template<class T, int NBLK = 16>
class Segtor : public MoveableAndDeepCopyOption< Segtor<T, NBLK> > {
protected:
 struct Block {
  byte item[NBLK][sizeof(T)];
 };

 Array<Block> block;
 int items;

 void DoRange(unsigned beg, unsigned end, void (*fn)(T*, const T*));
 void Fill(unsigned beg, unsigned end, const T& x);
 T& Get(int i) const {
  ;
  return *(T*) block[unsigned(i) / NBLK].item[unsigned(i) % NBLK];
 }
 void *Add0() {
  int blk = unsigned(items) / NBLK, ndx = unsigned(items) % NBLK;
  if(ndx == 0) block.Add(); items++;
  return block[blk].item[ndx];
 }
 void Del(int n) { if(n < items) DoRange(n, items, DestroyArray); }
 void Init(int n) { if(n > items) DoRange(items, n, ConstructArray); items = n; }
 void Init(int n, const T& x) { if(n > items) Fill(items, n, x); items = n; }
 void Free();

public:
 T& Add() { return *::new(Add0()) T; }
 void Add(const T& x) { DeepCopyConstruct(Add0(), x); }
 void AddPick(const T& x) { ::new(Add0()) T; }
 T& operator[](int i) { return Get(i); }
 const T& operator[](int i) const { return Get(i); }
 int GetCount() const { return items; }
 bool IsEmpty() const { return items == 0; }
 void SetCount(int n);
 void SetCount(int n, const T& init);
 void Clear();
 T& At(int i) { if(i >= items) SetCount(i + 1); return Get(i); }
 T& At(int i, const T& x) { if(i >= items) SetCount(i + 1, x); return Get(i); }
 void Shrink() { block.Shrink(); }
 void Reserve(int xtra) { block.Reserve((xtra + NBLK - 1) / NBLK); }
 int GetAlloc() const { return block.GetAlloc() * NBLK; }

 void Set(int i, const T& x, int count = 1);
 int GetIndex(const T& item) const;

 void Drop(int n = 1) { ; SetCount(GetCount() - n); }
 T& Top() { ; return Get(GetCount() - 1); }
 const T& Top() const { ; return Get(GetCount() - 1); }
 T Pop() { T h = Top(); Drop(); return h; }

 void Swap(Segtor& b) { block.Swap(b.block); Swap(items, b.items); }

 Segtor& operator<<(const T& x) { Add(x); return *this; }
 Segtor& operator|(const T& x) { AddPick(x); return *this; }

 bool IsPicked() const { return block.IsPicked(); }


 void Serialize(Stream& s) { StreamContainer(s, *this); }


 Segtor() { items = 0; }
 Segtor(const Segtor& s) : block(s.block), items(s.items) {}
 Segtor(const Segtor& s, int);
 ~Segtor();


 typedef ConstIIterator<Segtor> ConstIterator;
 typedef IIterator<Segtor> Iterator;


 typedef T ValueType;
 ConstIterator Begin() const { return ConstIterator(*this, 0); }
 ConstIterator End() const { return ConstIterator(*this, items); }
 ConstIterator GetIter(int pos) const { return ConstIterator(*this, pos); }
 Iterator Begin() { return Iterator(*this, 0); }
 Iterator End() { return Iterator(*this, items); }
 Iterator GetIter(int pos) { return Iterator(*this, pos); }


 friend void Swap(Segtor& a, Segtor& b) { a.Swap(b); }


 T& DoIndex(int i) { return At(i); }
 T& DoIndex(int i, const T& x) { return At(i, x); }


 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return Begin(); } const_iterator end() const { return End(); } void clear() { Clear(); } size_type size() { return GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return Begin(); } iterator end() { return End(); } reference front() { return (*this)[0]; } const_reference front() const { return (*this)[0]; } reference back() { return Top(); } const_reference back() const { return Top(); } void push_back(const T& x) { Add(x); } void pop_back() { Drop(); }
};
# 372 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/BiCont.h" 1
template <class T>
class BiVector : MoveableAndDeepCopyOption< BiVector<T> > {
protected:
 T *vector;
 int start;
 mutable int items;
 int alloc;

 int EI() const { return (start + items - 1) % alloc; }
 void ReAlloc(int newalloc);
 void Add0();
 void DeepCopy0(const BiVector& src);
 T *AddHead0() { AssertMoveable<T>(); Add0(); return &vector[start = (start + alloc - 1) % alloc]; }
 T *AddTail0() { AssertMoveable<T>(); Add0(); return &vector[EI()]; }
 void Free();
 void Pick(const BiVector& x) { vector = x.vector; start = x.start; items = x.items;
                                    alloc = x.alloc; x.items = -1; }
 void Copy(T *dst, int start, int count) const;

public:
 int GetCount() const { return items; }
 bool IsEmpty() const { return items == 0; }
 void Clear();

 T& AddHead() { return *new(AddHead0()) T; }
 T& AddTail() { return *new(AddTail0()) T; }
 void AddHead(const T& x) { new(AddHead0()) T(x); }
 void AddTail(const T& x) { new(AddTail0()) T(x); }
 void AddHeadPick(const T& x) { new(AddHead0()) T(x); }
 void AddTailPick(const T& x) { new(AddTail0()) T(x); }
 T& Head() { ; return vector[start]; }
 T& Tail() { ; return vector[EI()]; }
 const T& Head() const { ; return vector[start]; }
 const T& Tail() const { ; return vector[EI()]; }
 void DropHead() { (&Head())->T::~T(); items--; start = (start + 1) % alloc; }
 void DropTail() { (&Tail())->T::~T(); items--; }

 T& operator[](int i) { ;
                                    return vector[(start + i) % alloc]; }
 const T& operator[](int i) const { ;
                                    return vector[(start + i) % alloc]; }
 void Shrink();
 void Reserve(int n);
 int GetAlloc() const { return alloc; }


 void Serialize(Stream& s);


 bool IsPicked() { return items < 0; }

 BiVector(const BiVector& src, int) { DeepCopy0(src); }
 BiVector(const BiVector& src) { Pick(src); }
 void operator=(const BiVector& src) { Free(); Pick(src); }
 BiVector() { start = items = alloc = 0; vector = __null; }
 ~BiVector() { Free(); }

 typedef ConstIIterator<BiVector> ConstIterator;
 typedef IIterator<BiVector> Iterator;

 typedef T ValueType;

 ConstIterator Begin() const { return ConstIterator(*this, 0); }
 ConstIterator End() const { return ConstIterator(*this, GetCount()); }
 ConstIterator GetIter(int pos) const { return ConstIterator(*this, pos); }
 Iterator Begin() { return Iterator(*this, 0); }
 Iterator End() { return Iterator(*this, GetCount()); }
 Iterator GetIter(int pos) { return Iterator(*this, pos); }

 friend void Swap(BiVector& a, BiVector& b) { Upp::Swap(a.vector, b.vector);
                                               Upp::Swap(a.start, b.start);
                                               Upp::Swap(a.items, b.items);
                                               Upp::Swap(a.alloc, b.alloc); }

 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return Begin(); } const_iterator end() const { return End(); } void clear() { Clear(); } size_type size() { return GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return Begin(); } iterator end() { return End(); }
};

template <class T>
class BiArray : MoveableAndDeepCopyOption< BiArray<T> > {
protected:
 BiVector<void *> bv;

 void Free();
 void DeepCopy0(const BiArray<T>& v);

public:
 int GetCount() const { return bv.GetCount(); }
 bool IsEmpty() const { return GetCount() == 0; }
 void Clear() { Free(); bv.Clear(); }

 T& AddHead() { T *q = new T; bv.AddHead(q); return *q; }
 T& AddTail() { T *q = new T; bv.AddTail(q); return *q; }
 void AddHead(const T& x) { bv.AddHead(new T(x)); }
 void AddTail(const T& x) { bv.AddTail(new T(x)); }
 void AddHeadPick(const T& x) { bv.AddHead(new T(x)); }
 void AddTailPick(const T& x) { bv.AddTail(new T(x)); }
 T& AddHead(T *newt) { bv.AddHead(newt); return *newt; }
 T& AddTail(T *newt) { bv.AddTail(newt); return *newt; }
 template <class TT> TT& CreateHead() { TT *q = new TT; bv.AddHead(q); return *q; }
 template <class TT> TT& CreateTail() { TT *q = new TT; bv.AddTail(q); return *q; }
 T& Head() { return *(T *) bv.Head(); }
 T& Tail() { return *(T *) bv.Tail(); }
 const T& Head() const { return *(const T *) bv.Head(); }
 const T& Tail() const { return *(const T *) bv.Tail(); }
 void DropHead() { delete (T*) bv.Head(); bv.DropHead(); }
 void DropTail() { delete (T*) bv.Tail(); bv.DropTail(); }
 T *DetachHead() { T *q = (T*) bv.Head(); bv.DropHead(); return q; }
 T *DetachTail() { T *q = (T*) bv.Tail(); bv.DropTail(); return q; }

 T& operator[](int i) { return *(T *) bv[i]; }
 const T& operator[](int i) const { return *(const T *) bv[i]; }

 void Shrink() { bv.Shrink(); }
 void Reserve(int n) { bv.Reserve(n); }
 int GetAlloc() const { return bv.GetAlloc(); }


 void Serialize(Stream& s);


 bool IsPicked() const { return bv.IsPicked(); }

 BiArray(const BiArray& v, int) { DeepCopy0(v); }

 BiArray(const BiArray& src) : bv(src.bv) {}
 void operator=(const BiArray& src) { Free(); bv = src.bv; }
 BiArray() {}
 ~BiArray() { Free(); }

 typedef ConstIIterator<BiArray> ConstIterator;
 typedef IIterator<BiArray> Iterator;

 typedef T ValueType;

 ConstIterator Begin() const { return ConstIterator(*this, 0); }
 ConstIterator End() const { return ConstIterator(*this, GetCount()); }
 ConstIterator GetIter(int pos) const { return ConstIterator(*this, pos); }
 Iterator Begin() { return Iterator(*this, 0); }
 Iterator End() { return Iterator(*this, GetCount()); }
 Iterator GetIter(int pos) { return Iterator(*this, pos); }

 friend void Swap(BiArray& a, BiArray& b) { Upp::Swap(a.bv, b.bv); }

 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return Begin(); } const_iterator end() const { return End(); } void clear() { Clear(); } size_type size() { return GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return Begin(); } iterator end() { return End(); }
};
# 373 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Index.h" 1
enum { UNSIGNED_HIBIT = 0x80000000 };

class HashBase : Moveable<HashBase> {
 struct Link : Moveable<Link> {
  int next;
  int prev;
 };
 Vector<unsigned> hash;
 mutable Vector<Link> link;
 mutable int *map;
 mutable int mcount;
 mutable int unlinked;

 void LinkBefore(int i, Link& l, int bi) const;
 void LinkTo(int i, Link& l, int& m) const;
 void Unlink(int i, Link& l, int& mi);
 void Unlink(int i, Link& l);
 int& Maph(unsigned _hash) const;
 int& Mapi(int i) const;
 void FinishIndex() const;
 void DoIndex() const;
 void Free() const;

public:
 void ClearIndex() const;
 void Reindex(int n) const;
 void Reindex() const;

 void Add(unsigned hash);
 void Set(int i, unsigned hash);
 void SetUn(int i, unsigned hash);
 unsigned operator [] (int i) const { return hash[i]; }
 int Find(unsigned hash) const;
 int FindNext(int i) const;
 int FindLast(unsigned hash) const;
 int FindPrev(int i) const;
 int Put(unsigned hash);

 bool IsUnlinked(int i) const { return hash[i] & UNSIGNED_HIBIT; }
 void Unlink(int i);
 Vector<int> GetUnlinked() const;

 void Remove(int i);
 void Remove(const int *sorted_list, int count);
 void Insert(int i, unsigned hash);

 int GetCount() const { return hash.GetCount(); }
 void Trim(int count);
 void Drop(int n);
 void Clear() { hash.Clear(); ClearIndex(); }

 void Reserve(int n);
 void Shrink();


 void Serialize(Stream& s);


 HashBase();
 ~HashBase();

 HashBase(const HashBase& b);
 void operator=(const HashBase& b);
 HashBase(const HashBase& b, int);
 void operator<<=(const HashBase& b);

 bool IsPicked() const { return hash.IsPicked(); }

 const unsigned *Begin() const { return hash.Begin(); }
 const unsigned *End() const { return hash.End(); }

 void Swap(HashBase& b);
};

template <class T>
struct StdHash {
 unsigned operator()(const T& x) const { return GetHashValue(x); }
};

struct PtrHash {
 unsigned operator()(const void *x) const { return GetHashValue((intptr_t)x); }
};

template <class T, class V, class HashFn>
class AIndex {
protected:
 V key;
 HashBase hash;

 int Find0(const T& x, int i) const {
  while(i >= 0 && !(x == key[i])) i = hash.FindNext(i);
  return i;
 }
 int FindB(const T& x, int i) const {
  while(i >= 0 && !(x == key[i])) i = hash.FindPrev(i);
  return i;
 }
 void Hash();

public:
 HashFn hashfn;

 void Add(const T& x, unsigned _hash);
 void Add(const T& x);
 int FindAdd(const T& key, unsigned _hash);
 int FindAdd(const T& key);
 AIndex& operator<<(const T& x) { Add(x); return *this; }

 int Put(const T& x, unsigned _hash);
 int Put(const T& x);
 int FindPut(const T& key, unsigned _hash);
 int FindPut(const T& key);

 int Find(const T& x, unsigned _hash) const;
 int Find(const T& x) const;
 int FindNext(int i) const;
 int FindLast(const T& x, unsigned _hash) const;
 int FindLast(const T& x) const;
 int FindPrev(int i) const;

 void Set(int i, const T& x, unsigned _hash);
 void Set(int i, const T& x);

 const T& operator[](int i) const { return key[i]; }
 int GetCount() const { return key.GetCount(); }
 bool IsEmpty() const { return key.IsEmpty(); }

 void Clear() { hash.Clear(); key.Clear(); }

 void ClearIndex() const { hash.ClearIndex(); }
 void Reindex(int n) const { hash.Reindex(n); }
 void Reindex() const { hash.Reindex(); }

 void Unlink(int i) { hash.Unlink(i); }
 int UnlinkKey(const T& k, unsigned h);
 int UnlinkKey(const T& k);
 bool IsUnlinked(int i) const { return hash.IsUnlinked(i); }
 Vector<int> GetUnlinked() const { return hash.GetUnlinked(); }
 void Sweep();

 void Insert(int i, const T& k, unsigned h);
 void Insert(int i, const T& k);
 void Remove(int i);
 void Remove(const int *sorted_list, int count);
 void Remove(const Vector<int>& sorted_list);
 int RemoveKey(const T& k, unsigned h);
 int RemoveKey(const T& k);

 void Trim(int n) { key.SetCount(n); hash.Trim(n); }
 void Drop(int n = 1) { key.Drop(n); hash.Drop(n); }
 const T& Top() const { return key.Top(); }

 void Reserve(int n) { key.Reserve(n); hash.Reserve(n); }
 void Shrink() { key.Shrink(); hash.Shrink(); }
 int GetAlloc() const { return key.GetAlloc(); }


 void Serialize(Stream& s);


 V PickKeys() const { return key; }
 const V& GetKeys() const { return key; }



 AIndex& operator=(const V& s);
 AIndex& operator<<=(const V& s);


 typedef T ValueType;
 typedef typename V::ConstIterator ConstIterator;
 ConstIterator Begin() const { return key.Begin(); }
 ConstIterator End() const { return key.End(); }
 ConstIterator GetIter(int pos) const { return key.GetIter(pos); }

 void Swap(AIndex& b) { Upp::Swap(hash, b.hash);
                                                         Upp::Swap(key, b.key); }

 friend int GetCount(const AIndex& v) { return v.GetCount(); }

protected:
 AIndex(const V& s);
 AIndex(const V& s, int);
 AIndex() {}
 AIndex(const AIndex& s, int);
};

template <class T, class HashFn = StdHash<T> >
class Index : MoveableAndDeepCopyOption< Index<T, HashFn > >,
              public AIndex<T, Vector<T>, HashFn> {
 typedef AIndex< T, Vector<T>, HashFn > B;
public:
 T Pop() { T x = B::Top(); B::Drop(); return x; }

 Index() {}
 Index(const Index& s) : B(s) {}
 Index(const Index& s, int) : B(s, 1) {}
 Index(const Vector<T>& s) : B(s) {}
 Index(const Vector<T>& s, int) : B(s, 1) {}

 Index& operator=(const Vector<T>& x) { B::operator=(x); return *this; }

 friend void Swap(Index& a, Index& b) { a.B::Swap(b); }

 typedef typename B::ConstIterator ConstIterator;
 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return B::Begin(); } const_iterator end() const { return B::End(); } void clear() { B::Clear(); } size_type size() { return B::GetCount(); }
};

template <class T, class HashFn = StdHash<T> >
class ArrayIndex : MoveableAndDeepCopyOption< ArrayIndex<T, HashFn > >,
                   public AIndex<T, Array<T>, HashFn> {
 typedef AIndex< T, Array<T>, HashFn > B;
public:
 void Add(const T& x, unsigned _hash) { B::Add(x, _hash); }
 void Add(const T& x) { B::Add(x); }
 void Set(int i, const T& x, unsigned _hash) { B::Set(i, x, _hash); }
 void Set(int i, const T& x) { B::Set(i, x); }

 void Add(T *newt, unsigned _hash);
 void Add(T *newt);
 void Set(int i, T *newt, unsigned _hash);
 void Set(int i, T *newt);

 ArrayIndex() {}
 ArrayIndex(const ArrayIndex& s) : B(s) {}
 ArrayIndex(const ArrayIndex& s, int) : B(s, 1) {}
 ArrayIndex(const Array<T>& s) : B(s) {}
 ArrayIndex(const Array<T>& s, int) : B(s, 1) {}

 ArrayIndex& operator=(const Array<T>& x) { B::operator=(x); return *this; }

 friend void Swap(ArrayIndex& a, ArrayIndex& b) { a.B::Swap(b); }

 typedef typename B::ConstIterator ConstIterator;
 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return B::Begin(); } const_iterator end() const { return B::End(); } void clear() { B::Clear(); } size_type size() { return B::GetCount(); }
};
# 374 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Map.h" 1
template <class K, class T, class V, class HashFn>
class AMap {
protected:
 Index<K, HashFn> key;
 V value;

public:
 void Add(const K& k, const T& x) { key.Add(k); value.Add(x); }
 void AddPick(const K& k, const T& x) { key.Add(k); value.AddPick(x); }
 T& Add(const K& k) { key.Add(k); return value.Add(); }

 int Find(const K& k, unsigned h) const { return key.Find(k, h); }
 int Find(const K& k) const { return key.Find(k); }
 int FindNext(int i) const { return key.FindNext(i); }
 int FindLast(const K& k, unsigned h) const { return key.FindLast(k, h); }
 int FindLast(const K& k) const { return key.FindLast(k); }
 int FindPrev(int i) const { return key.FindPrev(i); }

 int FindAdd(const K& k);
 int FindAdd(const K& k, const T& init);
 int FindAddPick(const K& k, const T& init);

 int Put(const K& k, const T& x);
 int PutPick(const K& k, const T& x);
 T& Put(const K& k);

 int FindPut(const K& k);
 int FindPut(const K& k, const T& init);
 int FindPutPick(const K& k, const T& init);

 T& Get(const K& k) { return value[Find(k)]; }
 const T& Get(const K& k) const { return value[Find(k)]; }
 const T& Get(const K& k, const T& d) const { int i = Find(k); return i >= 0 ? value[i] : d; }

 T& GetAdd(const K& k);

 T& GetAdd(const K& k, const T& x);
 T& GetAddPick(const K& k, const T& x);

 T& GetPut(const K& k);

 T& GetPut(const K& k, const T& x);
 T& GetPutPick(const K& k, const T& x);

 void SetKey(int i, const K& k) { key.Set(i, k); }

 T *FindPtr(const K& k) { int i = Find(k); return i >= 0 ? &value[i] : __null; }
 const T *FindPtr(const K& k) const { int i = Find(k); return i >= 0 ? &value[i] : __null; }






 void Unlink(int i) { key.Unlink(i); }
 int UnlinkKey(const K& k, unsigned h) { return key.UnlinkKey(k, h); }
 int UnlinkKey(const K& k) { return key.UnlinkKey(k); }
 bool IsUnlinked(int i) const { return key.IsUnlinked(i); }
 void Sweep();

 T& Insert(int i, const K& k) { key.Insert(i, k); return value.Insert(i); }
 void Insert(int i, const K& k, const T& x) { key.Insert(i, k); value.Insert(i, x); }
 void Remove(int i) { key.Remove(i); value.Remove(i); }
 void Remove(const int *sl, int n) { key.Remove(sl, n); value.Remove(sl, n); }
 void Remove(const Vector<int>& sl) { Remove(sl, sl.GetCount()); }
 int RemoveKey(const K& k);

 const T& operator[](int i) const { return value[i]; }
 T& operator[](int i) { return value[i]; }
 int GetCount() const { return value.GetCount(); }
 bool IsEmpty() const { return value.IsEmpty(); }
 void Clear() { key.Clear(); value.Clear(); }
 void Shrink() { value.Shrink(); key.Shrink(); }
 void Reserve(int xtra) { value.Reserve(xtra); key.Reserve(xtra); }
 int GetAlloc() const { return value.GetAlloc(); }

 void Drop(int n = 1) { key.Drop(n); value.Drop(n); }
 T& Top() { return value.Top(); }
 const T& Top() const { return value.Top(); }
 const K& TopKey() const { return key.Top(); }

 K PopKey() { K h = TopKey(); Drop(); return h; }
 void Trim(int n) { key.Trim(n); value.SetCount(n); }

 const K& GetKey(int i) const { return key[i]; }


 void Serialize(Stream& s);


 void Swap(AMap& x) { Upp::Swap(value, x.value);
                                                  Upp::Swap(key, x.key); }
 const Index<K, HashFn>& GetIndex() const { return key; }
 Index<K, HashFn> PickIndex() const { return key; }

 const Vector<K>& GetKeys() const { return key.GetKeys(); }
 Vector<K> PickKeys() const { return key.PickKeys(); }

 const V& GetValues() const { return value; }
 V PickValues() const { return value; }

 AMap() {}
 AMap(const AMap& s, int) : value(s.value, 0), key(s.key, 0) {}
 AMap(const Index<K, HashFn>& ndx, const V& val) : key(ndx), value(val) {}
 AMap(const Vector<K>& ndx, const V& val) : key(ndx), value(val) {}

 typedef K KeyType;
 typedef typename Index<K, HashFn>::ConstIterator KeyConstIterator;

 KeyConstIterator KeyBegin() const { return key.Begin(); }
 KeyConstIterator KeyEnd() const { return key.End(); }
 KeyConstIterator KeyGetIter(int pos) const { return key.GetIter(pos); }

 typedef T ValueType;
 typedef typename V::ConstIterator ConstIterator;
 typedef typename V::Iterator Iterator;

 Iterator Begin() { return value.Begin(); }
 Iterator End() { return value.End(); }
 Iterator GetIter(int pos) { return value.GetIter(pos); }
 ConstIterator Begin() const { return value.Begin(); }
 ConstIterator End() const { return value.End(); }
 ConstIterator GetIter(int pos) const { return value.GetIter(pos); }

 friend int GetCount(const AMap& v) { return v.GetCount(); }
};

template <class K, class T, class HashFn = StdHash<K> >
class VectorMap : public MoveableAndDeepCopyOption<VectorMap<K, T, HashFn> >,
                  public AMap< K, T, Vector<T>, HashFn > {
    typedef AMap< K, T, Vector<T>, HashFn > B;
public:
 T Pop() { T h = B::Top(); B::Drop(); return h; }

 VectorMap(const VectorMap& s, int) : AMap<K, T, Vector<T>, HashFn>(s, 1) {}
 VectorMap(const Index<K, HashFn>& ndx, const Vector<T>& val) : AMap<K, T, Vector<T>, HashFn>(ndx, val) {}
 VectorMap(const Vector<K>& ndx, const Vector<T>& val) : AMap<K, T, Vector<T>, HashFn>(ndx, val) {}
 VectorMap() {}

 friend void Swap(VectorMap& a, VectorMap& b) { a.B::Swap(b); }

 typedef typename AMap< K, T, Vector<T>, HashFn >::ConstIterator ConstIterator;
 typedef typename AMap< K, T, Vector<T>, HashFn >::Iterator Iterator;
 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return B::Begin(); } const_iterator end() const { return B::End(); } void clear() { B::Clear(); } size_type size() { return B::GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return B::Begin(); } iterator end() { return B::End(); }
};

template <class K, class T, class HashFn = StdHash<K> >
class ArrayMap : public MoveableAndDeepCopyOption< ArrayMap<K, T, HashFn> >,
                 public AMap< K, T, Array<T>, HashFn > {
 typedef AMap< K, T, Array<T>, HashFn > B;
public:
 void Add(const K& k, const T& x) { B::Add(k, x); }
 T& Add(const K& k) { return B::Add(k); }
 T& Add(const K& k, T *newt) { B::key.Add(k); B::value.Add(newt); return *newt; }
 template <class TT> TT& Create(const K& k) { TT *q = new TT; B::key.Add(k); B::value.Add(q); return *q; }

 void Set(int i, T *ptr) { B::value.Set(i, ptr); }
 T *PopDetach() { B::key.Drop(); return B::value.PopDetach(); }

 ArrayMap(const ArrayMap& s, int) : AMap<K, T, Array<T>, HashFn>(s, 1) {}
 ArrayMap(const Index<K, HashFn>& ndx, const Array<T>& val) : AMap<K, T, Array<T>, HashFn>(ndx, val) {}
 ArrayMap(const Vector<K>& ndx, const Array<T>& val) : AMap<K, T, Array<T>, HashFn>(ndx, val) {}
 ArrayMap() {}

 friend void Swap(ArrayMap& a, ArrayMap& b) { a.B::Swap(b); }

 typedef typename AMap< K, T, Array<T>, HashFn >::ConstIterator ConstIterator;
 typedef typename AMap< K, T, Array<T>, HashFn >::Iterator Iterator;
 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return B::Begin(); } const_iterator end() const { return B::End(); } void clear() { B::Clear(); } size_type size() { return B::GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return B::Begin(); } iterator end() { return B::End(); }
};

template <class K, class T, int NBLK = 16, class HashFn = StdHash<K> >
class SegtorMap : public MoveableAndDeepCopyOption< SegtorMap<K, T, NBLK, HashFn > >,
                  public AMap< K, T, Segtor<T, NBLK>, HashFn > {
 typedef AMap< K, T, Segtor<T, NBLK>, HashFn > B;
public:
 SegtorMap(const SegtorMap& s, int) : AMap<K, T, Segtor<T, NBLK>, HashFn>(s, 1) {}
 SegtorMap(const Index<K, HashFn>& ndx, const Segtor<T>& val) : AMap<K, T, Segtor<T, NBLK>, HashFn>(ndx, val) {}
 SegtorMap(const Vector<K>& ndx, const Segtor<T>& val) : AMap<K, T, Segtor<T, NBLK>, HashFn>(ndx, val) {}
 SegtorMap() {}

 friend void Swap(SegtorMap& a, SegtorMap& b) { a.B::Swap(b); }

 typedef typename B::ConstIterator ConstIterator;
 typedef typename B::Iterator Iterator;
 typedef T value_type; typedef ConstIterator const_iterator; typedef const T& const_reference; typedef int size_type; typedef int difference_type; const_iterator begin() const { return B::Begin(); } const_iterator end() const { return B::End(); } void clear() { B::Clear(); } size_type size() { return B::GetCount(); } typedef Iterator iterator; typedef T& reference; iterator begin() { return B::Begin(); } iterator end() { return B::End(); }
};
# 375 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Algo.h" 1
template <class T>
inline int sgn(T a) { return a > 0 ? 1 : a < 0 ? -1 : 0; }

template <class T>
inline T tabs(T a) { return (a >= 0 ? a : -a); }

template <class T>
inline int cmp(const T& a, const T& b) { return a > b ? 1 : a < b ? -1 : 0; }

template <class I>
void Reverse(I start, I end)
{
 if(start != end && --end != start)
  do
   IterSwap(start, end);
  while(++start != end && --end != start);
}

template <class C>
void Reverse(C& container)
{
 Reverse(container.Begin(), container.End());
}

template <class T, class V>
void Sum(V& sum, T ptr, T end)

{
 while(ptr != end)
  sum += *ptr++;
}

template <class T>
typename T::ValueType Sum(const T& c, const typename T::ValueType& init = typename T::ValueType())
{
 typename T::ValueType sum = init;
 Sum(sum, c.Begin(), c.End());
 return sum;
}

template <class T>
typename T::ValueType Sum0(const T& c)
{
 typename T::ValueType sum = 0;
 Sum(sum, c.Begin(), c.End());
 return sum;
}

template <class T>
T MinElement(T ptr, T end)
{
 ;
 T min = ptr;
 while(++ptr != end)
  if(*ptr < *min) min = ptr;
 return min;
}

template <class C>
int MinIndex(const C& c)
{
 if(c.GetCount() == 0)
  return -1;
 typename C::ValueType m = c[0];
 int mi = 0;
 for(int i = 1; i < c.GetCount(); i++)
  if(c[i] < m) {
   m = c[i];
   mi = i;
  }
 return mi;
}

template <class C>
int MaxIndex(const C& c)
{
 if(c.GetCount() == 0)
  return -1;
 typename C::ValueType m = c[0];
 int mi = 0;
 for(int i = 1; i < c.GetCount(); i++)
  if(c[i] > m) {
   m = c[i];
   mi = i;
  }
 return mi;
}

template <class T>
const typename T::ValueType& Min(const T& c)
{
 return *MinElement(c.Begin(), c.End());
}

template <class T>
T MaxElement(T ptr, T end)
{
 ;
 T max = ptr;
 while(++ptr != end)
  if(*max < *ptr) max = ptr;
 return max;
}

template <class T>
const typename T::ValueType& Max(const T& c)
{
 return *MaxElement(c.Begin(), c.End());
}

template<class T>
struct StdEqual
{
 bool operator () (const T& a, const T& b) const { return a == b; }
};

template<class T>
struct StdLess {
 bool operator () (const T& a, const T& b) const { return a < b; }
};

template<class T>
struct StdGreater
{
 bool operator () (const T& a, const T& b) const { return a > b; }
};
# 151 "C:/upp/uppsrc/Core/Algo.h"
template <class T, class C>
bool IsEqual(T ptr1, T end1, T ptr2, T end2, const C& equal)
{
 for(; ptr1 != end1 && ptr2 != end2; ++ptr1, ++ptr2)
  if(!equal(*ptr1, *ptr2)) return false;
 return ptr1 == end1 && ptr2 == end2;
}

template <class T, class C>
bool IsEqual(const T& c1, const T& c2, const C& equal)
{
 return IsEqual(c1.Begin(), c1.End(), c2.Begin(), c2.End(), equal);
}

template <class T>
bool IsEqual(const T& c1, const T& c2)
{
 typedef typename T::ValueType VT;
 return IsEqual(c1, c2, StdEqual<VT>());
}

template <class T, class V, class C>
T Find(T ptr, T end, const V& value, const C& equal)
{
 while(ptr != end) {
  if(equal(*ptr, value)) return ptr;
  ptr++;
 }
 return __null;
}

template <class T, class V>
T Find(T ptr, T end, const V& value)
{
 return Find(ptr, end, value, StdEqual<T>());
}

template <class T, class V, class C>
int FindIndex(const T& cont, const V& value, const C& equal)
{
 for(int i = 0; i < cont.GetCount(); i++)
  if(equal(cont[i], value)) return i;
 return -1;
}

template <class T, class V>
int FindIndex(const T& cont, const V& value)
{
 typedef typename T::ValueType VT;
 return FindIndex(cont, value, StdEqual<VT>());
}

template <class I, class K, class L>
int BinFindIndex(I begin, I end, const K& key, const L& less)
{
 if(begin == end)
  return 0;
 int min = 0;
 int max = end - begin;

 while(min < max)
 {
  int mid = (max + min) >> 1;
  if(less(*(begin + mid), key))
   min = mid + 1;
  else
   max = mid;
 }
 return min;
}

template <class C, class K, class L>
inline int BinFindIndex(const C& container, const K& key, const L& less)
{
 return BinFindIndex(container.Begin(), container.End(), key, less);
}

template <class C, class K>
inline int BinFindIndex(const C& container, const K& key)
{
 typedef typename C::ValueType VT;
 return BinFindIndex(container, key, StdLess<VT>());
}

template <class I, class K, class L>
inline I BinFind(I begin, I end, const K& key, const L& less)
{
 return begin + BinFindIndex(begin, end, key, less);
}

template <class C, class K, class L>
inline typename C::ConstIterator BinFind(const C& container, const K& key, const L& less)
{
 return BinFind(container.Begin(), container.End(), key, less);
}

template <class C, class K>
inline typename C::ConstIterator BinFind(const C& container, const K& key)
{
 typedef typename C::ValueType VT;
 return BinFind(container, key, StdLess<VT>());
}



template <class I, class C>
int IterCompare(I a, I a_end, I b, I b_end, const C& compare)
{
 for(;;) {
  if(a >= a_end)
   return b < b_end ? -1 : 0;
  if(b >= b_end)
   return a < a_end ? 1 : 0;
  int q = compare(*a++, *b++);
  if(q)
   return q;
 }
}

template <class C, class T, class L>
int FindLowerBound(const C& v, int pos, int count, const T& val, const L& less)
{
 while(count > 0) {
  int half = count >> 1;
  int m = pos + half;
  if(less(v[m], val)) {
   pos = m + 1;
   count = count - half - 1;
  }
  else
   count = half;
 }
 return pos;
}

template <class I, class T, class L>
I FindLowerBoundIter(I begin, I end, const T& val, const L& less)
{
 return begin + FindLowerBound(begin, 0, end - begin, val, less);
}

template <class I, class T>
I FindLowerBoundIter(I begin, I end, const T& val)
{
 return begin + FindLowerBound(begin, 0, end - begin, val, StdLess<T>());
}

template <class C, class T, class L>
int FindLowerBound(const C& v, const T& val, const L& less)
{
 return FindLowerBound(v, 0, v.GetCount(), val, less);
}

template <class C, class T>
int FindLowerBound(const C& v, const T& val)
{
 return FindLowerBound(v, val, StdLess<typename C::ValueType>());
}

template <class C, class T, class L>
int FindUpperBound(const C& v, int pos, int count, const T& val, const L& less)
{
 while(count > 0) {
  int half = count >> 1;
  int m = pos + half;
  if(less(val, v[m]))
   count = half;
  else {
   pos = m + 1;
   count = count - half - 1;
  }
 }
 return pos;
}

template <class I, class T, class L>
I FindUpperBoundIter(I begin, I end, const T& val, const L& less)
{
 return begin + FindUpperBound(begin, 0, end - begin, val, less);
}

template <class I, class T>
I FindUpperBoundIter(I begin, I end, const T& val)
{
 return begin + FindUpperBound(begin, 0, end - begin, val, StdLess<T>());
}

template <class C, class T, class L>
int FindUpperBound(const C& v, const T& val, const L& less)
{
 return FindUpperBound(v, 0, v.GetCount(), val, less);
}

template <class C, class T>
int FindUpperBound(const C& v, const T& val)
{
 return FindUpperBound(v, val, StdLess<typename C::ValueType>());
}

template <class C, class T, class L>
int FindBinary(const C& v, const T& val, int pos, int count, const L& less)
{
 int i = FindLowerBound(v, pos, count, val, less);
 return i < count && !less(val, v[i]) ? i : -1;
}

template <class I, class T, class L>
I FindBinaryIter(I begin, I end, const T& val, const L& less)
{
 int q = FindUpperBound(begin, begin, end, val, less);
 return q < 0 ? __null : begin + q;
}

template <class I, class T>
I FindBinaryIter(I begin, I end, const T& val)
{
 return FindBinaryIter(begin, end, val, StdLess<T>());
}

template <class C, class T, class L>
int FindBinary(const C& v, const T& val, const L& less)
{
 return FindBinary(v, val, 0, v.GetCount(), less);
}

template <class C, class T>
int FindBinary(const C& v, const T& val)
{
 return FindBinary(v, val, StdLess<typename C::ValueType>());
}

template <class I, class K, class X>
int BinFindCompIndex(I begin, I end, const K& key, const X& comp)
{
 if(begin == end)
  return 0;
 int min = 0;
 int max = end - begin;
 while(min < max)
 {
  int mid = (max + min) >> 1;
  if(comp.Compare(key, *(begin + mid)) > 0)
   min = mid + 1;
  else
   max = mid;
 }
 return min;
}

template <class C, class K, class X>
inline int BinFindCompIndex(const C& container, const K& key, const X& comp)
{
 return BinFindCompIndex(container.Begin(), container.End(), key, comp);
}

template <class I, class K, class X>
inline I BinFindComp(I begin, I end, const K& key, const X& comp)
{
 return begin + BinFindCompIndex(begin, end, key, comp);
}

template <class C, class K, class X>
inline typename C::ConstIterator BinFindComp(const C& container, const K& key, const X& comp)
{
 return BinFindComp(container.Begin(), container.End(), key, comp);
}

template <class T, class V>
void Append(T& dst, V ptr, V end)
{
 for(; ptr != end; ++ptr)
  dst.Add(*ptr);
}

template <class T, class V>
void Append(T& dst, V ptr, int n)
{
 for(; n--; ++ptr)
  dst.Add(*ptr);
}

template <class T, class V>
void Append(T& dst, const V& src)
{
 Append(dst, src.Begin(), src.End());
}

template <class C, class I>
C& FindAppend(C& dest, I begin, I end)
{
 for(; begin != end; ++begin)
  dest.FindAdd(*begin);
 return dest;
}

template <class C, class S>
inline C& FindAppend(C& dest, const S& source)
{
 return FindAppend(dest, source.Begin(), source.End());
}

template <class C, class L>
C& AppendSorted(C& dest, const C& src, const L& less)
{
 if(src.IsEmpty())
  return dest;
 if(dest.IsEmpty())
 {
  dest <<= src;
  return dest;
 }
 if(!less(*src, dest.Top()))
 {
  dest.Append(src);
  return dest;
 }
 if(!less(*dest, src.Top()))
 {
  dest.Insert(0, src);
  return dest;
 }
 int dc = dest.GetCount();
 int sc = src.GetCount();
 dest.SetCount(dc + sc);
 typename C::Iterator de = dest.End();
 typename C::ConstIterator se = src.End(), pe = dest.GetIter(dc);
 --se;
 --pe;
 for(;;)
 {
  if(less(*se, *pe))
  {
   *--de = *pe;
   if(pe == dest.Begin())
   {
    *--de = *se;
    while(se != src.Begin())
     *--de = *--se;
    return dest;
   }
   --pe;
  }
  else
  {
   *--de = *se;
   if(se == src.Begin())
    return dest;
   --se;
  }
 }
 return dest;
}

template <class C>
C& AppendSorted(C& dest, const C& src)
{
 typedef typename C::ValueType VT;
 return AppendSorted(dest, src, StdLess<VT>());
}

template <class C, class L>
C& UnionSorted(C& dest, const C& src, const L& less)
{
 if(src.IsEmpty())
  return dest;
 if(dest.IsEmpty())
 {
  dest <<= src;
  return dest;
 }
 if(less(dest.Top(), *src))
 {
  dest.Append(src);
  return dest;
 }
 if(less(src.Top(), *dest))
 {
  dest.Insert(0, src);
  return dest;
 }
 int dc = dest.GetCount();
 int sc = src.GetCount();
 dest.SetCount(dc + sc);
 typename C::Iterator de = dest.End();
 typename C::ConstIterator se = src.End(), pe = dest.GetIter(dc);
 --se;
 --pe;
 for(;;)
 {
  if(less(*se, *pe))
  {
   *--de = *pe;
   if(pe == dest.Begin())
   {
    *--de = *se;
    while(se != src.Begin())
     *--de = *--se;
    dest.Remove(0, dest.GetIndex(*de));
    return dest;
   }
   --pe;
  }
  else
  {
   *--de = *se;
   if(!less(*pe, *se))
   {
    if(pe == dest.Begin())
    {
     while(se != src.Begin())
      *--de = *--se;
     dest.Remove(0, dest.GetIndex(*de));
     return dest;
    }
    --pe;
   }
   if(se == src.Begin())
   {
    int pi = (pe - dest.Begin()) + 1;
    dest.Remove(pi, (de - dest.Begin()) - pi);
    return dest;
   }
   --se;
  }
 }
 return dest;
}

template <class C>
C& UnionSorted(C& dest, const C& src)
{
 typedef typename C::ValueType VT;
 return UnionSorted(dest, src, StdLess<VT>());
}

template <class C, class L>
C& RemoveSorted(C& from, const C& what, const L& less)
{
 if(from.IsEmpty() || what.IsEmpty() ||
    less(from.Top(), *what.Begin()) || less(what.Top(), *from.Begin()))
  return from;
 typename C::ConstIterator we = what.End(), wp = BinFind(what, from[0], less);
 if(wp == we)
  return from;
 typename C::Iterator fp = from.Begin() + BinFindIndex(from, *wp), fe = from.End(), fd = fp;
 if(fp == fe)
 {
  from.Clear();
  return from;
 }
 for(;;)
 {
  while(less(*fp, *wp))
  {
   *fd = *fp;
   ++fd;
   if(++fp == fe)
   {
    from.SetCount(fd - from.Begin());
    return from;
   }
  }
  if(less(*wp, *fp))
  {
   do
    if(++wp == we)
    {
     Copy(fd, fp, fe);
     fd += (fe - fp);
     from.SetCount(fd - from.Begin());
     return from;
    }
   while(less(*wp, *fp));
  }
  else
  {
   const typename C::ValueType& value = *fp;
   while(!less(value, *fp))
    if(++fp == fe)
    {
     from.SetCount(fd - from.Begin());
     return from;
    }
   do
    if(++wp == we)
    {
     Copy(fd, fp, fe);
     fd += (fe - fp);
     from.SetCount(fd - from.Begin());
     return from;
    }
   while(!less(value, *wp));
  }
 }
}

template <class C>
C& RemoveSorted(C& from, const C& what)
{
 typedef typename C::ValueType VT;
 return RemoveSorted(from, what, StdLess<VT>());
}

template <class D, class S, class L>
D& IntersectSorted(D& dest, const S& src, const L& less)
{
 if(dest.IsEmpty())
  return dest;
 if(src.IsEmpty() || less(dest.Top(), src[0]) || less(src.Top(), dest[0]))
 {
  dest.Clear();
  return dest;
 }
 typename S::ConstIterator ss = BinFind(src, dest[0], less), se = src.End();
 if(ss == se)
 {
  dest.Clear();
  return dest;
 }
 typename D::ConstIterator ds = BinFind(dest, src[0], less), de = dest.End();
 if(ds == de)
 {
  dest.Clear();
  return dest;
 }
 typename D::Iterator d = dest.Begin();
 int count = 0;
 for(;;)
 {
  if(less(*ss, *ds))
  {
   if(++ss == se)
    break;
  }
  else
  {
   if(!less(*ds, *ss))
   {
    *d = *ds;
    ++d;
    count++;
   }
   if(++ds == de)
    break;
  }
 }
 dest.SetCount(count);
 return dest;
}

template <class D, class S>
D& IntersectSorted(D& dest, const S& src)
{
 typedef typename D::ValueType VT;
 return IntersectSorted(dest, src, StdLess<VT>());
}


template <class T>
void StreamContainer(Stream& s, T& cont)
{
 int n = cont.GetCount();
 s / n;
 if(s.IsLoading())
 {
  cont.Clear();
  while(n--)
   s % cont.Add();
 }
 else
 {
  for(typename T::Iterator ptr = cont.Begin(); n--; ++ptr)
   s % *ptr;
 }
}


template <class I, class Less>
void ForwardSort(I begin, I end, const Less& less)
{
 if(begin == end)
  return;
 I limit = end;
 --limit;
 while(!(begin == limit))
 {
  for(I best = limit, next = limit, ptr = limit;; best = ptr)
   if(!less(*best, *--ptr))
   {
    if(ptr == begin)
    {
     begin = next;
     break;
    }
   }
   else
   {
    do
    {
     if(ptr == begin)
     {
      IterSwap(begin, best);
      ++begin;
      goto NEXT_ITEM;
     }
    }
    while(less(*best, *--ptr));
    if(ptr == begin)
    {
     IterSwap(++begin, best);
     ++begin;
     break;
    }
    next = ptr;
    ++next;
   }
 NEXT_ITEM:
  ;
 }
}

template <class T, class Less>
void ForwardSort(T& c, const Less& less)
{
 ForwardSort(c.Begin(), c.End(), less);
}

template <class T>
void ForwardSort(T& c)
{
 typedef typename T::ValueType VT;
 ForwardSort(c.Begin(), c.End(), StdLess<VT>());
}

enum
{
 __SORT_THRESHOLD = 16,
 __SORT_MEDIAN_PASSES = 2,
};

template <class I, class Less>
void Sort(I begin, I end, const Less& less)
{
 int count;
 while((count = end - begin) > __SORT_THRESHOLD) {
  int expected = count >> 1, deviation = expected - (expected >> 8);
  I b = begin, e = end, m = b + expected;
  for(int pass = 1;; pass++) {
   for(;; ++b) {
    while(less(*m, *--e))
     ;
    while(less(*b, *m))
     ++b;
    if(!(b < e))
     break;
    if(m == b) m = e;
    else if(m == e) m = b;
    IterSwap(b, e);
   }
   if(pass >= __SORT_MEDIAN_PASSES)
    break;
   int pos = (b - begin);
   if(pos <= expected - deviation)
    e = end;
   else if(pos >= expected + deviation) {
    e = b;
    b = begin;
   }
   else
    break;
   m = b + 1 + (int)((unsigned)rand() % (e - b - 2));
  }
  if(b - begin < end - e) {
   Sort(begin, b, less);
   begin = b;
  }
  else {
   Sort(b, end, less);
   end = b;
  }
 }
 if(count >= 2)
  ForwardSort(begin, end, less);
}
# 844 "C:/upp/uppsrc/Core/Algo.h"
template <class T, class Less>
void Sort(T& c, const Less& less)
{
 Sort(c.Begin(), c.End(), less);
}

template <class T>
void Sort(T& c)
{
 typedef typename T::ValueType VT;
 Sort(c.Begin(), c.End(), StdLess<VT>());
}

template <class II, class VI, class K>
struct IndexSortIterator
{
 typedef IndexSortIterator<II, VI, K> Iter;

 IndexSortIterator(II ii, VI vi) : ii(ii), vi(vi) {}

 Iter& operator ++ () { ++ii; ++vi; return *this; }
 Iter& operator -- () { --ii; --vi; return *this; }
 const K& operator * () const { return *ii; }
 Iter operator + (int i) const { return Iter(ii + i, vi + i); }
 Iter operator - (int i) const { return Iter(ii - i, vi - i); }
 int operator - (Iter b) const { return (int)(ii - b.ii); }
 bool operator == (Iter b) const { return ii == b.ii; }
 bool operator != (Iter b) const { return ii != b.ii; }
 bool operator < (Iter b) const { return ii < b.ii; }
 friend void IterSwap (Iter a, Iter b) { IterSwap(a.ii, b.ii); IterSwap(a.vi, b.vi); }

 II ii;
 VI vi;
};

template <class II, class VI, class K, class Less>
inline void __IndexSort(II begin, II end, VI pair, const Less& less, const K *)
{
 Sort(IndexSortIterator<II, VI, K>(begin, pair),
  IndexSortIterator<II, VI, K>(end, pair + (end - begin)),
  less);
}

template <class II, class VI, class Less>
inline void IndexSort(II begin, II end, VI pair, const Less& less)
{
 if(begin != end)
  __IndexSort(begin, end, pair, less, &*begin);
}

template <class KC, class VC, class Less>
inline void IndexSort(KC& keys, VC& values, const Less& less)
{
 typedef typename KC::ValueType KT;
 ;
 if(keys.GetCount() >= 2)
  __IndexSort(keys.Begin(), keys.End(), values.Begin(), less, (KT *)0);
}

template <class KC, class VC>
inline void IndexSort(KC& keys, VC& values)
{
 typedef typename KC::ValueType KT;
 if(keys.GetCount() >= 2)
  __IndexSort(keys.Begin(), keys.End(), values.Begin(), StdLess<KT>(), (KT *)0);
}

template <class II, class VI, class WI, class K>
struct IndexSort2Iterator
{
 typedef IndexSort2Iterator<II, VI, WI, K> Iter;

 IndexSort2Iterator(II ii, VI vi, WI wi) : ii(ii), vi(vi), wi(wi) {}

 Iter& operator ++ () { ++ii; ++vi; ++wi; return *this; }
 Iter& operator -- () { --ii; --vi; --wi; return *this; }
 const K& operator * () const { return *ii; }
 Iter operator + (int i) const { return Iter(ii + i, vi + i, wi + i); }
 Iter operator - (int i) const { return Iter(ii - i, vi - i, wi - i); }
 int operator - (Iter b) const { return (int)(ii - b.ii); }
 bool operator == (Iter b) const { return ii == b.ii; }
 bool operator != (Iter b) const { return ii != b.ii; }
 bool operator < (Iter b) const { return ii < b.ii; }
 friend void IterSwap (Iter a, Iter b) { IterSwap(a.ii, b.ii); IterSwap(a.vi, b.vi); IterSwap(a.wi, b.wi); }

 II ii;
 VI vi;
 WI wi;
};

template <class II, class VI, class WI, class K, class Less>
inline void __IndexSort2(II begin, II end, VI pair1, WI pair2, const Less& less, const K *)
{
 int count = end - begin;
 Sort(IndexSort2Iterator<II, VI, WI, K>(begin, pair1, pair2),
  IndexSort2Iterator<II, VI, WI, K>(end, pair1 + count, pair2 + count),
  less);
}

template <class II, class VI, class WI, class Less>
inline void IndexSort2(II begin, II end, VI pair1, WI pair2, const Less& less)
{
 if(begin != end)
  __IndexSort2(begin, end, pair1, pair2, less, &*begin);
}

template <class KC, class VC, class WC, class Less>
inline void IndexSort2(KC& keys, VC& values1, WC& values2, const Less& less)
{
 typedef typename KC::ValueType KT;
 ;
 if(keys.GetCount() >= 2)
  __IndexSort2(keys.Begin(), keys.End(), values1.Begin(), values2.Begin(), less, (KT *)0);
}

template <class KC, class VC, class WC>
inline void IndexSort2(KC& keys, VC& values1, WC& values2)
{
 typedef typename KC::ValueType KT;
 if(keys.GetCount() >= 2)
  __IndexSort2(keys.Begin(), keys.End(), values1.Begin(), values2.Begin(), StdLess<KT>(), (KT *)0);
}

template <class I, class V>
struct SortOrderIterator : PostfixOps< SortOrderIterator<I, V> >
{
 typedef SortOrderIterator<I, V> Iter;

 SortOrderIterator(int *ii, I vi) : ii(ii), vi(vi) {}

 Iter& operator ++ () { ++ii; return *this; }
 Iter& operator -- () { --ii; return *this; }
 const V& operator * () const { return *(vi + *ii); }
 Iter operator + (int i) const { return Iter(ii + i, vi); }
 Iter operator - (int i) const { return Iter(ii - i, vi); }
 int operator - (Iter b) const { return int(ii - b.ii); }
 bool operator == (Iter b) const { return ii == b.ii; }
 bool operator != (Iter b) const { return ii != b.ii; }
 bool operator < (Iter b) const { return ii < b.ii; }
 friend void IterSwap (Iter a, Iter b) { IterSwap(a.ii, b.ii); }

 int *ii;
 I vi;
};

template <class I, class V, class Less>
inline void __SortOrder(int *begin, int *end, I data, const Less& less, const V *)
{
 Sort(SortOrderIterator<I, V>(begin, data), SortOrderIterator<I, V>(end, data), less);
}

template <class I, class Less>
inline Vector<int> GetSortOrder(I begin, I end, const Less& less)
{
 Vector<int> index;
 index.SetCount((int)(end - begin));
 for(int i = index.GetCount(); --i >= 0; index[i] = i)
  ;
 if(begin != end)
  __SortOrder(index.Begin(), index.End(), begin, less, &*begin);
 return index;
}

template <class C, class Less>
inline Vector<int> GetSortOrder(const C& container, const Less& less)
{
 return GetSortOrder(container.Begin(), container.End(), less);
}

template <class C>
inline Vector<int> GetSortOrder(const C& container)
{
 typedef typename C::ValueType V;
 return GetSortOrder(container.Begin(), container.End(), StdLess<V>());
}

template <class I, class Less, class T>
void StableSort__(int n, I begin, I end, const Less& less, T *temp)
{
 if(n > 1) {
  int n2 = n / 2;
  I mid = begin + n2;
  StableSort__(n2, begin, mid, less, temp);
  StableSort__(n - n2, mid, end, less, temp);
  I i1 = begin;
  I i2 = mid;
  T *t = temp;
  for(;;) {
   if(i1 == mid) {
    while(i2 != end)
     ::new(t++) T(*i2++);
    break;
   }
   if(i2 == end) {
    while(i1 != mid)
     ::new(t++) T(*i1++);
    break;
   }
   if(less(*i2, *i1))
    ::new(t++) T(*i2++);
   else
    ::new(t++) T(*i1++);
  }
  t = temp;
  while(begin != end)
   *begin++ = *t++;
  DestroyArray(temp, t);
 }
}

template <class I, class Less, class T>
void StableSort__(I begin, I end, const Less& less, const T&)
{
 int n = end - begin;
 T *temp = (T*) new byte[sizeof(T) * n];
 StableSort__(n, begin, end, less, temp);
 delete[] (byte *)temp;
}

template <class I, class Less>
void StableSort(I begin, I end, const Less& less)
{
 StableSort__(begin, end, less, *begin);
}

template <class C, class Less>
void StableSort(C& a, const Less& less)
{
 StableSort(a.Begin(), a.End(), less);
}

template <class C>
void StableSort(C& a)
{
 StableSort(a, StdLess<typename C::ValueType>());
}

template <class I, class Less>
struct StableSortOrderLess {
 I data;
 const Less *less;

 bool operator()(const int& a, const int& b) const {
  return (*less)(*(data + a), *(data + b));
 }
};

template <class I, class Less>
inline Vector<int> GetStableSortOrder(I begin, I end, const Less& less)
{
 Vector<int> index;
 index.SetCount((int)(end - begin));
 for(int i = index.GetCount(); --i >= 0; index[i] = i)
  ;
 StableSortOrderLess<I, Less> oless;
 oless.data = begin;
 oless.less = &less;
 if(begin != end)
  StableSort(index.Begin(), index.End(), oless);
 return index;
}

template <class C, class Less>
inline Vector<int> GetStableSortOrder(const C& container, const Less& less)
{
 return GetStableSortOrder(container.Begin(), container.End(), less);
}

template <class C>
inline Vector<int> GetStableSortOrder(const C& container)
{
 typedef typename C::ValueType V;
 return GetStableSortOrder(container.Begin(), container.End(), StdLess<V>());
}

template <class I, class IV, class Less, class T, class TV>
void StableIndexSort__(int n, I begin, I end, IV beginv, const Less& less, T *temp, TV *tempv)
{
 if(n > 1) {
  int n2 = n / 2;
  I mid = begin + n2;
  IV midv = beginv + n2;
  StableIndexSort__(n2, begin, mid, beginv, less, temp, tempv);
  StableIndexSort__(n - n2, mid, end, midv, less, temp, tempv);
  I i1 = begin;
  IV i1v = beginv;
  I i2 = mid;
  IV i2v = midv;
  T *t = temp;
  TV *tv = tempv;
  for(;;) {
   if(i1 == mid) {
    while(i2 != end) {
     ::new(t++) T(*i2++);
     ::new(tv++) TV(*i2v++);
    }
    break;
   }
   if(i2 == end) {
    while(i1 != mid) {
     ::new(t++) T(*i1++);
     ::new(tv++) TV(*i1v++);
    }
    break;
   }
   if(less(*i2, *i1)) {
    ::new(t++) T(*i2++);
    ::new(tv++) TV(*i2v++);
   }
   else {
    ::new(t++) T(*i1++);
    ::new(tv++) TV(*i1v++);
   }
  }
  t = temp;
  tv = tempv;
  while(begin != end) {
   *begin++ = *t++;
   *beginv++ = *tv++;
  }
  DestroyArray(temp, t);
  DestroyArray(tempv, tv);
 }
}

template <class I, class IV, class Less, class T, class TV>
void StableIndexSort__(I begin, I end, IV beginv, const Less& less, const T&, const TV&)
{
 int n = end - begin;
 T *temp = (T*) new byte[sizeof(T) * n];
 TV *tempv = (TV*) new byte[sizeof(T) * n];
 StableIndexSort__(n, begin, end, beginv, less, temp, tempv);
 delete[] (byte *)temp;
 delete[] (byte *)tempv;
}

template <class I, class IV, class Less>
void StableIndexSort(I begin, I end, IV beginv, const Less& less)
{
 StableIndexSort__(begin, end, beginv, less, *begin, *beginv);
}

template <class C, class CV, class Less>
void StableIndexSort(C& a, CV& v, const Less& less)
{
 StableIndexSort(a.Begin(), a.End(), v.Begin(), less);
}

template <class C, class CV>
void StableIndexSort(C& a, CV& v)
{
 StableIndexSort(a, v, StdLess<typename C::ValueType>());
}

template <class DC, class I, class F>
void GetFieldContainer(DC& dest, I begin, I end, F field)
{
 for(; begin != end; ++begin)
  dest.Add((*begin).*field);
}

template <class DC, class SC, class F>
void GetFieldContainer(DC& dest, const SC& src, F field)
{ GetFieldContainer<DC, typename SC::ConstIterator, F>(dest, src.Begin(), src.End(), field); }

template <class I, class F, class O, class E>
I FindField(I begin, I end, F field, const O& object, const E& equal)
{
 for(; begin != end && !equal((*begin).*field, object); ++begin)
  ;
 return begin;
}

template <class I, class F, class O>
I FindField(I begin, I end, F field, const O& object)
{ return FindField(begin, end, field, object, StdEqual<O>()); }

template <class C, class F, class O, class E>
int FindFieldIndex(const C& container, F field, const O& object, const E& equal)
{
 int i = 0;
 for(typename C::ConstIterator b = container.Begin(), e = container.End(); b != e; ++b, ++i)
  if(equal((*b).*field, object))
   return i;
 return -1;
}

template <class C, class F, class O>
int FindFieldIndex(const C& container, F field, const O& object)
{ return FindFieldIndex(container, field, object, StdEqual<O>()); }

template <class O, class T, class R>
class FieldRelationCls {
 O T::*member;
 const R& relation;

public:
 FieldRelationCls(O (T::*member), const R& relation) : member(member), relation(relation) {}
 bool operator () (const T& t1, const T& t2) const { return relation(t1.*member, t2.*member); }
};

template <class O, class T, class R>
inline FieldRelationCls<O, T, R> FieldRelation(O (T::*member), const R& relation)
{ return FieldRelationCls<O, T, R>(member, relation); }

template <class M, class T, class R>
class MethodRelationCls {
 M method;
 const R& relation;

public:
 MethodRelationCls(M method, const R& relation) : method(method), relation(relation) {}
 bool operator () (const T& t1, const T& t2) const {
  return relation((t1.*method)(), (t2.*method)());
 }
};

template <class O, class T, class R>
inline MethodRelationCls<O (T::*)(), T, R>
 MethodRelation(O (T::*method)(), const R& relation)
{ return MethodRelationCls<O (T::*)(), T, R>(method, relation); }

template <class O, class T, class R>
inline MethodRelationCls<O (T::*)() const, T, R>
 MethodRelation(O (T::*method)() const, const R& relation)
{ return MethodRelationCls<O (T::*)() const, T, R>(method, relation); }

template <class C, class T>
void LruAdd(C& lru, T value, int limit = 10) {
 int q = FindIndex(lru, value);
 if(q >= 0)
  lru.Remove(q);
 lru.Insert(0, value);
 if(lru.GetCount() > limit)
  lru.SetCount(limit);
}
# 376 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Other.h" 1
template <class T>
T& Single() {
 static T *p;
 for(static volatile bool o_b_; !o_b_;) for(static StaticCriticalSection o_ss_; !o_b_;) for(CriticalSection::Lock o_ss_lock__(o_ss_); !o_b_; Set__(o_b_)) {
  static T o;
  p = &o;
 }
 return *p;
}

template <class T>
class One : MoveableAndDeepCopyOption< One<T> > {
 mutable T *ptr;

 void Free() { if(ptr && ptr != (T*)1) delete ptr; }
 void Chk() const { ; }
 void ChkP() const { Chk(); ; }
 void Pick(const One<T>& data) { T *p = data.ptr; data.ptr = (T*)1; ptr = p; }

public:
 void Attach(T *data) { Free(); ptr = data; }
 T *Detach() const { ChkP(); T *t = ptr; ptr = __null; return t; }
 T *operator-() const { return Detach(); }
 void Clear() { Free(); ptr = __null; }

 void operator=(T *data) { Attach(data); }
 void operator=(const One<T>& d) { Free(); Pick(d); }

 const T *operator->() const { ChkP(); return ptr; }
 T *operator->() { ChkP(); return ptr; }
 const T *operator~() const { Chk(); return ptr; }
 T *operator~() { Chk(); return ptr; }
 const T& operator*() const { ChkP(); return *ptr; }
 T& operator*() { ChkP(); return *ptr; }

 template <class TT>
 TT& Create() { TT *q = new TT; Attach(q); return *q; }
 T& Create() { T *q = new T; Attach(q); return *q; }

 bool IsPicked() const { return ptr == (T*)1; }
 bool IsEmpty() const { Chk(); return !ptr; }

 operator bool() const { return ptr; }

 One() { ptr = __null; }
 One(T *newt) { ptr = newt; }
 One(const One<T>& p) { Pick(p); }
 One(const One<T>& p, int) { ptr = p.IsEmpty() ? __null : DeepCopyNew(*p); }
 ~One() { Free(); }
};

class Any : Moveable<Any> {
 struct BaseData {
  int typeno;

  virtual ~BaseData() {}
 };

 template <class T>
 struct Data : BaseData {
  T data;

  Data() { typeno = StaticTypeNo<T>(); }
 };

 BaseData *ptr;

 void Chk() const { ; }
 void Pick(const Any& s) { ptr = s.ptr; const_cast<Any&>(s).ptr = (BaseData *)1; }

public:
 template <class T> T& Create() { Clear(); Data<T> *x = new Data<T>; ptr = x; return x->data; }
 template <class T> bool Is() const { return ptr && ptr->typeno == StaticTypeNo<T>(); }
 template <class T> T& Get() { ; Chk(); return ((Data<T>*)ptr)->data; }
 template <class T> const T& Get() const { ; Chk(); return ((Data<T>*)ptr)->data; }

 void Clear() { if(ptr) delete ptr; ptr = __null; }

 bool IsEmpty() const { return ptr == __null; }
 bool IsPicked() const { return ptr == (void *)1; }

 void operator=(const Any& s) { Clear(); Pick(s); }
 Any(const Any& s) { Pick(s); }

 Any() { ptr = __null; }
 ~Any() { Clear(); }
};

template <class T>
class Buffer : Moveable< Buffer<T> > {
 mutable T *ptr;

public:
 operator T*() { return ptr; }
 operator const T*() const { return ptr; }
 T *operator~() { return ptr; }
 const T *operator~() const { return ptr; }

 void Alloc(int size) { Clear(); ptr = new T[size]; }
 void Alloc(int size, const T& in) { Clear(); ptr = new T[size];
                                     Fill(ptr, ptr + size, in); }

 void Clear() { if(ptr) delete[] ptr; ptr = __null; }

 Buffer() { ptr = __null; }
 Buffer(int size) { ptr = new T[size]; }
 Buffer(int size, const T& init) { ptr = new T[size]; Fill(ptr, ptr + size, init); }
 ~Buffer() { if(ptr) delete[] ptr; }

 void operator=(const Buffer& v) { if(ptr) delete[] ptr; ptr = v.ptr; v.ptr = __null; }
 Buffer(const Buffer& v) { ptr = v.ptr; v.ptr = __null; }
};

class Bits : Moveable<Bits> {
 mutable int alloc;
 dword *bp;

public:
 void Clear();
 void Set(int i, bool b = true);
 void Set(int i, bool b, int count);
 bool Get(int i) const { ; int q = i >> 5;
                                  return q < alloc ? bp[q] & (1 << (i & 31)) : false; }
 bool operator[](int i) const { return Get(i); }

 Bits() { bp = __null; alloc = 0; }
 ~Bits() { Clear(); }

 Bits(const Bits& b) { alloc = b.alloc; bp = b.bp; b.alloc = -1; }
 void operator=(const Bits& b) { Clear(); alloc = b.alloc; bp = b.bp; b.alloc = -1; }
};


template <class T>
class Mitor : Moveable< Mitor<T> > {
 union {
  mutable unsigned count;
  mutable Vector<T> *vector;
 };
 byte elem0[sizeof(T)];

 T& Get(int i) const;
 void Pick(const Mitor& m);
 void Copy(const Mitor& m);
 void Chk() const { ; }

public:
 T& operator[](int i) { return Get(i); }
 const T& operator[](int i) const { return Get(i); }
 int GetCount() const;
 T& Add();
 void Add(const T& x);
 void Clear();
 void Shrink();

 Mitor(const Mitor& m) { Pick(m); }
 void operator=(const Mitor& m) { Clear(); Pick(m); }

 Mitor(Mitor& m, int) { Copy(m); }
 void operator<<=(const Mitor& m) { Clear(); Copy(m); }

 Mitor() { count = 0; }
 ~Mitor() { Clear(); }
};

template <class T>
T& Mitor<T>::Get(int i) const
{
 ;
 return i == 0 ? *(T*)elem0 : (*const_cast<Vector<T>*>(vector))[i - 1];
}

template <class T>
void Mitor<T>::Pick(const Mitor& m)
{
 m.Chk();
 vector = m.vector;
 memcpy(&elem0, &m.elem0, sizeof(T));
 m.count = 2;
}

template <class T>
void Mitor<T>::Copy(const Mitor& m)
{
 m.Chk();
 if(m.count > 0)
  DeepCopyConstruct((T*)elem0, m.elem0);
 if(m.count > 1)
  vector = new Vector<T>(m.vector, 1);
}

template <class T>
int Mitor<T>::GetCount() const
{
 Chk();
 return count > 1 ? vector->GetCount() + 1 : count;
}

template <class T>
T& Mitor<T>::Add()
{
 Chk();
 if(count == 0) {
  count = 1;
  return *new(elem0) T;
 }
 if(count == 1)
  vector = new Vector<T>;
 return vector->Add();
}

template <class T>
void Mitor<T>::Add(const T& x)
{
 Chk();
 if(count == 0) {
  count = 1;
  new((T*) elem0) T(x);
 }
 else {
  if(count == 1)
   vector = new Vector<T>;
  vector->Add(x);
 }
}

template <class T>
void Mitor<T>::Clear()
{
 if(count > 2)
  delete vector;
 if(count && count != 2)
  ((T*)elem0)->T::~T();
 count = 0;
}

template <class T>
void Mitor<T>::Shrink()
{
 if(count > 2)
  vector->Shrink();
}


template <class T, int N = 1>
class Link {
protected:
 T *prev[N];
 T *next[N];

 void LPN(int i) { prev[i]->next[i] = next[i]->prev[i] = (T *)this; }

public:
 T *GetPtr() { return (T *) this; }
 const T *GetPtr() const { return (const T *) this; }
 T *GetNext(int i = 0) { return next[i]; }
 T *GetPrev(int i = 0) { return prev[i]; }
 const T *GetNext(int i = 0) const { return next[i]; }
 const T *GetPrev(int i = 0) const { return prev[i]; }

 void LinkSelf(int i = 0) { next[i] = prev[i] = (T *)this; }
 void LinkSelfAll() { for(int i = 0; i < N; i++) LinkSelf(i); }
 void Unlink(int i = 0) { next[i]->prev[i] = prev[i]; prev[i]->next[i] = next[i];
                                        LinkSelf(i); }
 void UnlinkAll() { for(int i = 0; i < N; i++) Unlink(i); }
 void LinkBefore(Link *n, int i = 0) { next[i] = (T *)n; prev[i] = next[i]->prev[i]; LPN(i); }
 void LinkAfter(Link *p, int i = 0) { prev[i] = (T *)p; next[i] = prev[i]->next[i]; LPN(i); }

 T *InsertNext(int i = 0) { T *x = new T; x->LinkAfter(this, i); return x; }
 T *InsertPrev(int i = 0) { T *x = new T; x->LinkBefore(this, i); return x; }

 void DeleteList(int i = 0) { while(next[i] != GetPtr()) delete next[i]; }

 bool InList(int i = 0) const { return next[i] != GetPtr(); }
 bool IsEmpty(int i = 0) const { return !InList(i); }

 Link() { LinkSelfAll(); }
 ~Link() { UnlinkAll(); }

private:
 Link(const Link&);
 void operator=(const Link&);

public:







};

template <class T, int N = 1>
class LinkOwner : public Link<T, N> {
public:
 ~LinkOwner() { Link<T, N>::DeleteList(); }
};

template <class T>
struct LRUCache {
 struct Maker {
  virtual String Key() const = 0;
  virtual int Make(T& object) const = 0;
  virtual ~Maker() {}
 };

private:
 struct Item : Moveable<Item> {
  int16 prev, next;
  int size;
  One<T> data;
  bool flag;
 };

 Index<String> key;
 Vector<Item> data;
 int head;

 int size;
 int count;

 int foundsize;
 int newsize;
 bool flag;


 void Unlink(int i);
 void LinkHead(int i);

public:
 int GetSize() const { return size; }

 void Shrink(int maxsize);

 const T& Get(const Maker& m);

 void ClearCounters();
 int GetFoundSize() const { return foundsize; }
 int GetNewSize() const { return newsize; }

 LRUCache() { head = -1; size = 0; count = 0; ClearCounters(); }
};

template <class T>
void LRUCache<T>::LinkHead(int i)
{
 Item& m = data[i];
 if(head >= 0) {
  int tail = data[head].prev;
  m.next = head;
  m.prev = tail;
  data[head].prev = i;
  data[tail].next = i;
 }
 else
  m.prev = m.next = i;
 head = i;
 count++;
}


template <class T>
void LRUCache<T>::Unlink(int i)
{
 Item& m = data[i];
 if(m.prev == i)
  head = -1;
 else {
  if(head == i)
   head = m.next;
  data[(int)m.next].prev = m.prev;
  data[(int)m.prev].next = m.next;
 }
 count--;
}

template <class T>
void LRUCache<T>::Shrink(int maxsize)
{
 if(maxsize < 0)
  return;
 while((count > 30000 || size > maxsize) && head >= 0) {
  int tail = data[head].prev;
  size -= data[tail].size;
  data[tail].data.Clear();
  Unlink(tail);
  key.Unlink(tail);
 }
}

template <class T>
void LRUCache<T>::ClearCounters()
{
 flag = !flag;
 newsize = foundsize = 0;
}

template <class T>
const T& LRUCache<T>::Get(const Maker& m)
{
 String k = m.Key();
 k.Cat((const char *)&typeid(m), sizeof(void *));
 int q = key.Find(k);
 if(q < 0) {
  q = key.Put(k);
  Item& t = data.At(q);
  t.size = m.Make(t.data.Create());
  size += t.size;
  newsize += t.size;
  t.flag = flag;
 }
 else {
  Item& t = data[q];
  Unlink(q);
  if(t.flag != flag) {
   t.flag = flag;
   foundsize += t.size;
  }
 }
 LinkHead(q);
 return *data[q].data;
}
# 377 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Vcont.hpp" 1


void VectorReAlloc_(void *vector_, int newalloc, int sizeofT);
void VectorReAllocF_(void *vector_, int newalloc, int sizeofT);
void VectorGrow_(void *vector_, int sizeofT);
void VectorGrowF_(void *vector_, int sizeofT);

template <class T>
void Vector<T>::ReAlloc(int newalloc)
{
 VectorReAlloc_(this, newalloc, sizeof(T));
}

template <class T>
void Vector<T>::ReAllocF(int newalloc)
{
 VectorReAllocF_(this, newalloc, sizeof(T));
}

template <class T>
void Vector<T>::Grow()
{
 VectorGrow_(this, sizeof(T));
}

template <class T>
void Vector<T>::GrowF()
{
 VectorGrowF_(this, sizeof(T));
}
# 73 "C:/upp/uppsrc/Core/Vcont.hpp"
template <class T>
void Vector<T>::Pick(const Vector<T>& v)
{
 vector = v.vector;
 items = v.items;
 alloc = v.alloc;
 SetPicked(v);
}

template <class T>
int Vector<T>::GetIndex(const T& item) const
{
 Chk();
 if(vector == __null) return -1;
 int n = &item - vector;
 return n >= 0 && n < items ? n : -1;
}

template <class T>
void Vector<T>::Reserve(int n)
{
 if(n > alloc)
  ReAllocF(n);
}

template <class T>
void Vector<T>::Free() {
 if(vector && items >= 0)
  DestroyArray((T *)vector, (T *)vector + items);
 RawFree(vector);
}

template <class T>
void Vector<T>::Clear() {
 if(vector && items >= 0)
  SetCount(0);
 else {
  alloc = items = 0;
  vector = __null;
 }
}

template <class T>
void Vector<T>::__DeepCopy(const Vector& src) {
 src.Chk();
 items = alloc = src.items;
 if(src.vector) {
  vector = RawAlloc(alloc);
  DeepCopyConstructArray(vector, src.vector, src.vector + items);
 }
 else
  vector = __null;
}

template <class T>
void Vector<T>::GrowAdd(const T& x) {
 T *prev = vector;
 Grow();
 DeepCopyConstruct(Rdd(), x);
 RawFree(prev);
}

template <class T>
void Vector<T>::GrowAddPick(const T& x) {
 T *prev = vector;
 Grow();
 ::new(Rdd()) T(x);
 RawFree(prev);
}

template <class T> inline
void Vector<T>::AddN(int n)
{
 Chk();
 ;
 if(items + n <= alloc) {
  const T *w = vector + items;
  ConstructArray(vector + items, vector + items + n);
  items += n;
 }
 else
  SetCountR(items + n);
}

template <class T>
void Vector<T>::Trim(int n)
{
 ;
 DestroyArray(vector + n, vector + items);
 items = n;
}

template <class T>
void Vector<T>::SetCount(int n) {
 Chk();
 ;
 if(n == items) return;
 if(n < items)
  Trim(n);
 else {
  if(n > alloc) ReAllocF(n);
  ConstructArray(vector + items, vector + n);
  items = n;
 }
}

template <class T>
void Vector<T>::SetCount(int n, const T& init) {
 Chk();
 ;
 if(n == items) return;
 if(n < items)
  DestroyArray(vector + n, vector + items);
 else {
  if(n > alloc) {
   T *prev = vector;
   ReAlloc(n);
   DeepCopyConstructFill(vector + items, vector + n, init);
   RawFree(prev);
  }
  else
   DeepCopyConstructFill(vector + items, vector + n, init);
 }
 items = n;
}

template <class T>
void Vector<T>::SetCountR(int n) {
 Chk();
 if(n + items > alloc)
  ReAllocF(alloc + ntl_max(alloc, n - items));
 SetCount(n);
}

template <class T>
void Vector<T>::SetCountR(int n, const T& init) {
 Chk();
 ;
 if(n == items) return;
 if(n < items)
  DestroyArray(vector + n, vector + items);
 else
  if(n > alloc) {
   T *prev = vector;
   ReAlloc(alloc + ntl_max(alloc, n - items));
   DeepCopyConstructFill(vector + items, vector + n, init);
   RawFree(prev);
  }
  else
   DeepCopyConstructFill(vector + items, vector + n, init);
 items = n;
}

template <class T>
void Vector<T>::Remove(int q, int count) {
 Chk();
 ;
 if(count == 0) return;
 DestroyArray(vector + q, vector + q + count);
 memmove(vector + q, vector + q + count, (items - q - count) * sizeof(T));
 items -= count;
}

template <int size>
class Data_S_ {
 byte filler[size];
};

template <class T>
void Vector<T>::Remove(const int *sorted_list, int n)
{
 Chk();
 if(!n) return;
 int pos = *sorted_list;
 int npos = pos;
 for(;;) {
  ;
  if(pos == *sorted_list) {
   (vector + pos)->T::~T();
   pos++;
   sorted_list++;
   if(--n == 0) break;
   ;
  }
  else
   *((Data_S_<sizeof(T)>*)vector + npos++)
    = *((Data_S_<sizeof(T)>*)vector + pos++);
 }
 while(pos < items)
  *((Data_S_<sizeof(T)>*)vector + npos++) = *((Data_S_<sizeof(T)>*)vector + pos++);
 items = npos;
}

template <class T>
void Vector<T>::Remove(const Vector<int>& v)
{
 Remove(v, v.GetCount());
}

template <class T>
void Vector<T>::RawInsert(int q, int count)
{
 ;
 ;
 if(!count) return;
 if(items + count > alloc) {
  T *newvector = RawAlloc(alloc = alloc + ntl_max(alloc, count));
  if(vector) {
   memcpy(newvector, vector, q * sizeof(T));
   memcpy(newvector + q + count, vector + q, (items - q) * sizeof(T));
   RawFree(vector);
  }
  vector = newvector;
 }
 else
  memmove(vector + q + count, vector + q, (items - q) * sizeof(T));
 items += count;
}

template <class T>
void Vector<T>::InsertN(int q, int count) {
 ;
 ;
 RawInsert(q, count);
 ConstructArray(vector + q, vector + q + count);
}

template <class T>
void Vector<T>::Insert(int q, const T& x, int count) {
 if(!count) return;
 ;
 RawInsert(q, count);
 DeepCopyConstructFill(vector + q, vector + q + count, x);
}

template <class T>
void Vector<T>::Insert(int q, const Vector& x, int offset, int count) {
 ;
 ;
 RawInsert(q, count);
 DeepCopyConstructArray(vector + q, x.vector + offset, x.vector + offset + count);
}

template <class T>
void Vector<T>::Insert(int q, const Vector& x) {
 if(!x.GetCount()) return;
 Insert(q, x, 0, x.GetCount());
}

template <class T>
void Vector<T>::InsertPick(int i, const Vector<T>& v) {
 Chk();
 v.Chk();
 ;
 if(v.items) {
  RawInsert(i, v.items);
  memcpy(vector + i, v.vector, sizeof(T) * v.items);
 }
 RawFree(v.vector);
 SetPicked(v);
}

template <class T>
void Vector<T>::Set(int i, const T& x, int count) {
 Chk();
 ;
 if(count == 0) return;
 if(&x >= vector && &x < vector + items) {
  T copy = x;
  At(i + count - 1);
  Fill(vector + i, vector + i + count, copy);
 }
 else {
  At(i + count - 1);
  Fill(vector + i, vector + i + count, x);
 }
}



template <class T>
void Array<T>::Free() {
 if(IsPicked()) return;
 for(int i = 0; i < vector.GetCount(); i++)
  delete (T *) vector[i];
}

template <class T>
void Array<T>::__DeepCopy(const Array<T>& v) {
 int n = v.GetCount();
 vector.SetCount(n);
 for(int i = 0; i < n; i++)
  vector[i] = DeepCopyNew(v[i]);
}

template <class T>
void Array<T>::Trim(int n)
{
 ;
 Del(vector.Begin() + n, vector.End());
 vector.Trim(n);
}

template <class T>
void Array<T>::SetCount(int n) {
 ;
 int lc = vector.GetCount();
 Del(vector.Begin() + n, vector.End());
 vector.SetCount(n);
 Init(vector.Begin() + lc, vector.Begin() + n);
}

template <class T>
void Array<T>::SetCount(int n, const T& init) {
 ;
 int lc = vector.GetCount();
 Del(vector.Begin() + n, vector.End());
 vector.SetCount(n);
 Init(vector.Begin() + lc, vector.Begin() + n, init);
}

template <class T>
void Array<T>::SetCountR(int n) {
 ;
 int lc = vector.GetCount();
 Del(vector.Begin() + n, vector.End());
 vector.SetCountR(n);
 Init(vector.Begin() + lc, vector.Begin() + n);
}

template <class T>
void Array<T>::SetCountR(int n, const T& init) {
 ;
 int lc = vector.GetCount();
 Del(vector.Begin() + n, vector.End());
 vector.SetCountR(n);
 Init(vector.Begin() + lc, vector.Begin() + n, init);
}

template <class T>
int Array<T>::GetIndex(const T& item) const {
 for(void * const *ptr = vector.Begin(); ptr < vector.End(); ptr++)
  if(*ptr == (void *)&item) return ptr - vector.Begin();
 return -1;
}

template <class T>
void Array<T>::Move(int i1, int i2) {
 void *q = vector[i1];
 vector.Remove(i1);
 vector.Insert(i2) = q;
}

template <class T>
void Array<T>::Remove(int i, int count) {
 ;
 Del(vector.Begin() + i, vector.Begin() + i + count);
 vector.Remove(i, count);
}

template <class T>
void Array<T>::Remove(const int *sorted_list, int n)
{
 const int *q = sorted_list;
 const int *e = sorted_list + n;
 while(q < e) {
  ;
  delete (T *)vector[*q++];
 }
 vector.Remove(sorted_list, n);
}

template <class T>
void Array<T>::Remove(const Vector<int>& sorted_list)
{
 Remove(sorted_list, sorted_list.GetCount());
}

template <class T>
void Array<T>::Set(int i, const T& x, int count) {
 ;
 if(i + count >= GetCount())
  SetCountR(i + count);
 for(void **ptr = vector.Begin() + i; ptr < vector.Begin() + i + count; ptr++) {
  delete (T *) *ptr;
  *ptr = new T(x);
 }
}

template <class T>
void Array<T>::InsertN(int i, int count) {
 ;
 vector.InsertN(i, count);
 Init(vector.Begin() + i, vector.Begin() + i + count);
}

template <class T>
void Array<T>::Insert(int i, const T& x, int count) {
 vector.InsertN(i, count);
 Init(vector.Begin() + i, vector.Begin() + i + count, x);
}

template <class T>
void Array<T>::Insert(int i, T *newt) {
 vector.InsertN(i, 1);
 vector[i] = newt;
}

template <class T>
void Array<T>::Insert(int i, const Array& x) {
 Insert(i, x, 0, x.GetCount());
}

template <class T>
void Array<T>::Insert(int i, const Array& x, int offset, int count) {
 vector.InsertN(i, count);
 for(int q = 0; q < count; q++)
  vector[q + i] = DeepCopyNew(x[q + offset]);
}



template <class T, int NBLK>
Segtor<T, NBLK>::Segtor(const Segtor& s, int) {
 items = s.items;
 block.SetCount((items + NBLK - 1) / NBLK);
 int q = items / NBLK;
 int r = items % NBLK;
 int i;
 for(i = 0; i < q; i++) {
  T *a = (T *) s.block[i].item;
  DeepCopyConstructArray((T *) block[i].item, a, a + NBLK);
 }
 if(r) {
  T *a = (T *) s.block[q].item;
  DeepCopyConstructArray((T *) block[i].item, a, a + r);
 }
}

template <class T, int NBLK>
void Segtor<T, NBLK>::Free() {
 int q = items / NBLK;
 int r = items % NBLK;
 int i;
 for(i = 0; i < q; i++) {
  T *a = (T *) block[i].item;
  DestroyArray(a, a + NBLK);
 }
 if(r) {
  T *a = (T *) block[i].item;
  DestroyArray(a, a + r);
 }
}

template <class T, int NBLK>
Segtor<T, NBLK>::~Segtor() {
 if(IsPicked()) return;
 Free();
}

template <class T, int NBLK>
void Segtor<T, NBLK>::DoRange(unsigned beg, unsigned end, void (*fn)(T*, const T*)) {
 ;
 int bblk = beg / NBLK, bidx = beg % NBLK;
 int eblk = end / NBLK, eidx = end % NBLK;
 if(eblk == block.GetCount()) {
  ;
  eblk--;
  eidx = NBLK;
 }
 ;
 T *tp = (T *)block[bblk].item;
 if(bblk != eblk) {
  (*fn)(tp + bidx, tp + NBLK);
  while(++bblk < eblk) {
   tp = (T *)block[bblk].item;
   (*fn)(tp, tp + NBLK);
  }
  tp = (T *)block[bblk].item;
  (*fn)(tp, tp + eidx);
 }
 else
  (*fn)(tp + bidx, tp + eidx);
}

template <class T, int NBLK>
void Segtor<T, NBLK>::Fill(unsigned beg, unsigned end, const T& x) {
 ;
 int bblk = beg / NBLK, bidx = beg % NBLK;
 int eblk = end / NBLK, eidx = end % NBLK;
 if(eblk == block.GetCount()) {
  ;
  eblk--;
  eidx = NBLK;
 }
 ;
 T *tp = (T *)block[bblk].item;
 if(bblk != eblk) {
  DeepCopyConstructFill(tp + bidx, tp + NBLK, x);
  while(++bblk < eblk) {
   tp = (T *)block[bblk].item;
   DeepCopyConstructFill(tp, tp + NBLK, x);
  }
  tp = (T *)block[bblk].item;
  DeepCopyConstructFill(tp, tp + eidx, x);
 }
 else
  DeepCopyConstructFill(tp + bidx, tp + eidx, x);
}

template <class T, int NBLK>
void Segtor<T, NBLK>::SetCount(int n) {
 Del(n);
 block.SetCount((n + NBLK - 1) / NBLK);
 Init(n);
}

template <class T, int NBLK>
void Segtor<T, NBLK>::SetCount(int n, const T& init) {
 Del(n);
 block.SetCount((n + NBLK - 1) / NBLK);
 Init(n, init);
}

template <class T, int NBLK>
void Segtor<T, NBLK>::Clear() {
 if(!IsPicked())
  Free();
 items = 0;
 block.Clear();
}

template <class T, int NBLK>
void Segtor<T, NBLK>::Set(int i, const T& x, int count) {
 ;
 DoIndex(i + count - 1);
 Iterator q(*this, i);
 while(count--)
  *q++ = x;
}

template <class T, int NBLK>
int Segtor<T, NBLK>::GetIndex(const T& item) const {
 for(int i = 0; i < block.GetCount(); i++) {
  T *q = (T *) block[i].item;
  if(&item >= q && &item < q + NBLK)
   return &item - q + NBLK * i;
 }
 return -1;
}



template <class T>
void BiVector<T>::ReAlloc(int newalloc) {
 ;
 T *newvector = newalloc ? (T *) new byte[newalloc * sizeof(T)] : __null;
 if(items) {
  int end = start + items;
  if(end <= alloc)
   memcpy(newvector, vector + start, (end - start) * sizeof(T));
  else {
   memcpy(newvector, vector + start, (alloc - start) * sizeof(T));
   memcpy(newvector + alloc - start, vector, (end - alloc) * sizeof(T));
  }
  delete[] (byte *)vector;
 }
 vector = newvector;
 alloc = newalloc;
 start = 0;
}

template <class T>
void BiVector<T>::DeepCopy0(const BiVector& src) {
 alloc = items = src.items;
 vector = alloc ? (T *) new byte[alloc * sizeof(T)] : __null;
 if(items) {
  int end = src.start + src.items;
  if(end <= src.alloc)
   DeepCopyConstructArray(vector, src.vector + src.start, src.vector + end);
  else {
   DeepCopyConstructArray(vector, src.vector + src.start, src.vector + src.alloc);
   DeepCopyConstructArray(vector + src.alloc - src.start, src.vector,
                       src.vector + end - src.alloc);
  }
 }
 start = 0;
}

template <class T>
void BiVector<T>::Clear() {
 Free();
 start = items = alloc = 0;
 vector = __null;
}

template <class T>
void BiVector<T>::Add0() {
 ;
 if(items >= alloc)
  ReAlloc(ntl_max(2 * items, 4));
 items++;
}

template <class T>
void BiVector<T>::Shrink() {
 ;
 if(items < alloc)
  ReAlloc(items);
}

template <class T>
void BiVector<T>::Reserve(int n) {
 ;
 n += items;
 if(n > alloc)
  ReAlloc(n);
}

template <class T>
void BiVector<T>::Free() {
 if(vector && items >= 0) {
  int end = start + items;
  if(end <= alloc)
   DestroyArray(vector + start, vector + end);
  else {
   DestroyArray(vector + start, vector + alloc);
   DestroyArray(vector, vector + end - alloc);
  }
  delete[] (byte *)vector;
 }
}


template <class T>
void BiVector<T>::Serialize(Stream& s) {
 int n = items;
 s / n;
 if(s.IsLoading()) {
  Clear();
  while(n--)
   s % AddTail();
 }
 else
  for(int i = 0; i < items; i++)
   s % operator[](i);
}




template <class T>
void BiArray<T>::Free() {
 if(!bv.IsPicked())
  for(int i = 0; i < GetCount(); i++)
   delete (T *) bv[i];
}

template <class T>
void BiArray<T>::DeepCopy0(const BiArray<T>& v) {
 int n = v.GetCount();
 bv.Clear();
 bv.Reserve(v.GetCount());
 for(int i = 0; i < n; i++)
  bv.AddTail() = DeepCopyNew(v[i]);
}


template <class T>
void BiArray<T>::Serialize(Stream& s) {
 int n = bv.GetCount();
 s / n;
 if(s.IsLoading()) {
  Clear();
  while(n--)
   s % AddTail();
 }
 else
  for(int i = 0; i < bv.GetCount(); i++)
   s % operator[](i);
}
# 378 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Index.hpp" 1
inline void HashBase::LinkTo(int i, Link& l, int& m) const
{
 if(m >= 0) {
  Link& bl = link[m];
  l.next = m;
  l.prev = bl.prev;
  bl.prev = i;
  link[l.prev].next = i;
 }
 else
  m = l.prev = l.next = i;
}

inline void HashBase::Unlink(int i, Link& l, int& m)
{
 if(i == m) {
  if(l.next == i) {
   m = -1;
   return;
  }
  m = l.next;
 }
 link[l.next].prev = l.prev;
 link[l.prev].next = l.next;
}

inline void HashBase::Unlink(int i, Link& l)
{
 Unlink(i, l, hash[i] & UNSIGNED_HIBIT ? unlinked : Mapi(i));
}

inline int& HashBase::Mapi(int i) const
{
 return Maph(hash[i]);
}

inline int& HashBase::Maph(unsigned _hash) const
{
 unsigned h = _hash & ~UNSIGNED_HIBIT;
 return map[h % mcount];
}

inline void HashBase::DoIndex() const
{
 if(hash.GetCount() < mcount)
  FinishIndex();
 else
  Reindex();
}

inline int HashBase::Find(unsigned _hash) const
{
 if(hash.GetCount() == 0) return -1;
 if(link.GetCount() < hash.GetCount() || mcount == 0)
  DoIndex();
 return Maph(_hash);
}

inline int HashBase::FindNext(int i) const
{
 if(link.GetCount() < hash.GetCount())
  DoIndex();
 int q = link[i].next;
 return q == Mapi(i) ? -1 : q;
}

inline int HashBase::FindLast(unsigned _hash) const
{
 if(hash.GetCount() == 0) return - 1;
 if(link.GetCount() < hash.GetCount())
  DoIndex();
 int i = Find(_hash & ~UNSIGNED_HIBIT);
 return i >= 0 ? link[i].prev : -1;
}

inline int HashBase::FindPrev(int i) const
{
 if(link.GetCount() < hash.GetCount())
  DoIndex();
 int q = link[i].prev;
 return q == link[Mapi(i)].prev ? -1 : q;
}

inline void HashBase::Unlink(int i)
{
 ;
 hash[i] |= UNSIGNED_HIBIT;
 if(i < link.GetCount()) {
  Link& lnk = link[i];
  Unlink(i, lnk, Mapi(i));
  LinkTo(i, lnk, unlinked);
 }
}

template <class T, class V, class HashFn>
AIndex<T, V, HashFn>::AIndex(const AIndex& s, int)
: key(s.key, 0),
 hash(s.hash, 0) {}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Hash() {
 for(int i = 0; i < key.GetCount(); i++)
  hash.Add(hashfn(key[i]));
}

template <class T, class V, class HashFn>
AIndex<T, V, HashFn>& AIndex<T, V, HashFn>::operator=(const V& s) {
 key = s;
 hash.Clear();
 Hash();
 return *this;
}

template <class T, class V, class HashFn>
AIndex<T, V, HashFn>& AIndex<T, V, HashFn>::operator<<=(const V& s) {
 key <<= s;
 hash.Clear();
 Hash();
 return *this;
}

template <class T, class V, class HashFn>
AIndex<T, V, HashFn>::AIndex(const V& s) : key(s) {
 Hash();
}

template <class T, class V, class HashFn>
AIndex<T, V, HashFn>::AIndex(const V& s, int) : key(s, 1) {
 Hash();
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Add(const T& x, unsigned _hash) {
 key.Add(x);
 hash.Add(_hash);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Add(const T& x) {
 Add(x, hashfn(x));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindAdd(const T& _key, unsigned _hash) {
 int i = Find(_key, _hash);
 if(i >= 0) return i;
 i = key.GetCount();
 Add(_key, _hash);
 return i;
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::Put(const T& x, unsigned _hash)
{
 int q = hash.Put(_hash);
 if(q < 0) {
  q = key.GetCount();
  Add(x, _hash);
 }
 else
  key[q] = x;
 return q;
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::Put(const T& x)
{
 return Put(x, hashfn(x));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindPut(const T& _key, unsigned _hash)
{
 int i = Find(_key, _hash);
 if(i >= 0) return i;
 return Put(_key, _hash);
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindPut(const T& key)
{
 return FindPut(key, hashfn(key));
}

template <class T, class V, class HashFn>
inline int AIndex<T, V, HashFn>::Find(const T& x, unsigned _hash) const {
 return Find0(x, hash.Find(_hash));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::Find(const T& x) const {
 return Find(x, hashfn(x));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindNext(int i) const {
 return Find0(key[i], hash.FindNext(i));
}

template <class T, class V, class HashFn>
inline int AIndex<T, V, HashFn>::FindLast(const T& x, unsigned _hash) const {
 return FindB(x, hash.FindLast(_hash));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindLast(const T& x) const {
 return FindLast(x, hashfn(x));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindPrev(int i) const {
 return FindB(key[i], hash.FindPrev(i));
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::FindAdd(const T& key) {
 return FindAdd(key, hashfn(key));
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Set(int i, const T& x, unsigned _hash) {
 key[i] = x;
 hash.Set(i, _hash);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Set(int i, const T& x) {
 Set(i, x, hashfn(x));
}


template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Serialize(Stream& s) {
 if(s.IsLoading()) ClearIndex();
 key.Serialize(s);
 hash.Serialize(s);
}


template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::UnlinkKey(const T& k, unsigned h)
{
 int n = 0;
 int q = hash.Find(h);
 while(q >= 0) {
  int w = q;
  q = hash.FindNext(q);
  if(k == key[w]) {
   hash.Unlink(w);
   n++;
  }
 }
 return n;
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::UnlinkKey(const T& k)
{
 return UnlinkKey(k, hashfn(k));
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Sweep()
{
 Vector<int> b = hash.GetUnlinked();
 Sort(b);
 Remove(b);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Insert(int i, const T& k, unsigned h) {
 key.Insert(i, k);
 hash.Insert(i, h);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Insert(int i, const T& k) {
 key.Insert(i, k);
 hash.Insert(i, hashfn(k));
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Remove(int i)
{
 key.Remove(i);
 hash.Remove(i);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Remove(const int *sorted_list, int count)
{
 key.Remove(sorted_list, count);
 hash.Remove(sorted_list, count);
}

template <class T, class V, class HashFn>
void AIndex<T, V, HashFn>::Remove(const Vector<int>& sl)
{
 Remove(sl, sl.GetCount());
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::RemoveKey(const T& k, unsigned h)
{
 Vector<int> rk;
 int q = Find(k, h);
 while(q >= 0) {
  rk.Add(q);
  q = FindNext(q);
 }
 Remove(rk);
 return rk.GetCount();
}

template <class T, class V, class HashFn>
int AIndex<T, V, HashFn>::RemoveKey(const T& k)
{
 return RemoveKey(k, hashfn(k));
}



template <class T, class HashFn>
void ArrayIndex<T, HashFn>::Add(T *newt, unsigned _hash) {
 B::key.Add(newt);
 B::hash.Add(_hash);
}

template <class T, class HashFn>
void ArrayIndex<T, HashFn>::Add(T *newt) {
 Add(newt, B::hashfn(*newt));
}

template <class T, class HashFn>
void ArrayIndex<T, HashFn>::Set(int i, T *newt, unsigned _hash) {
 B::key.Set(i, newt);
 B::hash.Set(i, _hash);
}

template <class T, class HashFn>
void ArrayIndex<T, HashFn>::Set(int i, T *newt) {
 Set(i, newt, B::hashfn(*newt));
}



template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindAdd(const K& k) {
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = GetCount();
  key.Add(k, hash);
  value.Add();
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindAdd(const K& k, const T& x) {
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = GetCount();
  key.Add(k, hash);
  value.Add(x);
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindAddPick(const K& k, const T& x) {
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = GetCount();
  key.Add(k, hash);
  value.Add(x);
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::Put(const K& k, const T& x)
{
 int i = key.Put(k);
 if(i < value.GetCount())
  value[i] = x;
 else {
  ;
  value.Add(x);
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::PutPick(const K& k, const T& x)
{
 int i = key.Put(k);
 if(i < value.GetCount())
  value[i] = x;
 else {
  ;
  value.AddPick(x);
 }
 return i;
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::Put(const K& k)
{
 int i = key.Put(k);
 if(i < value.GetCount())
  return value[i];
 else {
  ;
  return value.Add();
 }
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindPut(const K& k)
{
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = key.Put(k, hash);
  value.At(i);
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindPut(const K& k, const T& init)
{
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = key.Put(k, hash);
  if(i >= value.GetCount()) {
   ;
   i = value.GetCount();
   value.Add(init);
  }
  else
   value[i] = init;
 }
 return i;
}

template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::FindPutPick(const K& k, const T& init)
{
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i < 0) {
  i = key.Put(k, hash);
  value.At(i) = init;
 }
 return i;
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetAdd(const K& k) {
 unsigned hash = key.hashfn(k);
 int i = key.Find(k, hash);
 if(i >= 0)
  return value[i];
 key.Add(k, hash);
 return value.Add();
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetAdd(const K& k, const T& x) {
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i >= 0) return value[i];
 key.Add(k, hash);
 value.Add(x);
 return value.Top();
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetAddPick(const K& k, const T& x) {
 unsigned hash = key.hashfn(k);
 int i = Find(k, hash);
 if(i >= 0) return value[i];
 key.Add(k, hash);
 value.AddPick(x);
 return value.Top();
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetPut(const K& k) {
 return value[FindAdd(k)];
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetPut(const K& k, const T& x) {
 return value[FindAdd(k, x)];
}

template <class K, class T, class V, class HashFn>
T& AMap<K, T, V, HashFn>::GetPutPick(const K& k, const T& x) {
 return value[FindAddPick(k, x)];
}


template <class K, class T, class V, class HashFn>
void AMap<K, T, V, HashFn>::Serialize(Stream& s) {
 int version = 0;
 s / version % key % value;
}


template <class K, class T, class V, class HashFn>
int AMap<K, T, V, HashFn>::RemoveKey(const K& k)
{
 Vector<int> rk;
 int q = Find(k);
 while(q >= 0) {
  rk.Add(q);
  q = FindNext(q);
 }
 Remove(rk);
 return rk.GetCount();
}

template <class K, class T, class V, class HashFn>
void AMap<K, T, V, HashFn>::Sweep()
{
 Vector<int> b = key.GetUnlinked();
 Sort(b);
 key.Remove(b);
 value.Remove(b);
}
# 379 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Value.h" 1

struct IdConst {
 const char *text;
 mutable int ndx;
};

class Id : Moveable<Id> {
protected:
 int ndx;
 static Index<String>& Ids();
 void Set(const String& s);

public:
 int AsNdx() const { return ndx; }
 String ToString() const;
 dword GetHashValue() const { return ndx; }
 bool IsNull() const { return ndx == 0; }

 void Serialize(Stream& s);

 operator String() const { return ToString(); }
 String operator~() const { return ToString(); }
 bool operator==(Id b) const { return ndx == b.ndx; }
 bool operator!=(Id b) const { return ndx != b.ndx; }

 static Id Find(const String& s);
 static const String& AsString(int n);

 operator bool() const { return ndx; }

 Id() { ndx = 0; }
 Id(const String& s) { Set(s); }
 Id(const char *s) { Set(s); }
 explicit Id(int n) { ; ndx = n; }
 Id(const IdConst& cnst);
};

const int INT_NULL = (-2147483647 -1);
const int64 INT64_NULL = ((int64)-0x8000000000000000LL);

const double DOUBLE_NULL = -1.0E+308;
const double DOUBLE_NULL_LIM = -1.0E+307;

class Nuller {
public:
 operator int() const { return INT_NULL; }
 operator int64() const { return INT64_NULL; }
 operator double() const { return DOUBLE_NULL; }
 operator bool() const { return false; }

 Nuller() {}
};




extern const Nuller Null;


template<> inline bool IsNull(const int& i) { return i == INT_NULL; }
template<> inline bool IsNull(const int64& i) { return i == INT64_NULL; }
template<> inline bool IsNull(const double& r) { return r < DOUBLE_NULL_LIM; }
template<> inline bool IsNull(const bool& r ) { return false; }
template<> inline bool IsNull(const Date& d) { return d.year == -32768; }
template<> inline bool IsNull(const Time& t) { return t.year == -32768; }

inline const String& Nvl(const String& a, const String& b) { return IsNull(a) ? b : a; }
inline int Nvl(int a, int b) { return IsNull(a) ? b : a; }
inline int64 Nvl(int64 a, int64 b) { return IsNull(a) ? b : a; }
inline double Nvl(double a, double b) { return IsNull(a) ? b : a; }
inline Date Nvl(Date a, Date b) { return IsNull(a) ? b : a; }
inline Time Nvl(Time a, Time b) { return IsNull(a) ? b : a; }

inline int Nvl(int a) { return Nvl(a, 0); }
inline int64 Nvl(int64 a) { return Nvl(a, (int64)0); }
inline double Nvl(double a) { return Nvl(a, 0.0); }

const int VOID_V = 0;

const int INT_V = 1;
const int DOUBLE_V = 2;
const int STRING_V = 3;
const int DATE_V = 4;
const int TIME_V = 5;

const int ERROR_V = 6;

const int VALUE_V = 7;

const int WSTRING_V = 8;

const int INT64_V = 10;
const int BOOL_V = 11;

const int UNKNOWN_V = (int)0xffffffff;

class Value : Moveable<Value> {
public:
 class Void {
 protected:
  Atomic refcount;

 public:
  void Retain() { AtomicInc(refcount); }
  void Release() { if(AtomicDec(refcount) == 0) delete this; }

  virtual dword GetType() const { return VOID_V; }
  virtual bool IsNull() const { return true; }
  virtual void Serialize(Stream& s) {}
  virtual unsigned GetHashValue() const { return 0; }
  virtual bool IsEqual(const Void *p) { return false; }
  virtual bool IsPolyEqual(const Value& v) { return false; }
  virtual String AsString() const { return ""; }

  Void() { AtomicWrite(refcount, 1); }
  virtual ~Void() {}

  friend class Value;
 };

protected:
 static VectorMap<dword, Void* (*)(Stream& s) >& Typemap();

 Void *ptr;

 void SetVoidVal();

public:
 static void Register(dword w, Void* (*c)(Stream& s));

 dword GetType() const { return ptr->GetType(); }
 bool IsError() const { return GetType() == ERROR_V; }
 bool IsVoid() const { return GetType() == VOID_V || IsError(); }
 bool IsNull() const { return ptr->IsNull(); }

 template <class T>
 bool Is() const;

 operator String() const;
 operator WString() const;
 operator Date() const;
 operator Time() const;
 operator double() const;
 operator int() const;
 operator int64() const;
 operator bool() const;

 Value(const String& s);
 Value(const WString& s);
 Value(const char *s);
 Value(int i);
 Value(int64 i);
 Value(double d);
 Value(bool b);
 Value(Date d);
 Value(Time t);
 Value(const Nuller&);

 bool operator==(const Value& v) const;
 bool operator!=(const Value& v) const { return !operator==(v); }

 String ToString() const;

 void Serialize(Stream& s);

 unsigned GetHashValue() const;

 Value& operator=(const Value& v);
 Value(const Value& v);

 Value();
 ~Value();

 Value(Void *p) { ptr = p; }
 const Void *GetVoidPtr() const { return ptr; }
};







inline bool operator==(const Value& v, int x) { return (int)v == x; } inline bool operator==(int x, const Value& v) { return (int)v == x; } inline bool operator!=(const Value& v, int x) { return (int)v != x; } inline bool operator!=(int x, const Value& v) { return (int)v != x; }
inline bool operator==(const Value& v, int64 x) { return (int64)v == x; } inline bool operator==(int64 x, const Value& v) { return (int64)v == x; } inline bool operator!=(const Value& v, int64 x) { return (int64)v != x; } inline bool operator!=(int64 x, const Value& v) { return (int64)v != x; }
inline bool operator==(const Value& v, double x) { return (double)v == x; } inline bool operator==(double x, const Value& v) { return (double)v == x; } inline bool operator!=(const Value& v, double x) { return (double)v != x; } inline bool operator!=(double x, const Value& v) { return (double)v != x; }
inline bool operator==(const Value& v, bool x) { return (bool)v == x; } inline bool operator==(bool x, const Value& v) { return (bool)v == x; } inline bool operator!=(const Value& v, bool x) { return (bool)v != x; } inline bool operator!=(bool x, const Value& v) { return (bool)v != x; }
inline bool operator==(const Value& v, Date x) { return (Date)v == x; } inline bool operator==(Date x, const Value& v) { return (Date)v == x; } inline bool operator!=(const Value& v, Date x) { return (Date)v != x; } inline bool operator!=(Date x, const Value& v) { return (Date)v != x; }
inline bool operator==(const Value& v, Time x) { return (Time)v == x; } inline bool operator==(Time x, const Value& v) { return (Time)v == x; } inline bool operator!=(const Value& v, Time x) { return (Time)v != x; } inline bool operator!=(Time x, const Value& v) { return (Time)v != x; }
inline bool operator==(const Value& v, String x) { return (String)v == x; } inline bool operator==(String x, const Value& v) { return (String)v == x; } inline bool operator!=(const Value& v, String x) { return (String)v != x; } inline bool operator!=(String x, const Value& v) { return (String)v != x; }
inline bool operator==(const Value& v, WString x) { return (WString)v == x; } inline bool operator==(WString x, const Value& v) { return (WString)v == x; } inline bool operator!=(const Value& v, WString x) { return (WString)v != x; } inline bool operator!=(WString x, const Value& v) { return (WString)v != x; }

inline bool operator==(const Value& v, const char *x) { return (String)v == x; }
inline bool operator==(const char *x, const Value& v) { return (String)v == x; }
inline bool operator!=(const Value& v, const char *x) { return (String)v != x; }
inline bool operator!=(const char *x, const Value& v) { return (String)v != x; }

inline bool operator==(const Value& v, const wchar *x) { return (WString)v == x; }
inline bool operator==(const wchar *x, const Value& v) { return (WString)v == x; }
inline bool operator!=(const Value& v, const wchar *x) { return (WString)v != x; }
inline bool operator!=(const wchar *x, const Value& v) { return (WString)v != x; }

inline bool IsVoid(const Value& v) { return v.GetType() == VOID_V; }
inline bool IsError(const Value& v) { return v.GetType() == ERROR_V; }
inline bool IsString(const Value& v) { return v.GetType() == STRING_V || v.GetType() == WSTRING_V; }
inline bool IsNumber(const Value& v) { return v.GetType() == DOUBLE_V || v.GetType() == INT_V
                                                || v.GetType() == INT64_V || v.GetType() == BOOL_V; }
inline bool IsDateTime(const Value& v) { return v.GetType() == DATE_V || v.GetType() == TIME_V; }

int StdValueCompare(const Value& a, const Value& b, int language);
int StdValueCompare(const Value& a, const Value& b);

int StdValueCompareDesc(const Value& a, const Value& b, int language);
int StdValueCompareDesc(const Value& a, const Value& b);

struct ValueOrder {
 virtual bool operator()(const Value& a, const Value& b) const = 0;
};

struct StdValueOrder : ValueOrder {
 int language;

 virtual bool operator()(const Value& a, const Value& b) const;

 StdValueOrder(int l = -1);
 virtual ~StdValueOrder();
};

struct FnValueOrder : ValueOrder {
 int (*fn)(const Value& a, const Value& b);

 virtual bool operator()(const Value& a, const Value& b) const;

 FnValueOrder(int (*fn)(const Value& a, const Value& b));
 virtual ~FnValueOrder();
};

template <class T>
inline dword ValueTypeNo(const T&) { return StaticTypeNo<T>() + 0x8000000;; }

template <class T>
bool IsType(const Value& x, T* = 0) { return ValueTypeNo(*(T *)__null) == x.GetType(); }

template <class T>
inline bool Value::Is() const
{
 return IsType<T>(*this);
}

template <class T, dword type, class B = EmptyClass>
class AssignValueTypeNo : B {
public:
 friend dword ValueTypeNo(const T&) { return type; }

 void operator=(const AssignValueTypeNo&) {}
};

inline dword ValueTypeNo(const int&) { return INT_V; }
inline dword ValueTypeNo(const int64&) { return INT64_V; }
inline dword ValueTypeNo(const double&) { return DOUBLE_V; }
inline dword ValueTypeNo(const bool&) { return BOOL_V; }
inline dword ValueTypeNo(const String&) { return STRING_V; }
inline dword ValueTypeNo(const WString&) { return WSTRING_V; }
inline dword ValueTypeNo(const Date&) { return DATE_V; }
inline dword ValueTypeNo(const Time&) { return TIME_V; }

template <class T>
class RawValueRep : public Value::Void {
protected:
 T v;

public:
 virtual dword GetType() const { return ValueTypeNo(v); }
 virtual bool IsNull() const { return false; }

 const T& Get() const { return v; }
 RawValueRep(const T& v) : v(v) {}
 RawValueRep() {}
 static const RawValueRep *Cast(const Value::Void *p) {
  ;
  return (const RawValueRep *) p;
 }
};

template <class T>
bool IsTypeRaw(const Value& value, T * = 0) {
 return !IsVoid(value) && dynamic_cast<const RawValueRep<T> *>(value.GetVoidPtr());
}

template <class T>
class RawValue : public Value {
protected:
 typedef RawValueRep<T> Rep;

 RawValue(Rep *rep) : Value(rep) {}

public:
 RawValue(const T& x) : Value(new Rep(x)) {}
 static const T& Extract(const Value& v) {
  return Rep::Cast(v.GetVoidPtr())->Get();
 }
 static const T& Extract(const Value& v, const T& dflt) {
  return IsTypeRaw<T>(v) ? Rep::Cast(v.GetVoidPtr())->Get() : dflt;
 }
};

template <class T>
class RawPickValueRep : public RawValueRep<T> {
public:
 RawPickValueRep(const T& _v) { this->v = _v; }
 RawPickValueRep(const T& _v, int) { this->v <<= _v; }
 RawPickValueRep() {}
};

template <class T>
class RawPickValue : public RawValue<T> {
protected:
 typedef RawPickValueRep<T> PickRep;

public:
 RawPickValue(const T& x) : RawValue<T>(new PickRep(x)) {}
 RawPickValue(const T& x, int) : RawValue<T>(new PickRep(x, 0)) {}
};

template <class T>
class RawValueCreateRep : public RawValueRep<T> {
public:
 T& Get() { return this->v; }
};

template <class T>
class RawValueCreate : public RawValue<T> {
protected:
 typedef RawValueCreateRep<T> Rep;

public:
 RawValueCreate() : RawValue<T>(new Rep()) {}
 T& Get() { return ((Rep *)this->GetVoidPtr())->Get(); }
};

template <class T>
inline Value RawToValue(const T& data) { return RawValue<T>(data); }

template <class T>
inline Value RawPickToValue(const T& data) { return RawPickValue<T>(data); }

template <class T>
inline Value RawDeepToValue(const T& data) { return RawPickValue<T>(data, 0); }

template <class T>
inline T& CreateRawValue(Value& v) {
 RawValueCreate<T> x;
 v = x;
 return x.Get();
}

template <class T>
inline const T& ValueTo(const Value& v, T * = 0) { return RawValue<T>::Extract(v); }

template <class T>
inline const T& ValueTo(const Value& v, const T& dflt) { return RawValue<T>::Extract(v, dflt); }

template <class T>
inline bool IsPolyEqual(const T& x, const Value& v) {
 return false;
}

template <class T>
inline unsigned ValueGetHashValue(const T& x) {
 return Upp::GetHashValue(x);
}

inline bool IsPolyEqual(const bool& x, const Value& v) {
 return v.GetType() == DOUBLE_V && int(x) == double(v)
     || v.GetType() == INT64_V && int(x) == int64(v)
     || v.GetType() == INT_V && int(x) == int(v);
}

inline bool IsPolyEqual(const int& x, const Value& v) {
 return v.GetType() == DOUBLE_V && x == double(v)
     || v.GetType() == INT64_V && x == int64(v);
}

inline bool IsPolyEqual(const int64& x, const Value& v) {
 return v.GetType() == DOUBLE_V && double(x) == double(v);
}

inline bool IsPolyEqual(const Date& x, const Value& v) {
 return v.GetType() == TIME_V && ToTime(x) == Time(v);
}

inline bool IsPolyEqual(const WString& x, const Value& v) {
 return v.GetType() == STRING_V && WString(v) == x;
}

inline unsigned ValueGetHashValue(const bool& x) {
 return Upp::GetHashValue((double)x);
}

inline unsigned ValueGetHashValue(const int& x) {
 return Upp::GetHashValue((double)x);
}

inline unsigned ValueGetHashValue(const int64& x) {
 return Upp::GetHashValue((double)x);
}

inline unsigned ValueGetHashValue(const Date& x) {
 return Upp::GetHashValue(ToTime(x));
}

inline unsigned ValueGetHashValue(const String& x) {
 return Upp::GetHashValue((WString)x);
}

template <class T>
class RichValueRep : public RawValueRep<T> {
public:
 virtual bool IsNull() const { return Upp::IsNull(this->v); }
 virtual void Serialize(Stream& s) { s % this->v; }
 virtual unsigned GetHashValue() const { return Upp::ValueGetHashValue(this->v); }
 virtual bool IsEqual(const Value::Void *p) { return Cast(p)->Get() == this->v; }
 virtual bool IsPolyEqual(const Value& b) { return Upp::IsPolyEqual(this->v, b); }
 virtual String AsString() const { return Upp::AsString(this->v); }

 RichValueRep(const T& v) : RawValueRep<T>(v) {}
 RichValueRep(Stream& s) { Serialize(s); }

 static Value::Void *Create(Stream& s) { return new RichValueRep(s); }
 static const RichValueRep *Cast(const Value::Void *p) {
  ;
  return (const RichValueRep *) p;
 }
};

template <class T>
class RichValue : public Value {
protected:
 typedef RichValueRep<T> Rep;

 static const T& GetNull() {
  static T *q;
  for(static volatile bool o_b_; !o_b_;) for(static StaticCriticalSection o_ss_; !o_b_;) for(CriticalSection::Lock o_ss_lock__(o_ss_); !o_b_; Set__(o_b_)) {
   static T x(Null);
   q = &x;
  }
  return *q;
 }

public:
 RichValue(const T& x) : Value(new Rep(x)) {}
 const T& Get(const Value& v) {
  if(IsNull(v)) return GetNull();
  return Rep::Cast(v.GetVoidPtr())->Get();
 }
 static void Register() {
  Value::Register(ValueTypeNo(*(T *)__null), Rep::Create);
 }
 class Registrator {
 public:
  Registrator() {
   RichValue::Register();
  }
 };
 static const T& Extract(const Value& v) {
  if(v.IsNull()) return GetNull();
  return Rep::Cast(v.GetVoidPtr())->Get();
 }
};

template <class T>
inline Value RichToValue(const T& data) { return RichValue<T>(data); }

Value ErrorValue(const char *s);
Value ErrorValue(const String& s);
Value ErrorValue();

String GetErrorText(const Value& v);

inline bool IsNull(const Value& v) { return v.IsNull(); }
inline const Value& Nvl(const Value& a, const Value& b) { return IsNull(a) ? b : a; }

Value Scan(dword stdtype, const String& text);



struct RefManager {
 virtual int GetType() = 0;
 virtual Value GetValue(const void *) { return Null; }
 virtual bool IsNull(const void *) { return false; }
 virtual void SetValue(void *, const Value& v) { ; }
 virtual void SetNull(void *) { ; }
};


template <class T>
struct RawRef : public RefManager {
 virtual void SetValue(void *p, const Value& v) { *(T *) p = RawValue<T>::Extract(v); }
 virtual Value GetValue(const void *p) { return RawValue<T>(*(const T *) p); }
 virtual int GetType() { return ValueTypeNo(*(T *)__null); }
};

template <class T>
struct RichRef : public RawRef<T> {
 virtual Value GetValue(const void *p) { return RichValue<T>(*(T *) p); }
 virtual bool IsNull(const void *p) { return Upp::IsNull(*(T *) p); }
 virtual void SetValue(void *p, const Value& v) { *(T *) p = T(v); }
 virtual void SetNull(void *p) { *(T *) p = T(Null); }
};

class Ref : Moveable<Ref> {
protected:
 RefManager *m;
 void *ptr;
 struct ValueRef;

public:
 dword GetType() const { return m ? m->GetType() : VOID_V; }
 operator Value() const { return m ? m->GetValue(ptr) : Value(); }
 bool IsNull() const { return m ? m->IsNull(ptr) : true; }

 void *GetVoidPtr() const { return ptr; }

 void SetNull() { if(m) m->SetNull(ptr); }
 void SetValue(const Value& v) { ; m->SetValue(ptr, v); }

 Ref& operator=(const Value& v) { SetValue(v); return *this; }

 Ref(String& s);
 Ref(WString& s);
 Ref(int& i);
 Ref(int64& i);
 Ref(double& d);
 Ref(Date& d);
 Ref(Time& t);
 Ref(Value& v);
 Ref(void *_ptr, RefManager *_m) { ptr = _ptr, m = _m; }
 Ref() { ptr = m = __null; }
};

template <class T>
T& GetRef(Ref r, T *x = __null) {
 ;
 return *(T *) r.GetVoidPtr();
}

inline String& RefString(Ref f) { return GetRef<String>(f); }
inline WString& RefWString(Ref f) { return GetRef<WString>(f); }
inline int& RefInt(Ref f) { return GetRef<int>(f); }
inline int64& RefInt64(Ref f) { return GetRef<int64>(f); }
inline double& RefDouble(Ref f) { return GetRef<double>(f); }
inline Date& RefDate(Ref f) { return GetRef<Date>(f); }
inline Time& RefTime(Ref f) { return GetRef<Time>(f); }
inline Value& RefValue(Ref f) { ;
                                    return *(Value *)f.GetVoidPtr(); }

template <class T>
Ref RawAsRef(T& x) {
 return Ref(&x, &Single< RawRef<T> >());
}

template <class T>
Ref RichAsRef(T& x) {
 return Ref(&x, &Single< RichRef<T> >());
}






const int VALUEARRAY_V = 9;

class ValueArray : AssignValueTypeNo<ValueArray, VALUEARRAY_V, Moveable<ValueArray> > {
 struct Data : Value::Void {
  virtual dword GetType() const { return VALUEARRAY_V; }
  virtual bool IsNull() const;
  virtual void Serialize(Stream& s);
  virtual unsigned GetHashValue() const;
  virtual bool IsEqual(const Value::Void *p);
  virtual String AsString() const;

  int GetRefCount() const { return AtomicRead(refcount); }

  Vector<Value> data;
 };
 struct NullData : Data {};
 Data *data;

 Vector<Value>& Create();
 Vector<Value>& Clone();

public:
 ValueArray();
 ValueArray(const ValueArray& v);
 explicit ValueArray(const Vector<Value>& values);
 explicit ValueArray(const Vector<Value>& values, int deep);
 ~ValueArray();

 ValueArray& operator=(const ValueArray& v);

 operator Value() const;
 ValueArray(const Value& src);

 ValueArray(const Nuller&);
 bool IsNull() const { return data->IsNull(); }

 void Clear();
 void SetCount(int n);
 void SetCount(int n, const Value& v);
 int GetCount() const { return data->data.GetCount(); }
 bool IsEmpty() const { return data->data.IsEmpty(); }

 void Add(const Value& v);
 void Set(int i, const Value& v);
 void Remove(int i);
 const Value& Get(int i) const;
 const Vector<Value>& Get() const { return data->data; }

 const Value& operator[](int i) const { return Get(i); }

 unsigned GetHashValue() const { return data->GetHashValue(); }
 void Serialize(Stream& s);

 bool operator==(const ValueArray& v) const;
 bool operator!=(const ValueArray& v) const { return !operator==(v); }
};

template<> inline unsigned GetHashValue(const ValueArray& v) { return v.GetHashValue(); }
template<> inline bool IsNull(const ValueArray& v) { return v.IsNull(); }

template<>
String AsString(const ValueArray& v);

inline bool IsValueArray(const Value& v) { return v.GetType() == 9; }

class ValueGen {
public:
 virtual Value Get() = 0;
 Value operator++() { return Get(); }
};
# 381 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Gtypes.h" 1
template <class T> struct Point_;
template <class T> struct Size_;
template <class T> struct Rect_;

template <class T>
struct Size_ : Moveable< Size_<T> > {
 T cx, cy;

 void Clear() { cx = cy = 0; }
 bool IsEmpty() const { return cx == 0 || cy == 0; }

 void SetNull() { cx = Null; }
 bool IsNullInstance() const { return Upp::IsNull(cx); }

 Size_& operator+=(Size_ p) { cx += p.cx; cy += p.cy; return *this; }
 Size_& operator+=(T t) { cx += t; cy += t; return *this; }
 Size_& operator-=(Size_ p) { cx -= p.cx; cy -= p.cy; return *this; }
 Size_& operator-=(T t) { cx -= t; cy -= t; return *this; }
 Size_& operator*=(Size_ p) { cx *= p.cx; cy *= p.cy; return *this; }
 Size_& operator*=(T t) { cx *= t; cy *= t; return *this; }
 Size_& operator/=(Size_ p) { cx /= p.cx; cy /= p.cy; return *this; }
 Size_& operator/=(T t) { cx /= t; cy /= t; return *this; }
 Size_& operator<<=(int sh) { cx <<= sh; cy <<= sh; return *this; }
 Size_& operator>>=(int sh) { cx >>= sh; cy >>= sh; return *this; }

 Size_& operator++() { ++cx; ++cy; return *this; }
 Size_& operator--() { --cx; --cy; return *this; }

 friend Size_ operator+(Size_ s) { return s; }
 friend Size_ operator-(Size_ s) { return Size_(-s.cx, -s.cy); }

 friend Size_ operator+(Size_ a, Size_ b) { return a += b; }
 friend Size_ operator+(Size_ a, T t) { return a += t; }
 friend Size_ operator+(T t, Size_ b) { return b += t; }
 friend Size_ operator-(Size_ a, Size_ b) { return a -= b; }
 friend Size_ operator-(Size_ a, T t) { return a -= t; }
 friend Size_ operator-(T t, Size_ b) { b = -b; return b += t; }
 friend Size_ operator*(Size_ a, Size_ b) { return a *= b; }
 friend Size_ operator*(Size_ a, T b) { return a *= b; }
 friend Size_ operator*(T a, Size_ b) { return b *= a; }
 friend Size_ operator/(Size_ a, Size_ b) { return a /= b; }
 friend Size_ operator/(Size_ a, T b) { return a /= b; }
 friend Size_ operator<<(Size_ a, int sh) { return a <<= sh; }
 friend Size_ operator>>(Size_ a, int sh) { return a >>= sh; }

 friend bool operator==(Size_ a, Size_ b) { return a.cx == b.cx && a.cy == b.cy; }
 friend bool operator!=(Size_ a, Size_ b) { return !(a == b); }

 friend Size_ min(Size_ a, Size_ b) { return Size_(min(a.cx, b.cx), min(a.cy, b.cy)); }
 friend Size_ max(Size_ a, Size_ b) { return Size_(max(a.cx, b.cx), max(a.cy, b.cy)); }

 friend Size_ Nvl(Size_ a, Size_ b) { return IsNull(a) ? b : a; }

 unsigned GetHashValue() const { return Upp::GetHashValue(cx) ^ Upp::GetHashValue(cy); }

 String ToString() const;

 Size_() {}
 Size_(T cx, T cy) : cx(cx), cy(cy) {}

 Size_(const Size_<int>& sz) : cx((T)sz.cx), cy((T)sz.cy) {}
 Size_(const Size_<short>& sz) : cx((T)sz.cx), cy((T)sz.cy) {}
 Size_(const Size_<double>& sz) : cx((T)sz.cx), cy((T)sz.cy) {}
 Size_(const Size_<int64>& sz) : cx((T)sz.cx), cy((T)sz.cy) {}

 Size_(const Point_<T>& pt) : cx(pt.x), cy(pt.y) {}

 Size_(const Nuller&) { cx = cy = Null; }

 operator Value() const { return RichValue<Size_>(*this); }
 Size_(const Value& src) { *this = RichValue<Size_>::Extract(src); }

 void Serialize(Stream& s) { s % cx % cy; }


 operator SIZE*() { ; return (SIZE*)this; }
 operator const SIZE*() const { ; return (SIZE*)this; }
 operator SIZE() const { SIZE sz; sz.cx = cx; sz.cy = cy; return sz; }
 LONG GetLONG() const { return ((LONG)(((WORD)(cx))|(((DWORD)((WORD)(cy)))<<16))); }

 Size_(POINT pt) : cx((T)pt.x), cy((T)pt.y) {}
 Size_(SIZE sz) : cx((T)sz.cx), cy((T)sz.cy) {}
 explicit Size_(LONG lParam) { cx = (T)(int16)((WORD)((DWORD)(lParam))); cy = (T)(int16)((WORD)(((DWORD)(lParam)>>16)&0xFFFF)); }

};

template <class T>
String Size_<T>::ToString() const {
 String ss;
 return ss << '(' << cx << ", " << cy << ')';
}

template <class T>
struct Point_ : Moveable< Point_<T> > {
 T x, y;

 typedef Size_<T> Sz;

 void Clear() { x = y = 0; }
 bool IsZero() const { return x == 0 && y == 0; }

 void SetNull() { x = y = Null; }
 bool IsNullInstance() const { return Upp::IsNull(x); }

 void Offset(T dx, T dy) { x += dx; y += dy; }

 Point_& operator+=(Sz p) { x += p.cx; y += p.cy; return *this; }
 Point_& operator+=(Point_ p) { x += p.x; y += p.y; return *this; }
 Point_& operator+=(T t) { x += t; y += t; return *this; }
 Point_& operator-=(Sz p) { x -= p.cx; y -= p.cy; return *this; }
 Point_& operator-=(Point_ p) { x -= p.x; y -= p.y; return *this; }
 Point_& operator-=(T t) { x -= t; y -= t; return *this; }
 Point_& operator*=(Sz p) { x *= p.cx; y *= p.cy; return *this; }
 Point_& operator*=(Point_ p) { x *= p.x; y *= p.y; return *this; }
 Point_& operator*=(T t) { x *= t; y *= t; return *this; }
 Point_& operator/=(Sz p) { x /= p.cx; y /= p.cy; return *this; }
 Point_& operator/=(Point_ p) { x /= p.x; y /= p.y; return *this; }
 Point_& operator/=(T t) { x /= t; y /= t; return *this; }
 Point_& operator<<=(int sh) { x <<= sh; y <<= sh; return *this; }
 Point_& operator>>=(int sh) { x >>= sh; y >>= sh; return *this; }

 Point_& operator++() { ++x; ++y; return *this; }
 Point_& operator--() { --x; --y; return *this; }

 friend Point_ operator+(Point_ p) { return p; }
 friend Point_ operator-(Point_ p) { return Point_(-p.x, -p.y); }

 friend Point_ operator+(Point_ a, Sz b) { return a += b; }
 friend Point_ operator+(Point_ a, Point_ b) { return a += b; }
 friend Point_ operator+(Point_ a, T t) { return a += t; }
 friend Point_ operator+(T t, Point_ b) { return b += t; }
 friend Sz operator+(Sz a, Point_ b) { return Point_(a) + b; }
 friend Sz& operator+=(Sz& a, Point_ b) { return a = a + b; }
 friend Point_ operator-(Point_ a, Sz b) { return a -= b; }
 friend Point_ operator-(Point_ a, T t) { return a -= t; }
 friend Sz operator-(Point_ a, Point_ b) { return a -= b; }
 friend Sz operator-(Sz a, Point_ b) { return Point_(a) - b; }
 friend Sz& operator-=(Sz& a, Point_ b) { return a = a - b; }
 friend Point_ operator*(Point_ a, Point_ b) { return a *= b; }
 friend Point_ operator*(Point_ a, T b) { return a *= b; }
 friend Point_ operator*(T a, Point_ b) { return b *= a; }
 friend Point_ operator/(Point_ a, Sz b) { return a /= b; }
 friend Point_ operator/(Point_ a, T b) { return a /= b; }
 friend Point_ operator<<(Point_ a, int sh) { return a <<= sh; }
 friend Point_ operator>>(Point_ a, int sh) { return a >>= sh; }


 friend bool operator==(Point_ a, Point_ b) { return a.x == b.x && a.y == b.y; }
 friend bool operator!=(Point_ a, Point_ b) { return a.x != b.x || a.y != b.y; }

 friend Point_ min(Point_ a, Point_ b) { return Point_(min(a.x, b.x), min(a.y, b.y)); }
 friend Point_ max(Point_ a, Point_ b) { return Point_(max(a.x, b.x), max(a.y, b.y)); }

 friend Point_ Nvl(Point_ a, Point_ b) { return IsNull(a) ? b : a; }

 unsigned GetHashValue() const { return Upp::GetHashValue(x) ^ Upp::GetHashValue(y); }

 String ToString() const;

 Point_() {}
 Point_(T x, T y) : x(x), y(y) {}

 Point_(const Point_<int>& pt) : x((T)pt.x), y((T)pt.y) {}
 Point_(const Point_<short>& pt) : x((T)pt.x), y((T)pt.y) {}
 Point_(const Point_<double>& pt) : x((T)pt.x), y((T)pt.y) {}
 Point_(const Point_<int64>& pt) : x((T)pt.x), y((T)pt.y) {}

 Point_(const Size_<T>& sz) : x(sz.cx), y(sz.cy) {}

 Point_(const Nuller&) { x = y = Null; }

 operator Value() const { return RichValue<Point_>(*this); }
              Point_(const Value& src) { *this = RichValue<Point_>::Extract(src); }

 void Serialize(Stream& s) { s % x % y; }


 operator POINT*() { ; return (POINT*)this; }
 operator const POINT*() const { ; return (POINT*)this; }
 operator POINT() const { POINT p; p.x = x; p.y = y; return p; }
 LONG GetLONG() const { return ((LONG)(((WORD)(x))|(((DWORD)((WORD)(y)))<<16))); }

 Point_(POINT pt) : x((T)pt.x), y((T)pt.y) {}
 Point_(SIZE sz) : x((T)sz.cx), y((T)sz.cy) {}
 explicit Point_(LONG lParam) { x = (T)(int16)((WORD)((DWORD)(lParam))); y = (T)(int16)((WORD)(((DWORD)(lParam)>>16)&0xFFFF)); }

};

template <class T>
String Point_<T>::ToString() const {
 String ss;
 return ss << '[' << x << ", " << y << ']';
}

template <class T>
T GHalf_(T t) { return t >> 1; }

template <>
inline double GHalf_(double d) { return d / 2; }

template <class T>
struct Rect_ : Moveable< Rect_<T> > {
 T left, top, right, bottom;

 typedef Point_<T> Pt;
 typedef Size_<T> Sz;

 void Clear() { left = top = right = bottom = 0; }

 bool IsEmpty() const { return right <= left || bottom <= top; }
 bool IsNullInstance() const;

 Pt TopLeft() const { return Pt(left, top); }
 Pt TopCenter() const { return Pt(GHalf_(left + right), top); }
 Pt TopRight() const { return Pt(right, top); }
 Pt CenterLeft() const { return Pt(left, GHalf_(top + bottom)); }
 Pt CenterPoint() const { return Pt(GHalf_(left + right), GHalf_(top + bottom)); }
 Pt CenterRight() const { return Pt(right, GHalf_(top + bottom)); }
 Pt BottomLeft() const { return Pt(left, bottom); }
 Pt BottomCenter() const { return Pt(GHalf_(left + right), bottom); }
 Pt BottomRight() const { return Pt(right, bottom); }
 T Width() const { return right - left; }
 T Height() const { return bottom - top; }
 Sz Size() const { return Sz(right - left, bottom - top); }

 T GetWidth() const { return right - left; }
 T GetHeight() const { return bottom - top; }
 Sz GetSize() const { return Sz(right - left, bottom - top); }

 Pt CenterPos(T cx, T cy) const;
 Pt CenterPos(Sz sz) const { return CenterPos(sz.cx, sz.cy); }
 Rect_ CenterRect(Sz sz) const { return Rect_(CenterPos(sz), sz); }
 Rect_ CenterRect(T cx, T cy) const { return CenterRect(Sz(cx, cy)); }

 void Set(T l, T t, T r, T b) { left = l; top = t; right = r; bottom = b; }
 void Set(Pt a, Pt b) { left = a.x; top = a.y; right = b.x; bottom = b.y; }
 void Set(Pt a, Sz sz) { Set(a, a + sz); }
 void Set(const Rect_& r) { Set(r.left, r.top, r.right, r.bottom); }

 void SetSize(int cx, int cy) { right = left + cx; bottom = top + cy; }
 void SetSize(Sz sz) { SetSize(sz.cx, sz.cy); }

 void InflateHorz(T dx) { left -= dx; right += dx; }
 void InflateVert(T dy) { top -= dy; bottom += dy; }
 void Inflate(T dx, T dy) { InflateHorz(dx); InflateVert(dy); }
 void Inflate(Sz sz) { Inflate(sz.cx, sz.cy); }
 void Inflate(T dxy) { Inflate(dxy, dxy); }
 void Inflate(T l, T t, T r, T b) { left -= l; top -= t; right += r; bottom += b; }
 void Inflate(const Rect_& r) { Inflate(r.left, r.top, r.right, r.bottom); }

 void DeflateHorz(T dx) { InflateHorz(-dx); }
 void DeflateVert(T dy) { InflateVert(-dy); }
 void Deflate(T dx, T dy) { Inflate(-dx, -dy); }
 void Deflate(Sz sz) { Inflate(-sz); }
 void Deflate(T dxy) { Inflate(-dxy); }
 void Deflate(T l, T t, T r, T b) { Inflate(-l, -t, -r, -b); }
 void Deflate(const Rect_& r) { Deflate(r.left, r.top, r.right, r.bottom); }

 Rect_ InflatedHorz(T dx) const { Rect_ r = *this; r.InflateHorz(dx); return r; }
 Rect_ InflatedVert(T dy) const { Rect_ r = *this; r.InflateVert(dy); return r; }
 Rect_ Inflated(T dx, T dy) const { Rect_ r = *this; r.Inflate(dx, dy); return r; }
 Rect_ Inflated(Sz sz) const { Rect_ r = *this; r.Inflate(sz); return r; }
 Rect_ Inflated(T dxy) const { Rect_ r = *this; r.Inflate(dxy); return r; }
 Rect_ Inflated(T l, T t, T r, T b) const { Rect_ m = *this; m.Inflate(l, t, r, b); return m; }
 Rect_ Inflated(const Rect_& q) const { Rect_ r = *this; r.Inflate(q); return r; }

 Rect_ DeflatedHorz(T dx) const { Rect_ r = *this; r.DeflateHorz(dx); return r; }
 Rect_ DeflatedVert(T dy) const { Rect_ r = *this; r.DeflateVert(dy); return r; }
 Rect_ Deflated(T dx, T dy) const { Rect_ r = *this; r.Deflate(dx, dy); return r; }
 Rect_ Deflated(Sz sz) const { Rect_ r = *this; r.Deflate(sz); return r; }
 Rect_ Deflated(T dxy) const { Rect_ r = *this; r.Deflate(dxy); return r; }
 Rect_ Deflated(T l, T t, T r, T b) const { Rect_ m = *this; m.Deflate(l, t, r, b); return m; }
 Rect_ Deflated(const Rect_& q) const { Rect_ r = *this; r.Deflate(q); return r; }

 void OffsetHorz(T dx) { left += dx; right += dx; }
 void OffsetVert(T dy) { top += dy; bottom += dy; }
 void Offset(T dx, T dy) { OffsetHorz(dx); OffsetVert(dy); }
 void Offset(Sz sz) { Offset(sz.cx, sz.cy); }
 void Offset(Pt p) { Offset(p.x, p.y); }

 Rect_ OffsetedHorz(T dx) const { Rect_ r = *this; r.OffsetHorz(dx); return r; }
 Rect_ OffsetedVert(T dy) const { Rect_ r = *this; r.OffsetVert(dy); return r; }
 Rect_ Offseted(T dx, T dy) const { Rect_ r = *this; r.Offset(dx, dy); return r; }
 Rect_ Offseted(Sz sz) const { Rect_ r = *this; r.Offset(sz); return r; }
 Rect_ Offseted(Pt p) const { Rect_ r = *this; r.Offset(p); return r; }

 void Normalize();
 Rect_ Normalized() const { Rect_ r = *this; r.Normalize(); return r; }

 void Union(Pt p);
 void Union(const Rect_& rc);
 void Intersect(const Rect_& rc);

 bool Contains(T x, T y) const;
 bool Contains(Pt p) const { return Contains(p.x, p.y); }
 bool Contains(const Rect_& rc) const;
 bool Intersects(const Rect_& rc) const;

 Pt Bind(Pt pt) const;

 Rect_& operator+=(Sz sz) { Offset(sz); return *this; }
 Rect_& operator+=(Pt p) { Offset(p); return *this; }
 Rect_& operator+=(const Rect_& b);
 Rect_& operator-=(Sz sz) { Offset(-sz); return *this; }
 Rect_& operator-=(Pt p) { Offset(-p); return *this; }
 Rect_& operator-=(const Rect_& b);

 Rect_& operator|=(Pt p) { Union(p); return *this; }
 Rect_& operator|=(const Rect_& rc) { Union(rc); return *this; }
 Rect_& operator&=(const Rect_& rc) { Intersect(rc); return *this; }

 bool operator==(const Rect_& b) const;
 bool operator!=(const Rect_& b) const { return !operator==(b); }

 friend Rect_ operator+(Rect_ a, Sz b) { return a += b; }
 friend Rect_ operator+(Sz a, Rect_ b) { return b += a; }
 friend Rect_ operator+(Rect_ a, Pt b) { return a += b; }
 friend Rect_ operator+(Pt a, Rect_ b) { return b += a; }
 friend Rect_ operator+(Rect_ a, const Rect_& b) { return a += b; }
 friend Rect_ operator-(Rect_ a, Sz b) { return a -= b; }
 friend Rect_ operator-(Rect_ a, Pt b) { return a -= b; }
 friend Rect_ operator-(Rect_ a, const Rect_& b) { return a -= b; }
 friend Rect_ operator|(Rect_ a, Rect_ b) { a.Union(b); return a; }
 friend Rect_ operator&(Rect_ a, Rect_ b) { a.Intersect(b); return a; }
 friend bool operator&&(const Rect_& a, const Rect_& b) { return a.Intersects(b); }
 friend bool operator>=(const Rect_& a, Pt b) { return a.Contains(b); }
 friend bool operator<=(Pt a, const Rect_& b) { return b.Contains(a); }
 friend bool operator<=(const Rect_& a, const Rect_& b) { return b.Contains(a); }
 friend bool operator>=(const Rect_& b, const Rect_& a) { return a.Contains(b); }

 friend const Rect_& Nvl(const Rect_& a, const Rect_& b) { return IsNull(a) ? b : a; }

 unsigned GetHashValue() const { return Upp::GetHashValue(left) ^ Upp::GetHashValue(top) ^ Upp::GetHashValue(right) ^ Upp::GetHashValue(bottom); }

 String ToString() const;

 Rect_() {}
 Rect_(T l, T t, T r, T b) { Set(l, t, r, b); }
 Rect_(Pt a, Pt b) { Set(a, b); }
 Rect_(Pt a, Sz sz) { Set(a, sz); }
 Rect_(Sz sz) { Set(0, 0, sz.cx, sz.cy); }

 Rect_(const Rect_<int>& r) { Set((T)r.left, (T)r.top, (T)r.right, (T)r.bottom); }
 Rect_(const Rect_<short>& r) { Set((T)r.left, (T)r.top, (T)r.right, (T)r.bottom); }
 Rect_(const Rect_<double>& r) { Set((T)r.left, (T)r.top, (T)r.right, (T)r.bottom); }
 Rect_(const Rect_<int64>& r) { Set((T)r.left, (T)r.top, (T)r.right, (T)r.bottom); }

 Rect_(const Nuller&);

 operator Value() const { return RichValue<Rect_>(*this); }
              Rect_(const Value& src) { *this = RichValue<Rect_>::Extract(src); }

 void Serialize(Stream& s) { s % left % top % right % bottom; }


 operator const RECT*() const { ; return (RECT*)this; }
 operator RECT*() { ; return (RECT*)this; }
 operator RECT&() { ; return *(RECT*)this; }
 operator RECT() const { RECT r; r.top = top; r.bottom = bottom;
                r.left = left; r.right = right; return r; }
 Rect_(const RECT& rc) { Set((T)rc.left, (T)rc.top, (T)rc.right, (T)rc.bottom); }

};

template <class T>
inline Rect_<T>::Rect_(const Nuller&) {
 left = top = right = bottom = Null;
}

template <>
inline Rect_<double>::Rect_(const Nuller&) {
 left = top = 0;
 right = bottom = -1;
}

template <class T>
bool Rect_<T>::IsNullInstance() const {
 return IsNull(left);
}

template <>
inline bool Rect_<double>::IsNullInstance() const {
 return left > right || top > bottom;
}

template <class T>
Point_<T> Rect_<T>::CenterPos(T cx, T cy) const {
 return Point_<T>(left + GHalf_(Width() - cx), top + GHalf_(Height() - cy));
}

template <class T>
void Rect_<T>::Normalize() {
 if(left > right) Swap(left, right);
 if(top > bottom) Swap(top, bottom);
}

template <class T>
void Rect_<T>::Union(Pt p) {
 if(IsNull(p)) return;
 if(IsNullInstance()) {
  right = 1 + (left = p.x);
  bottom = 1 + (top = p.y);
 }
 else
 {
  if(p.x >= right) right = p.x + 1;
  else if(p.x < left) left = p.x;
  if(p.y >= bottom) bottom = p.y + 1;
  else if(p.y < top) top = p.y;
 }
}

template <>
inline void Rect_<double>::Union(Point_<double> p) {
 if(IsNull(p)) return;
 if(IsNullInstance())
 {
  left = right = p.x;
  top = bottom = p.y;
 }
 else
 {
  if(p.x < left) left = p.x;
  else if(p.x > right) right = p.x;
  if(p.y < top) top = p.y;
  else if(p.y > bottom) bottom = p.y;
 }
}

template <class T>
void Rect_<T>::Union(const Rect_<T>& r) {
 if(IsNull(r)) return;
 if(IsNullInstance()) {
  Set(r);
  return;
 }
 if(r.left < left) left = r.left;
 if(r.top < top) top = r.top;
 if(r.right > right) right = r.right;
 if(r.bottom > bottom) bottom = r.bottom;
}

void Rect_double_Union(Rect_<double>& self, const Rect_<double>& r);

template <>
inline void Rect_<double>::Union(const Rect_<double>& r) {
 Rect_double_Union(*this, r);
}

template <class T>
void Rect_<T>::Intersect(const Rect_<T>& r) {
 if(r.left > left) left = r.left;
 if(r.top > top) top = r.top;
 if(right < left) right = left;
 if(r.right < right) right = r.right;
 if(r.bottom < bottom) bottom = r.bottom;
 if(bottom < top) bottom = top;
}

template <class T>
bool Rect_<T>::Contains(T x, T y) const {
 return x >= left && x < right && y >= top && y < bottom;
}

template <>
inline bool Rect_<double>::Contains(double x, double y) const {
 return x >= left && x <= right && y >= top && y <= bottom;
}

template <class T>
bool Rect_<T>::Contains(const Rect_<T>& r) const {
 return r.left >= left && r.top >= top && r.right <= right && r.bottom <= bottom;
}

template <class T>
bool Rect_<T>::Intersects(const Rect_<T>& r) const {
 if(IsEmpty() || r.IsEmpty()) return false;
 return r.right > left && r.bottom > top && r.left < right && r.top < bottom;
}

bool Rect_double_Intersects(const Rect_<double>& self, const Rect_<double>& r);

template <>
inline bool Rect_<double>::Intersects(const Rect_<double>& r) const {
 return Rect_double_Intersects(*this, r);
}

template <class T>
Point_<T> Rect_<T>::Bind(Point_<T> pt) const {
 return Point_<T>(pt.x < left ? left : pt.x >= right ? right - 1 : pt.x,
               pt.y < top ? top : pt.y >= bottom ? bottom - 1 : pt.y);
}

Point_<double> Rect_double_Bind(const Rect_<double>& self, Point_<double> pt);

template <>
inline Point_<double> Rect_<double>::Bind(Point_<double> pt) const {
 return Rect_double_Bind(*this, pt);
}

template <class T>
Rect_<T>& Rect_<T>::operator-=(const Rect_<T>& b) {
 left -= b.left;
 top -= b.top;
 right -= b.right;
 bottom -= b.bottom;
 return *this;
}

template <class T>
Rect_<T>& Rect_<T>::operator+=(const Rect_<T>& b) {
 left += b.left;
 top += b.top;
 right += b.right;
 bottom += b.bottom;
 return *this;
}

template <class T>
bool Rect_<T>::operator==(const Rect_& b) const {
 return top == b.top && bottom == b.bottom && left == b.left && right == b.right;
}

template <class T>
String Rect_<T>::ToString() const
{
 String str;
 return str << AsString(TopLeft()) << " - " << AsString(BottomRight())
            << " : " << AsString(Size());
}

typedef Size_<int> Size;
typedef Point_<int> Point;
typedef Rect_<int> Rect;

typedef Size_<int16> Size16;
typedef Point_<int16> Point16;
typedef Rect_<int16> Rect16;

typedef Size_<double> Sizef;
typedef Point_<double> Pointf;
typedef Rect_<double> Rectf;

typedef Size_<int64> Size64;
typedef Point_<int64> Point64;
typedef Rect_<int64> Rect64;

const int SIZE_V = 70;
const int SIZE16_V = 71;
const int SIZEF_V = 72;
const int SIZE64_V = 79;

template<> inline dword ValueTypeNo(const Size&) { return SIZE_V; }
template<> inline dword ValueTypeNo(const Size16&) { return SIZE16_V; }
template<> inline dword ValueTypeNo(const Size64&) { return SIZE64_V; }
template<> inline dword ValueTypeNo(const Sizef&) { return SIZEF_V; }

const int POINT_V = 73;
const int POINT16_V = 74;
const int POINTF_V = 75;
const int POINT64_V = 80;

template<> inline dword ValueTypeNo(const Point&) { return POINT_V; }
template<> inline dword ValueTypeNo(const Point16&) { return POINT16_V; }
template<> inline dword ValueTypeNo(const Point64&) { return POINT64_V; }
template<> inline dword ValueTypeNo(const Pointf&) { return POINTF_V; }

const int RECT_V = 76;
const int RECT16_V = 77;
const int RECTF_V = 78;
const int RECT64_V = 81;

template<> inline dword ValueTypeNo(const Rect&) { return RECT_V; }
template<> inline dword ValueTypeNo(const Rect16&) { return RECT16_V; }
template<> inline dword ValueTypeNo(const Rect64&) { return RECT64_V; }
template<> inline dword ValueTypeNo(const Rectf&) { return RECTF_V; }

Rect RectC(int x, int y, int cx, int cy);
Rect16 Rect16C(int16 x, int16 y, int16 cx, int16 cy);
Rectf RectfC(double x, double y, double cx, double cy);

inline Size& operator*=(Size& sz, double a)
{
 sz.cx = int(sz.cx * a);
 sz.cy = int(sz.cy * a);
 return sz;
}

inline Size& operator/=(Size& sz, double a)
{
 sz.cx = int(sz.cx / a);
 sz.cy = int(sz.cy / a);
 return sz;
}

inline Size& operator*=(Size& sz, Sizef a)
{
 sz.cx = int(sz.cx * a.cx);
 sz.cy = int(sz.cy * a.cy);
 return sz;
}

inline Size& operator/=(Size& sz, Sizef a)
{
 sz.cx = int(sz.cx / a.cx);
 sz.cy = int(sz.cy / a.cy);
 return sz;
}

inline Sizef operator*(Size sz, double a) { return Sizef(sz.cx * a, sz.cy * a); }
inline Sizef operator*(double a, Size sz) { return Sizef(sz.cx * a, sz.cy * a); }
inline Sizef operator/(Size sz, double a) { return Sizef(sz.cx / a, sz.cy / a); }
inline Sizef operator*(Size sz, Sizef a) { return Sizef(sz.cx * a.cx, sz.cy * a.cy); }
inline Sizef operator*(Sizef a, Size sz) { return Sizef(sz.cx * a.cx, sz.cy * a.cy); }
inline Sizef operator/(Size sz, Sizef a) { return Sizef(sz.cx / a.cx, sz.cy / a.cy); }

inline Size16& operator*=(Size16& sz, double a)
{
 sz.cx = int16(sz.cx * a);
 sz.cy = int16(sz.cy * a);
 return sz;
}

inline Size16& operator/=(Size16& sz, double a)
{
 sz.cx = int16(sz.cx / a);
 sz.cy = int16(sz.cy / a);
 return sz;
}

inline Size16& operator*=(Size16& sz, Sizef a)
{
 sz.cx = int16(sz.cx * a.cx);
 sz.cy = int16(sz.cy * a.cy);
 return sz;
}

inline Size16& operator/=(Size16& sz, Sizef a)
{
 sz.cx = int16(sz.cx / a.cx);
 sz.cy = int16(sz.cy / a.cy);
 return sz;
}

inline Sizef operator*(Size16 sz, double a) { return Sizef(sz.cx * a, sz.cy * a); }
inline Sizef operator*(double a, Size16 sz) { return Sizef(sz.cx * a, sz.cy * a); }
inline Sizef operator/(Size16 sz, double a) { return Sizef(sz.cx / a, sz.cy / a); }
inline Sizef operator*(Size16 sz, Sizef a) { return Sizef(sz.cx * a.cx, sz.cy * a.cy); }
inline Sizef operator*(Sizef a, Size16 sz) { return Sizef(sz.cx * a.cx, sz.cy * a.cy); }
inline Sizef operator/(Size16 sz, Sizef a) { return Sizef(sz.cx / a.cx, sz.cy / a.cy); }

inline Rect RectC(int x, int y, int cx, int cy) {
 return Rect(x, y, x + cx, y + cy);
}

inline Rect16 Rect16C(int16 x, int16 y, int16 cx, int16 cy) {
 return Rect16(x, y, x + cx, y + cy);
}

inline Rectf RectfC(double x, double y, double cx, double cy) {
 return Rectf(x, y, x + cx, y + cy);
}

inline Rect RectSort(Point a, Point b) { return Rect(min(a, b), max(a, b) + 1); }
inline Rectf RectfSort(Pointf a, Pointf b) { return Rectf(min(a, b), max(a, b)); }

Stream& Pack16(Stream& s, Point& p);
Stream& Pack16(Stream& s, Size& sz);
Stream& Pack16(Stream& s, Rect& r);

Size iscale(Size a, int b, int c);
Size iscalefloor(Size a, int b, int c);
Size iscaleceil(Size a, int b, int c);
Size idivfloor(Size a, int b);
Size idivceil(Size a, int b);
Size iscale(Size a, Size b, Size c);
Size iscalefloor(Size a, Size b, Size c);
Size iscaleceil(Size a, Size b, Size c);
Size idivfloor(Size a, Size b);
Size idivceil(Size a, Size b);

enum Alignment {
 ALIGN_NULL,
 ALIGN_LEFT,
 ALIGN_TOP = ALIGN_LEFT,
 ALIGN_RIGHT,
 ALIGN_BOTTOM = ALIGN_RIGHT,
 ALIGN_CENTER,
 ALIGN_JUSTIFY,
};

Size GetRatioSize(Size stdsize, int cx, int cy);
Size GetFitSize(Size objsize, int cx, int cy);
inline Size GetFitSize(Size objsize, Size intosize) { return GetFitSize(objsize, intosize.cx, intosize.cy); }
# 382 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Color.h" 1

struct RGBA : Moveable<RGBA> {
        byte b, g, r, a;
};
# 26 "C:/upp/uppsrc/Core/Color.h"
const int COLOR_V = 39;

class Color : AssignValueTypeNo<Color, COLOR_V, Moveable<Color> > {
protected:
 dword color;

 dword Get() const;

public:
 static void SetStdColor(int i, dword color);
 static void SetStdColor(int i, Color color) { SetStdColor(i, color.color); }

 dword GetRaw() const { return color; }

 int GetR() const { return ((BYTE)(Get())); }
 int GetG() const { return ((BYTE)(((WORD)(Get()))>>8)); }
 int GetB() const { return ((BYTE)((Get())>>16)); }

 bool IsNullInstance() const { return color == 0xffffffff; }
 unsigned GetHashValue() const { return color; }
 bool operator==(Color c) const { return color == c.color; }
 bool operator!=(Color c) const { return color != c.color; }

 void Serialize(Stream& s) { s % color; }

 Color() { color = 0xffffffff; }
 Color(int r, int g, int b) { color = ((COLORREF)((BYTE)(r)|((BYTE)(g) << 8)|((BYTE)(b) << 16))); }
 Color(int n, int) { color = 0x80000000 | n; }

 Color(const Nuller&) { color = 0xffffffff; }

 operator Value() const { return RichValue<Color>(*this); }
 Color(const Value& q) { color = RichValue<Color>::Extract(q).color; }

 operator RGBA() const;
 Color(RGBA rgba);

 Color(Color (*fn)()) { color = (*fn)().color; }

 static Color FromRaw(dword co) { Color c; c.color = co; return c; }


 operator COLORREF() const { return (COLORREF) Get(); }
 static Color FromCR(COLORREF cr) { Color c; c.color = (dword)cr; return c; }



};

inline RGBA operator*(int alpha, Color c) { RGBA x = c; x.a = alpha; return x; }

typedef Color (*ColorF)();

inline unsigned GetHashValue(Color c) { return c.GetHashValue(); }
inline Color Nvl(Color a, Color b) { return IsNull(a) ? b : a; }

template<>
String AsString(const Color& c);


inline Color GrayColor(int a = 128) { return Color(a, a, a); }

inline Color Black() { return Color(0, 0, 0); }
inline Color Gray() { return Color(128, 128, 128); }
inline Color LtGray() { return Color(192, 192, 192); }
inline Color WhiteGray() { return Color(224, 224, 224); }
inline Color White() { return Color(255, 255, 255); }

inline Color Red() { return Color(128, 0, 0); }
inline Color Green() { return Color(0, 128, 0); }
inline Color Brown() { return Color(128, 128, 0); }
inline Color Blue() { return Color(0, 0, 128); }
inline Color Magenta() { return Color(128, 0, 255); }
inline Color Cyan() { return Color(0, 128, 128); }
inline Color Yellow() { return Color(255, 255, 0); }
inline Color LtRed() { return Color(255, 0, 0); }
inline Color LtGreen() { return Color(0, 255, 0); }
inline Color LtYellow() { return Color(255, 255, 192); }
inline Color LtBlue() { return Color(0, 0, 255); }
inline Color LtMagenta() { return Color(255, 0, 255); }
inline Color LtCyan() { return Color(0, 255, 255); }

void RGBtoHSV(double r, double g, double b, double& h, double& s, double& v);
void HSVtoRGB(double h, double s, double v, double& r, double& g, double& b);

Color HsvColorf(double h, double s, double v);

Color Blend(Color c1, Color c2, int alpha = 128);

String ColorToHtml(Color color);

inline bool operator==(const Value& v, Color x) { return v == x.operator Value(); }
inline bool operator==(Color x, const Value& v) { return v == x.operator Value(); }
inline bool operator!=(const Value& v, Color x) { return v != x.operator Value(); }
inline bool operator!=(Color x, const Value& v) { return v != x.operator Value(); }

inline bool operator==(const Value& v, Color (*x)()) { return v == (*x)(); }
inline bool operator==(Color (*x)(), const Value& v) { return v == (*x)(); }
inline bool operator!=(const Value& v, Color (*x)()) { return v != (*x)(); }
inline bool operator!=(Color (*x)(), const Value& v) { return v != (*x)(); }

inline bool operator==(Color c, Color (*x)()) { return c == (*x)(); }
inline bool operator==(Color (*x)(), Color c) { return c == (*x)(); }
inline bool operator!=(Color c, Color (*x)()) { return c != (*x)(); }
inline bool operator!=(Color (*x)(), Color c) { return c != (*x)(); }
# 383 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Uuid.h" 1
struct Uuid : AssignValueTypeNo<Uuid, 50, Moveable<Uuid> > {
 dword a, b, c, d;

 void Serialize(Stream& s);
 bool IsNull() const { return a == 0 && b == 0 && c == 0 && d == 0; }
 void SetNull() { a = b = c = d = 0; }

 operator Value() const { return RichValue<Uuid>(*this); }
 Uuid(const Value& q) { *this = RichValue<Uuid>::Extract(q); }
 Uuid(const Nuller&) { SetNull(); }
 Uuid() {}

 static Uuid Create();
};

String Format(const Uuid& id);

template<>
inline unsigned GetHashValue(const Uuid& u) { return u.a + u.b + u.c + u.d; }

inline bool operator==(const Uuid& u, const Uuid& w) {
 return u.a == w.a && u.b == w.b && u.c == w.c && u.d == w.d;
}

inline bool operator!=(const Uuid& u, const Uuid& w) {
 return !(u == w);
}

template<>
inline bool IsNull(const Uuid& id) { return id.IsNull(); }

template<>
inline String AsString(const Uuid& id) { return Format(id); }

ValueGen& UuidValueGen();
# 385 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Ptr.h" 1
template <class T> class Ptr;

class PteBase {
protected:
 struct Prec {
  PteBase *ptr;
  Atomic n;
 };

 volatile Prec *prec;

 Prec *PtrAdd();
 static void PtrRelease(Prec *prec);
 static Prec *PtrAdd(const Uuid& uuid);

 PteBase();
 ~PteBase();

 friend class PtrBase;
};

class PtrBase {
protected:
 PteBase::Prec *prec;
 void Set(PteBase *p);
 void Release();
 void Assign(PteBase *p);

public:
 ~PtrBase();
};

template <class T>
class Pte : public PteBase {
 friend class Ptr<T>;
};

template <class T>
class Ptr : public PtrBase, Moveable< Ptr<T> > {
 T *Get() const { return prec ? static_cast<T *>(prec->ptr) : __null; }

public:
 T *operator->() const { return Get(); }
 T *operator~() const { return Get(); }
 operator T*() const { return Get(); }

 Ptr& operator=(T *ptr) { Assign(ptr); return *this; }
 Ptr& operator=(const Ptr& ptr) { Assign(ptr.Get()); return *this; }

 Ptr() { prec = __null; }
 Ptr(T *ptr) { Set(ptr); }
 Ptr(const Ptr& ptr) { Set(ptr.Get()); }

 String ToString() const;

 friend bool operator==(const Ptr& a, const T *b) { return a.Get() == b; }
 friend bool operator==(const T *a, const Ptr& b) { return a == b.Get(); }
 friend bool operator==(const Ptr& a, const Ptr& b) { return a.prec == b.prec; }

 friend bool operator==(const Ptr& a, T *b) { return a.Get() == b; }
 friend bool operator==(T *a, const Ptr& b) { return a == b.Get(); }

 friend bool operator!=(const Ptr& a, const T *b) { return a.Get() != b; }
 friend bool operator!=(const T *a, const Ptr& b) { return a != b.Get(); }
 friend bool operator!=(const Ptr& a, const Ptr& b) { return a.prec != b.prec; }

 friend bool operator!=(const Ptr& a, T *b) { return a.Get() != b; }
 friend bool operator!=(T *a, const Ptr& b) { return a != b.Get(); }
};

template <class T>
String Ptr<T>::ToString() const
{
 return prec ? FormatPtr(Get()) : String("0x0");
}
# 386 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Callback.h" 1
enum _CNULL { CNULL };

template <class D, class S>
inline D brutal_cast(const S& source) { return *(D *)&source; }

# 1 "C:/upp/uppsrc/Core/Cbgen.h" 1




struct CallbackAction {
 Atomic count;

 virtual void Execute() = 0;
 virtual bool IsValid() const { return true; }

 CallbackAction() { count = 1; }
 virtual ~CallbackAction() {}
};

template <class OBJECT, class METHOD>
struct CallbackMethodActionPte : public CallbackAction {
 Ptr<OBJECT> object;
 METHOD method;

 void Execute() { if(object) (object->*method)(); }
 bool IsValid() const { return object; }

 CallbackMethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD>
struct CallbackMethodAction : public CallbackAction {
 OBJECT *object;
 METHOD method;

 void Execute() { (object->*method)(); }

 CallbackMethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

struct CallbackFnAction : public CallbackAction {
 void (*fn)();

 void Execute() { (*fn)(); }

 CallbackFnAction(void (*fn)()) : fn(fn) {}
};

class Callback : Moveable< Callback > {
 CallbackAction *action;

 void Retain() const { if(action ) AtomicInc(action->count); }
 void Release() { if(action && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Callback&);
 bool operator!=(const Callback&);

public:
 typedef Callback CLASSNAME;

 Callback& operator=(const Callback& c);
 Callback(const Callback& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return action && action->IsValid(); }
 void Execute() const;
 void operator()() const { Execute(); }

 explicit Callback(CallbackAction *newaction) { action = newaction; }
 Callback() { action = __null; }
 Callback(_CNULL) { action = __null; }
 ~Callback();

 static Callback Empty() { return CNULL; }

};

template <class OBJECT, class METHOD>
Callback pteback(OBJECT *object, void (METHOD::*method)()) {
 return Callback(new CallbackMethodActionPte<OBJECT, void (METHOD::*)()>(object, method));
}

template <class OBJECT, class METHOD>
Callback callback(OBJECT *object, void (METHOD::*method)()) {
 return Callback(new CallbackMethodAction<OBJECT, void (METHOD::*)()>(object, method));
}

template <class OBJECT, class METHOD>
Callback callback(const OBJECT *object, void (METHOD::*method)() const) {
 return Callback(new CallbackMethodAction<const OBJECT, void (METHOD::*)() const>(object, method));
}

inline Callback callback(void (*fn)()) {
 return Callback(new CallbackFnAction (fn));
}

struct CallbackForkAction : public CallbackAction {
 Callback cb1, cb2;

 void Execute() { cb1(); cb2(); }

 CallbackForkAction(Callback cb1, Callback cb2)
   : cb1(cb1), cb2(cb2) {}
};

inline Callback Proxy(Callback& cb)
{
 return callback(&cb, &Callback::Execute);
}

Callback callback(Callback cb1, Callback cb2);
Callback& operator<<(Callback& a, Callback b);
# 151 "C:/upp/uppsrc/Core/Cbgen.h"
template <class P1>
struct Callback1Action {
 Atomic count;

 virtual void Execute(P1 p1) = 0;
 virtual bool IsValid() const { return true; }

 Callback1Action() { count = 1; }
 virtual ~Callback1Action() {}
};

template <class OBJECT, class METHOD, class P1>
struct Callback1MethodActionPte : public Callback1Action<P1> {
 Ptr<OBJECT> object;
 METHOD method;

 void Execute(P1 p1) { if(object) (object->*method)(p1); }
 bool IsValid() const { return object; }

 Callback1MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1>
struct Callback1MethodAction : public Callback1Action<P1> {
 OBJECT *object;
 METHOD method;

 void Execute(P1 p1) { (object->*method)(p1); }

 Callback1MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1>
struct Callback1FnAction : public Callback1Action<P1> {
 void (*fn)(P1 p1);

 void Execute(P1 p1) { (*fn)(p1); }

 Callback1FnAction(void (*fn)(P1 p1)) : fn(fn) {}
};

template <class P1>
class Callback1 : Moveable< Callback1<P1> > {
 Callback1Action<P1> *action;

 void Retain() const { if(action ) AtomicInc(action->count); }
 void Release() { if(action && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Callback1&);
 bool operator!=(const Callback1&);

public:
 typedef Callback1 CLASSNAME;

 Callback1& operator=(const Callback1& c);
 Callback1(const Callback1& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return action && action->IsValid(); }
 void Execute(P1 p1) const { if(action) action->Execute(p1); }
 void operator()(P1 p1) const { Execute(p1); }

 explicit Callback1(Callback1Action <P1> *newaction) { action = newaction; }
 Callback1() { action = __null; }
 Callback1(_CNULL) { action = __null; }
 ~Callback1();

 static Callback1 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1>
Callback1<P1> pteback(OBJECT *object, void (METHOD::*method)(P1 p1)) {
 return Callback1<P1>(new Callback1MethodActionPte<OBJECT, void (METHOD::*)(P1 p1), P1>(object, method));
}

template <class OBJECT, class METHOD, class P1>
Callback1<P1> callback(OBJECT *object, void (METHOD::*method)(P1 p1)) {
 return Callback1<P1>(new Callback1MethodAction<OBJECT, void (METHOD::*)(P1 p1), P1>(object, method));
}

template <class OBJECT, class METHOD, class P1>
Callback1<P1> callback(const OBJECT *object, void (METHOD::*method)(P1 p1) const) {
 return Callback1<P1>(new Callback1MethodAction<const OBJECT, void (METHOD::*)(P1 p1) const, P1>(object, method));
}

template <class P1>
inline Callback1<P1> callback(void (*fn)(P1 p1)) {
 return Callback1<P1>(new Callback1FnAction <P1>(fn));
}

template <class P1>
struct Callback1ForkAction : public Callback1Action<P1> {
 Callback1<P1> cb1, cb2;

 void Execute(P1 p1) { cb1(p1); cb2(p1); }

 Callback1ForkAction(Callback1<P1> cb1, Callback1<P1> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1>
inline Callback1<P1> Proxy(Callback1<P1>& cb)
{
 return callback(&cb, &Callback1<P1>::Execute);
}

template <class P1>
Callback1<P1> callback(Callback1<P1> cb1, Callback1<P1> cb2)
{
 return Callback1<P1>(new Callback1ForkAction <P1>(cb1, cb2));
}

template <class P1>
Callback1<P1>& operator<<(Callback1<P1>& a, Callback1<P1> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1>
Callback1<P1>& Callback1<P1>::operator=(const Callback1& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1>
Callback1<P1>::Callback1(const Callback1& c)
{
 action = c.action;
 Retain();
}

template <class P1>
Callback1<P1>::~Callback1()
{
 Release();
}



template <class P1, class P2>
struct Callback2Action {
 Atomic count;

 virtual void Execute(P1 p1, P2 p2) = 0;
 virtual bool IsValid() const { return true; }

 Callback2Action() { count = 1; }
 virtual ~Callback2Action() {}
};

template <class OBJECT, class METHOD, class P1, class P2>
struct Callback2MethodActionPte : public Callback2Action<P1, P2> {
 Ptr<OBJECT> object;
 METHOD method;

 void Execute(P1 p1, P2 p2) { if(object) (object->*method)(p1, p2); }
 bool IsValid() const { return object; }

 Callback2MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1, class P2>
struct Callback2MethodAction : public Callback2Action<P1, P2> {
 OBJECT *object;
 METHOD method;

 void Execute(P1 p1, P2 p2) { (object->*method)(p1, p2); }

 Callback2MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1, class P2>
struct Callback2FnAction : public Callback2Action<P1, P2> {
 void (*fn)(P1 p1, P2 p2);

 void Execute(P1 p1, P2 p2) { (*fn)(p1, p2); }

 Callback2FnAction(void (*fn)(P1 p1, P2 p2)) : fn(fn) {}
};

template <class P1, class P2>
class Callback2 : Moveable< Callback2<P1, P2> > {
 Callback2Action<P1, P2> *action;

 void Retain() const { if(action ) AtomicInc(action->count); }
 void Release() { if(action && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Callback2&);
 bool operator!=(const Callback2&);

public:
 typedef Callback2 CLASSNAME;

 Callback2& operator=(const Callback2& c);
 Callback2(const Callback2& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return action && action->IsValid(); }
 void Execute(P1 p1, P2 p2) const { if(action) action->Execute(p1, p2); }
 void operator()(P1 p1, P2 p2) const { Execute(p1, p2); }

 explicit Callback2(Callback2Action <P1, P2> *newaction) { action = newaction; }
 Callback2() { action = __null; }
 Callback2(_CNULL) { action = __null; }
 ~Callback2();

 static Callback2 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1, class P2>
Callback2<P1, P2> pteback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2)) {
 return Callback2<P1, P2>(new Callback2MethodActionPte<OBJECT, void (METHOD::*)(P1 p1, P2 p2), P1, P2>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2>
Callback2<P1, P2> callback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2)) {
 return Callback2<P1, P2>(new Callback2MethodAction<OBJECT, void (METHOD::*)(P1 p1, P2 p2), P1, P2>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2>
Callback2<P1, P2> callback(const OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2) const) {
 return Callback2<P1, P2>(new Callback2MethodAction<const OBJECT, void (METHOD::*)(P1 p1, P2 p2) const, P1, P2>(object, method));
}

template <class P1, class P2>
inline Callback2<P1, P2> callback(void (*fn)(P1 p1, P2 p2)) {
 return Callback2<P1, P2>(new Callback2FnAction <P1, P2>(fn));
}

template <class P1, class P2>
struct Callback2ForkAction : public Callback2Action<P1, P2> {
 Callback2<P1, P2> cb1, cb2;

 void Execute(P1 p1, P2 p2) { cb1(p1, p2); cb2(p1, p2); }

 Callback2ForkAction(Callback2<P1, P2> cb1, Callback2<P1, P2> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1, class P2>
inline Callback2<P1, P2> Proxy(Callback2<P1, P2>& cb)
{
 return callback(&cb, &Callback2<P1, P2>::Execute);
}

template <class P1, class P2>
Callback2<P1, P2> callback(Callback2<P1, P2> cb1, Callback2<P1, P2> cb2)
{
 return Callback2<P1, P2>(new Callback2ForkAction <P1, P2>(cb1, cb2));
}

template <class P1, class P2>
Callback2<P1, P2>& operator<<(Callback2<P1, P2>& a, Callback2<P1, P2> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1, class P2>
Callback2<P1, P2>& Callback2<P1, P2>::operator=(const Callback2& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1, class P2>
Callback2<P1, P2>::Callback2(const Callback2& c)
{
 action = c.action;
 Retain();
}

template <class P1, class P2>
Callback2<P1, P2>::~Callback2()
{
 Release();
}



template <class P1, class P2, class P3>
struct Callback3Action {
 Atomic count;

 virtual void Execute(P1 p1, P2 p2, P3 p3) = 0;
 virtual bool IsValid() const { return true; }

 Callback3Action() { count = 1; }
 virtual ~Callback3Action() {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
struct Callback3MethodActionPte : public Callback3Action<P1, P2, P3> {
 Ptr<OBJECT> object;
 METHOD method;

 void Execute(P1 p1, P2 p2, P3 p3) { if(object) (object->*method)(p1, p2, p3); }
 bool IsValid() const { return object; }

 Callback3MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
struct Callback3MethodAction : public Callback3Action<P1, P2, P3> {
 OBJECT *object;
 METHOD method;

 void Execute(P1 p1, P2 p2, P3 p3) { (object->*method)(p1, p2, p3); }

 Callback3MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1, class P2, class P3>
struct Callback3FnAction : public Callback3Action<P1, P2, P3> {
 void (*fn)(P1 p1, P2 p2, P3 p3);

 void Execute(P1 p1, P2 p2, P3 p3) { (*fn)(p1, p2, p3); }

 Callback3FnAction(void (*fn)(P1 p1, P2 p2, P3 p3)) : fn(fn) {}
};

template <class P1, class P2, class P3>
class Callback3 : Moveable< Callback3<P1, P2, P3> > {
 Callback3Action<P1, P2, P3> *action;

 void Retain() const { if(action ) AtomicInc(action->count); }
 void Release() { if(action && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Callback3&);
 bool operator!=(const Callback3&);

public:
 typedef Callback3 CLASSNAME;

 Callback3& operator=(const Callback3& c);
 Callback3(const Callback3& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return action && action->IsValid(); }
 void Execute(P1 p1, P2 p2, P3 p3) const { if(action) action->Execute(p1, p2, p3); }
 void operator()(P1 p1, P2 p2, P3 p3) const { Execute(p1, p2, p3); }

 explicit Callback3(Callback3Action <P1, P2, P3> *newaction) { action = newaction; }
 Callback3() { action = __null; }
 Callback3(_CNULL) { action = __null; }
 ~Callback3();

 static Callback3 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Callback3<P1, P2, P3> pteback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3)) {
 return Callback3<P1, P2, P3>(new Callback3MethodActionPte<OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3), P1, P2, P3>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Callback3<P1, P2, P3> callback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3)) {
 return Callback3<P1, P2, P3>(new Callback3MethodAction<OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3), P1, P2, P3>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Callback3<P1, P2, P3> callback(const OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3) const) {
 return Callback3<P1, P2, P3>(new Callback3MethodAction<const OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3) const, P1, P2, P3>(object, method));
}

template <class P1, class P2, class P3>
inline Callback3<P1, P2, P3> callback(void (*fn)(P1 p1, P2 p2, P3 p3)) {
 return Callback3<P1, P2, P3>(new Callback3FnAction <P1, P2, P3>(fn));
}

template <class P1, class P2, class P3>
struct Callback3ForkAction : public Callback3Action<P1, P2, P3> {
 Callback3<P1, P2, P3> cb1, cb2;

 void Execute(P1 p1, P2 p2, P3 p3) { cb1(p1, p2, p3); cb2(p1, p2, p3); }

 Callback3ForkAction(Callback3<P1, P2, P3> cb1, Callback3<P1, P2, P3> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1, class P2, class P3>
inline Callback3<P1, P2, P3> Proxy(Callback3<P1, P2, P3>& cb)
{
 return callback(&cb, &Callback3<P1, P2, P3>::Execute);
}

template <class P1, class P2, class P3>
Callback3<P1, P2, P3> callback(Callback3<P1, P2, P3> cb1, Callback3<P1, P2, P3> cb2)
{
 return Callback3<P1, P2, P3>(new Callback3ForkAction <P1, P2, P3>(cb1, cb2));
}

template <class P1, class P2, class P3>
Callback3<P1, P2, P3>& operator<<(Callback3<P1, P2, P3>& a, Callback3<P1, P2, P3> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1, class P2, class P3>
Callback3<P1, P2, P3>& Callback3<P1, P2, P3>::operator=(const Callback3& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1, class P2, class P3>
Callback3<P1, P2, P3>::Callback3(const Callback3& c)
{
 action = c.action;
 Retain();
}

template <class P1, class P2, class P3>
Callback3<P1, P2, P3>::~Callback3()
{
 Release();
}



template <class P1, class P2, class P3, class P4>
struct Callback4Action {
 Atomic count;

 virtual void Execute(P1 p1, P2 p2, P3 p3, P4 p4) = 0;
 virtual bool IsValid() const { return true; }

 Callback4Action() { count = 1; }
 virtual ~Callback4Action() {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3, class P4>
struct Callback4MethodActionPte : public Callback4Action<P1, P2, P3, P4> {
 Ptr<OBJECT> object;
 METHOD method;

 void Execute(P1 p1, P2 p2, P3 p3, P4 p4) { if(object) (object->*method)(p1, p2, p3, p4); }
 bool IsValid() const { return object; }

 Callback4MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3, class P4>
struct Callback4MethodAction : public Callback4Action<P1, P2, P3, P4> {
 OBJECT *object;
 METHOD method;

 void Execute(P1 p1, P2 p2, P3 p3, P4 p4) { (object->*method)(p1, p2, p3, p4); }

 Callback4MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1, class P2, class P3, class P4>
struct Callback4FnAction : public Callback4Action<P1, P2, P3, P4> {
 void (*fn)(P1 p1, P2 p2, P3 p3, P4 p4);

 void Execute(P1 p1, P2 p2, P3 p3, P4 p4) { (*fn)(p1, p2, p3, p4); }

 Callback4FnAction(void (*fn)(P1 p1, P2 p2, P3 p3, P4 p4)) : fn(fn) {}
};

template <class P1, class P2, class P3, class P4>
class Callback4 : Moveable< Callback4<P1, P2, P3, P4> > {
 Callback4Action<P1, P2, P3, P4> *action;

 void Retain() const { if(action ) AtomicInc(action->count); }
 void Release() { if(action && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Callback4&);
 bool operator!=(const Callback4&);

public:
 typedef Callback4 CLASSNAME;

 Callback4& operator=(const Callback4& c);
 Callback4(const Callback4& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return action && action->IsValid(); }
 void Execute(P1 p1, P2 p2, P3 p3, P4 p4) const { if(action) action->Execute(p1, p2, p3, p4); }
 void operator()(P1 p1, P2 p2, P3 p3, P4 p4) const { Execute(p1, p2, p3, p4); }

 explicit Callback4(Callback4Action <P1, P2, P3, P4> *newaction) { action = newaction; }
 Callback4() { action = __null; }
 Callback4(_CNULL) { action = __null; }
 ~Callback4();

 static Callback4 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4> pteback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3, P4 p4)) {
 return Callback4<P1, P2, P3, P4>(new Callback4MethodActionPte<OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3, P4 p4), P1, P2, P3, P4>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4> callback(OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3, P4 p4)) {
 return Callback4<P1, P2, P3, P4>(new Callback4MethodAction<OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3, P4 p4), P1, P2, P3, P4>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4> callback(const OBJECT *object, void (METHOD::*method)(P1 p1, P2 p2, P3 p3, P4 p4) const) {
 return Callback4<P1, P2, P3, P4>(new Callback4MethodAction<const OBJECT, void (METHOD::*)(P1 p1, P2 p2, P3 p3, P4 p4) const, P1, P2, P3, P4>(object, method));
}

template <class P1, class P2, class P3, class P4>
inline Callback4<P1, P2, P3, P4> callback(void (*fn)(P1 p1, P2 p2, P3 p3, P4 p4)) {
 return Callback4<P1, P2, P3, P4>(new Callback4FnAction <P1, P2, P3, P4>(fn));
}

template <class P1, class P2, class P3, class P4>
struct Callback4ForkAction : public Callback4Action<P1, P2, P3, P4> {
 Callback4<P1, P2, P3, P4> cb1, cb2;

 void Execute(P1 p1, P2 p2, P3 p3, P4 p4) { cb1(p1, p2, p3, p4); cb2(p1, p2, p3, p4); }

 Callback4ForkAction(Callback4<P1, P2, P3, P4> cb1, Callback4<P1, P2, P3, P4> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1, class P2, class P3, class P4>
inline Callback4<P1, P2, P3, P4> Proxy(Callback4<P1, P2, P3, P4>& cb)
{
 return callback(&cb, &Callback4<P1, P2, P3, P4>::Execute);
}

template <class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4> callback(Callback4<P1, P2, P3, P4> cb1, Callback4<P1, P2, P3, P4> cb2)
{
 return Callback4<P1, P2, P3, P4>(new Callback4ForkAction <P1, P2, P3, P4>(cb1, cb2));
}

template <class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4>& operator<<(Callback4<P1, P2, P3, P4>& a, Callback4<P1, P2, P3, P4> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4>& Callback4<P1, P2, P3, P4>::operator=(const Callback4& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4>::Callback4(const Callback4& c)
{
 action = c.action;
 Retain();
}

template <class P1, class P2, class P3, class P4>
Callback4<P1, P2, P3, P4>::~Callback4()
{
 Release();
}



struct GateAction {
 Atomic count;

 virtual bool Execute() = 0;
 virtual bool IsValid() const { return true; }

 GateAction() { count = 1; }
 virtual ~GateAction() {}
};

template <class OBJECT, class METHOD>
struct GateMethodActionPte : public GateAction {
 Ptr<OBJECT> object;
 METHOD method;

 bool Execute() { return object ? (object->*method)() : false; }
 bool IsValid() const { return object; }

 GateMethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD>
struct GateMethodAction : public GateAction {
 OBJECT *object;
 METHOD method;

 bool Execute() { return (object->*method)(); }

 GateMethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

struct GateFnAction : public GateAction {
 bool (*fn)();

 bool Execute() { return (*fn)(); }

 GateFnAction(bool (*fn)()) : fn(fn) {}
};

class Gate : Moveable< Gate > {
 GateAction *action;

 void Retain() const { if(action && (void *)action != (void *)1) AtomicInc(action->count); }
 void Release() { if(action && (void *)action != (void *)1 && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Gate&);
 bool operator!=(const Gate&);

public:
 typedef Gate CLASSNAME;

 Gate& operator=(const Gate& c);
 Gate(const Gate& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return (void *)action != (void *)1 && action && action->IsValid(); }
 bool Execute() const;
 bool operator()() const { return Execute(); }
 void ClearTrue() { Clear(); action = (GateAction *)1; }
 void ClearFalse() { Clear(); }

 Gate(bool b) { action = (GateAction *)(int)b; }

 explicit Gate(GateAction *newaction) { action = newaction; }
 Gate() { action = __null; }
 Gate(_CNULL) { action = __null; }
 ~Gate();

 static Gate Empty() { return CNULL; }

};

template <class OBJECT, class METHOD>
Gate pteback(OBJECT *object, bool (METHOD::*method)()) {
 return Gate(new GateMethodActionPte<OBJECT, bool (METHOD::*)()>(object, method));
}

template <class OBJECT, class METHOD>
Gate callback(OBJECT *object, bool (METHOD::*method)()) {
 return Gate(new GateMethodAction<OBJECT, bool (METHOD::*)()>(object, method));
}

template <class OBJECT, class METHOD>
Gate callback(const OBJECT *object, bool (METHOD::*method)() const) {
 return Gate(new GateMethodAction<const OBJECT, bool (METHOD::*)() const>(object, method));
}

inline Gate callback(bool (*fn)()) {
 return Gate(new GateFnAction (fn));
}

struct GateForkAction : public GateAction {
 Gate cb1, cb2;

 bool Execute() { cb1(); return cb2(); }

 GateForkAction(Gate cb1, Gate cb2)
   : cb1(cb1), cb2(cb2) {}
};

inline Gate Proxy(Gate& cb)
{
 return callback(&cb, &Gate::Execute);
}

Gate callback(Gate cb1, Gate cb2);
Gate& operator<<(Gate& a, Gate b);
# 893 "C:/upp/uppsrc/Core/Cbgen.h"
template <class P1>
struct Gate1Action {
 Atomic count;

 virtual bool Execute(P1 p1) = 0;
 virtual bool IsValid() const { return true; }

 Gate1Action() { count = 1; }
 virtual ~Gate1Action() {}
};

template <class OBJECT, class METHOD, class P1>
struct Gate1MethodActionPte : public Gate1Action<P1> {
 Ptr<OBJECT> object;
 METHOD method;

 bool Execute(P1 p1) { return object ? (object->*method)(p1) : false; }
 bool IsValid() const { return object; }

 Gate1MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1>
struct Gate1MethodAction : public Gate1Action<P1> {
 OBJECT *object;
 METHOD method;

 bool Execute(P1 p1) { return (object->*method)(p1); }

 Gate1MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1>
struct Gate1FnAction : public Gate1Action<P1> {
 bool (*fn)(P1 p1);

 bool Execute(P1 p1) { return (*fn)(p1); }

 Gate1FnAction(bool (*fn)(P1 p1)) : fn(fn) {}
};

template <class P1>
class Gate1 : Moveable< Gate1<P1> > {
 Gate1Action<P1> *action;

 void Retain() const { if(action && (void *)action != (void *)1) AtomicInc(action->count); }
 void Release() { if(action && (void *)action != (void *)1 && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Gate1&);
 bool operator!=(const Gate1&);

public:
 typedef Gate1 CLASSNAME;

 Gate1& operator=(const Gate1& c);
 Gate1(const Gate1& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return (void *)action != (void *)1 && action && action->IsValid(); }
 bool Execute(P1 p1) const;
 bool operator()(P1 p1) const { return Execute(p1); }
 void ClearTrue() { Clear(); action = (Gate1Action<P1> *)1; }
 void ClearFalse() { Clear(); }

 Gate1(bool b) { action = (Gate1Action<P1> *)(int)b; }

 explicit Gate1(Gate1Action <P1> *newaction) { action = newaction; }
 Gate1() { action = __null; }
 Gate1(_CNULL) { action = __null; }
 ~Gate1();

 static Gate1 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1>
Gate1<P1> pteback(OBJECT *object, bool (METHOD::*method)(P1 p1)) {
 return Gate1<P1>(new Gate1MethodActionPte<OBJECT, bool (METHOD::*)(P1 p1), P1>(object, method));
}

template <class OBJECT, class METHOD, class P1>
Gate1<P1> callback(OBJECT *object, bool (METHOD::*method)(P1 p1)) {
 return Gate1<P1>(new Gate1MethodAction<OBJECT, bool (METHOD::*)(P1 p1), P1>(object, method));
}

template <class OBJECT, class METHOD, class P1>
Gate1<P1> callback(const OBJECT *object, bool (METHOD::*method)(P1 p1) const) {
 return Gate1<P1>(new Gate1MethodAction<const OBJECT, bool (METHOD::*)(P1 p1) const, P1>(object, method));
}

template <class P1>
inline Gate1<P1> callback(bool (*fn)(P1 p1)) {
 return Gate1<P1>(new Gate1FnAction <P1>(fn));
}

template <class P1>
struct Gate1ForkAction : public Gate1Action<P1> {
 Gate1<P1> cb1, cb2;

 bool Execute(P1 p1) { cb1(p1); return cb2(p1); }

 Gate1ForkAction(Gate1<P1> cb1, Gate1<P1> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1>
inline Gate1<P1> Proxy(Gate1<P1>& cb)
{
 return callback(&cb, &Gate1<P1>::Execute);
}

template <class P1>
Gate1<P1> callback(Gate1<P1> cb1, Gate1<P1> cb2)
{
 return Gate1<P1>(new Gate1ForkAction <P1>(cb1, cb2));
}

template <class P1>
Gate1<P1>& operator<<(Gate1<P1>& a, Gate1<P1> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1>
Gate1<P1>& Gate1<P1>::operator=(const Gate1& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1>
Gate1<P1>::Gate1(const Gate1& c)
{
 action = c.action;
 Retain();
}

template <class P1>
Gate1<P1>::~Gate1()
{
 Release();
}



template <class P1, class P2>
struct Gate2Action {
 Atomic count;

 virtual bool Execute(P1 p1, P2 p2) = 0;
 virtual bool IsValid() const { return true; }

 Gate2Action() { count = 1; }
 virtual ~Gate2Action() {}
};

template <class OBJECT, class METHOD, class P1, class P2>
struct Gate2MethodActionPte : public Gate2Action<P1, P2> {
 Ptr<OBJECT> object;
 METHOD method;

 bool Execute(P1 p1, P2 p2) { return object ? (object->*method)(p1, p2) : false; }
 bool IsValid() const { return object; }

 Gate2MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1, class P2>
struct Gate2MethodAction : public Gate2Action<P1, P2> {
 OBJECT *object;
 METHOD method;

 bool Execute(P1 p1, P2 p2) { return (object->*method)(p1, p2); }

 Gate2MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1, class P2>
struct Gate2FnAction : public Gate2Action<P1, P2> {
 bool (*fn)(P1 p1, P2 p2);

 bool Execute(P1 p1, P2 p2) { return (*fn)(p1, p2); }

 Gate2FnAction(bool (*fn)(P1 p1, P2 p2)) : fn(fn) {}
};

template <class P1, class P2>
class Gate2 : Moveable< Gate2<P1, P2> > {
 Gate2Action<P1, P2> *action;

 void Retain() const { if(action && (void *)action != (void *)1) AtomicInc(action->count); }
 void Release() { if(action && (void *)action != (void *)1 && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Gate2&);
 bool operator!=(const Gate2&);

public:
 typedef Gate2 CLASSNAME;

 Gate2& operator=(const Gate2& c);
 Gate2(const Gate2& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return (void *)action != (void *)1 && action && action->IsValid(); }
 bool Execute(P1 p1, P2 p2) const;
 bool operator()(P1 p1, P2 p2) const { return Execute(p1, p2); }
 void ClearTrue() { Clear(); action = (Gate2Action<P1, P2> *)1; }
 void ClearFalse() { Clear(); }

 Gate2(bool b) { action = (Gate2Action<P1, P2> *)(int)b; }

 explicit Gate2(Gate2Action <P1, P2> *newaction) { action = newaction; }
 Gate2() { action = __null; }
 Gate2(_CNULL) { action = __null; }
 ~Gate2();

 static Gate2 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1, class P2>
Gate2<P1, P2> pteback(OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2)) {
 return Gate2<P1, P2>(new Gate2MethodActionPte<OBJECT, bool (METHOD::*)(P1 p1, P2 p2), P1, P2>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2>
Gate2<P1, P2> callback(OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2)) {
 return Gate2<P1, P2>(new Gate2MethodAction<OBJECT, bool (METHOD::*)(P1 p1, P2 p2), P1, P2>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2>
Gate2<P1, P2> callback(const OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2) const) {
 return Gate2<P1, P2>(new Gate2MethodAction<const OBJECT, bool (METHOD::*)(P1 p1, P2 p2) const, P1, P2>(object, method));
}

template <class P1, class P2>
inline Gate2<P1, P2> callback(bool (*fn)(P1 p1, P2 p2)) {
 return Gate2<P1, P2>(new Gate2FnAction <P1, P2>(fn));
}

template <class P1, class P2>
struct Gate2ForkAction : public Gate2Action<P1, P2> {
 Gate2<P1, P2> cb1, cb2;

 bool Execute(P1 p1, P2 p2) { cb1(p1, p2); return cb2(p1, p2); }

 Gate2ForkAction(Gate2<P1, P2> cb1, Gate2<P1, P2> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1, class P2>
inline Gate2<P1, P2> Proxy(Gate2<P1, P2>& cb)
{
 return callback(&cb, &Gate2<P1, P2>::Execute);
}

template <class P1, class P2>
Gate2<P1, P2> callback(Gate2<P1, P2> cb1, Gate2<P1, P2> cb2)
{
 return Gate2<P1, P2>(new Gate2ForkAction <P1, P2>(cb1, cb2));
}

template <class P1, class P2>
Gate2<P1, P2>& operator<<(Gate2<P1, P2>& a, Gate2<P1, P2> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1, class P2>
Gate2<P1, P2>& Gate2<P1, P2>::operator=(const Gate2& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1, class P2>
Gate2<P1, P2>::Gate2(const Gate2& c)
{
 action = c.action;
 Retain();
}

template <class P1, class P2>
Gate2<P1, P2>::~Gate2()
{
 Release();
}



template <class P1, class P2, class P3>
struct Gate3Action {
 Atomic count;

 virtual bool Execute(P1 p1, P2 p2, P3 p3) = 0;
 virtual bool IsValid() const { return true; }

 Gate3Action() { count = 1; }
 virtual ~Gate3Action() {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
struct Gate3MethodActionPte : public Gate3Action<P1, P2, P3> {
 Ptr<OBJECT> object;
 METHOD method;

 bool Execute(P1 p1, P2 p2, P3 p3) { return object ? (object->*method)(p1, p2, p3) : false; }
 bool IsValid() const { return object; }

 Gate3MethodActionPte(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
struct Gate3MethodAction : public Gate3Action<P1, P2, P3> {
 OBJECT *object;
 METHOD method;

 bool Execute(P1 p1, P2 p2, P3 p3) { return (object->*method)(p1, p2, p3); }

 Gate3MethodAction(OBJECT *object, METHOD method) : object(object), method(method) {}
};

template <class P1, class P2, class P3>
struct Gate3FnAction : public Gate3Action<P1, P2, P3> {
 bool (*fn)(P1 p1, P2 p2, P3 p3);

 bool Execute(P1 p1, P2 p2, P3 p3) { return (*fn)(p1, p2, p3); }

 Gate3FnAction(bool (*fn)(P1 p1, P2 p2, P3 p3)) : fn(fn) {}
};

template <class P1, class P2, class P3>
class Gate3 : Moveable< Gate3<P1, P2, P3> > {
 Gate3Action<P1, P2, P3> *action;

 void Retain() const { if(action && (void *)action != (void *)1) AtomicInc(action->count); }
 void Release() { if(action && (void *)action != (void *)1 && AtomicDec(action->count) == 0) delete action; }

 bool operator==(const Gate3&);
 bool operator!=(const Gate3&);

public:
 typedef Gate3 CLASSNAME;

 Gate3& operator=(const Gate3& c);
 Gate3(const Gate3& c);
 void Clear() { Release(); action = __null; }


 operator bool() const { return (void *)action != (void *)1 && action && action->IsValid(); }
 bool Execute(P1 p1, P2 p2, P3 p3) const;
 bool operator()(P1 p1, P2 p2, P3 p3) const { return Execute(p1, p2, p3); }
 void ClearTrue() { Clear(); action = (Gate3Action<P1, P2, P3> *)1; }
 void ClearFalse() { Clear(); }

 Gate3(bool b) { action = (Gate3Action<P1, P2, P3> *)(int)b; }

 explicit Gate3(Gate3Action <P1, P2, P3> *newaction) { action = newaction; }
 Gate3() { action = __null; }
 Gate3(_CNULL) { action = __null; }
 ~Gate3();

 static Gate3 Empty() { return CNULL; }

};

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Gate3<P1, P2, P3> pteback(OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2, P3 p3)) {
 return Gate3<P1, P2, P3>(new Gate3MethodActionPte<OBJECT, bool (METHOD::*)(P1 p1, P2 p2, P3 p3), P1, P2, P3>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Gate3<P1, P2, P3> callback(OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2, P3 p3)) {
 return Gate3<P1, P2, P3>(new Gate3MethodAction<OBJECT, bool (METHOD::*)(P1 p1, P2 p2, P3 p3), P1, P2, P3>(object, method));
}

template <class OBJECT, class METHOD, class P1, class P2, class P3>
Gate3<P1, P2, P3> callback(const OBJECT *object, bool (METHOD::*method)(P1 p1, P2 p2, P3 p3) const) {
 return Gate3<P1, P2, P3>(new Gate3MethodAction<const OBJECT, bool (METHOD::*)(P1 p1, P2 p2, P3 p3) const, P1, P2, P3>(object, method));
}

template <class P1, class P2, class P3>
inline Gate3<P1, P2, P3> callback(bool (*fn)(P1 p1, P2 p2, P3 p3)) {
 return Gate3<P1, P2, P3>(new Gate3FnAction <P1, P2, P3>(fn));
}

template <class P1, class P2, class P3>
struct Gate3ForkAction : public Gate3Action<P1, P2, P3> {
 Gate3<P1, P2, P3> cb1, cb2;

 bool Execute(P1 p1, P2 p2, P3 p3) { cb1(p1, p2, p3); return cb2(p1, p2, p3); }

 Gate3ForkAction(Gate3<P1, P2, P3> cb1, Gate3<P1, P2, P3> cb2)
   : cb1(cb1), cb2(cb2) {}
};

template <class P1, class P2, class P3>
inline Gate3<P1, P2, P3> Proxy(Gate3<P1, P2, P3>& cb)
{
 return callback(&cb, &Gate3<P1, P2, P3>::Execute);
}

template <class P1, class P2, class P3>
Gate3<P1, P2, P3> callback(Gate3<P1, P2, P3> cb1, Gate3<P1, P2, P3> cb2)
{
 return Gate3<P1, P2, P3>(new Gate3ForkAction <P1, P2, P3>(cb1, cb2));
}

template <class P1, class P2, class P3>
Gate3<P1, P2, P3>& operator<<(Gate3<P1, P2, P3>& a, Gate3<P1, P2, P3> b)
{
 if(a)
  a = callback(a, b);
 else
  a = b;
 return a;
}

template <class P1, class P2, class P3>
Gate3<P1, P2, P3>& Gate3<P1, P2, P3>::operator=(const Gate3& c)
{
 c.Retain();
 Release();
 action = c.action;
 return *this;
}

template <class P1, class P2, class P3>
Gate3<P1, P2, P3>::Gate3(const Gate3& c)
{
 action = c.action;
 Retain();
}

template <class P1, class P2, class P3>
Gate3<P1, P2, P3>::~Gate3()
{
 Release();
}
# 7 "C:/upp/uppsrc/Core/Callback.h" 2

template <class OBJECT_, class METHOD_, class T>
struct CallbackMethodActionArgPte : public CallbackAction {
 Ptr<OBJECT_> object;
 METHOD_ method;
 T arg;

 void Execute() { if(object) (object->*method)(arg); }

 CallbackMethodActionArgPte(OBJECT_ *object, METHOD_ method, T arg)
 : object(object), method(method), arg(arg) {}
};

template <class Object, class M, class P, class T>
Callback pteback1(Object *object, void (M::*method)(P), T arg) {
 return Callback(new CallbackMethodActionArgPte<Object, void (M::*)(P), T>(object, method, arg));
}

template <class OBJECT_, class METHOD_, class T>
struct CallbackMethodActionArg : public CallbackAction {
 OBJECT_ *object;
 METHOD_ method;
 T arg;

 void Execute() { (object->*method)(arg); }

 CallbackMethodActionArg(OBJECT_ *object, METHOD_ method, T arg)
 : object(object), method(method), arg(arg) {}
};

template <class Object, class M, class P, class T>
Callback callback1(Object *object, void (M::*method)(P), T arg) {
 return Callback(new CallbackMethodActionArg<Object, void (M::*)(P), T>
                     (object, method, arg));
}

template <class Object, class M, class P, class T>
Callback callback1(const Object *object, void (M::*method)(P) const, T arg) {
 return Callback(new CallbackMethodActionArg<const Object, void (M::*)(P) const, T>
                     (object, method, arg));
}

template <class F, class T, class HC = F>
struct CallbackActionCallArg : public CallbackAction {
 F fn;
 T arg;
 void Execute() { fn(arg); }

 CallbackActionCallArg(F fn, T arg) : fn(fn), arg(arg) {}
};

template <class T, class P>
Callback callback1(void (*fn)(P), T arg)
{
 return Callback(new CallbackActionCallArg<void (*)(P), T, uintptr_t>(fn, arg));
}

template <class OBJECT_, class METHOD_, class P1, class T>
struct CallbackMethodActionArg1Pte : public Callback1Action<P1> {
 Ptr<OBJECT_> object;
 METHOD_ method;
 T arg;
 void Execute(P1 p1) { if(object) (object->*method)(p1, arg); }

 CallbackMethodActionArg1Pte(OBJECT_ *object, METHOD_ method, T arg)
 : object(object), method(method), arg(arg) {}
};

template <class Object, class M, class P1, class P, class T>
Callback1<P1> pteback1(Object *object, void (M::*method)(P1, P), T arg) {
 return Callback1<P1>(new CallbackMethodActionArg1Pte<Object, void (M::*)(P1, P), P1, T> (object, method, arg));
}

template <class OBJECT_, class METHOD_, class P1, class T>
struct CallbackMethodActionArg1 : public Callback1Action<P1> {
 OBJECT_ *object;
 METHOD_ method;
 T arg;
 void Execute(P1 p1) { (object->*method)(p1, arg); }

 CallbackMethodActionArg1(OBJECT_ *object, METHOD_ method, T arg)
 : object(object), method(method), arg(arg) {}
};

template <class Object, class M, class P1, class P, class T>
Callback1<P1> callback1(Object *object, void (M::*method)(P1, P), T arg) {
 return Callback1<P1>(new CallbackMethodActionArg1<Object, void (M::*)(P1, P), P1, T>
                          (object, method, arg));
}

template <class Object, class M, class P1, class P, class T>
Callback1<P1> callback1(const Object *object, void (M::*method)(P1, P) const, T arg) {
 return Callback1<P1>(new CallbackMethodActionArg1<const Object, void (M::*)(P1, P) const, P1, T>
                          (object, method, arg));
}

template <class F, class P1, class T, class HC = F>
struct CallbackActionCallArg1 : Callback1Action<P1> {
 F fn;
 T arg;
 void Execute(P1 p1) { fn(p1, arg); }

 CallbackActionCallArg1(F fn, T arg) : fn(fn), arg(arg) {}
};

template <class T, class P1, class P>
Callback1<P1> callback1(void (*fn)(P1, P), T arg)
{
 return Callback1<P1>(new CallbackActionCallArg1<void (*)(P1, P), P1, T, uintptr_t>(fn, arg));
}

template <class T, class P>
Callback callback1(Callback1<P> cb, T arg)
{
 return Callback(new CallbackActionCallArg<Callback1<P>, T>(cb, arg));
}

template <class T, class P1, class P>
Callback1<P1> callback1(Callback2<P1, P> cb, T arg) {
 return Callback1<P1>(new CallbackActionCallArg1<Callback2<P1, P>, P1, T>(cb, arg));
}

template <class P1>
bool Gate1<P1>::Execute(P1 p1) const {
 return (void *)action == (void *)1 ? true : action ? action->Execute(p1) : false;
}

template <class P1, class P2>
bool Gate2<P1, P2>::Execute(P1 p1, P2 p2) const {
 return (void *)action == (void *)1 ? true : action ? action->Execute(p1, p2) : false;
}

template <class P1, class P2, class P3>
bool Gate3<P1, P2, P3>::Execute(P1 p1, P2 p2, P3 p3) const {
 return (void *)action == (void *)1 ? true : action ? action->Execute(p1, p2, p3) : false;
}

template <class OBJECT_, class METHOD_, class T1, class T2>
struct CallbackMethodActionArg2Pte : public CallbackAction {
 Ptr<OBJECT_> object;
 METHOD_ method;
 T1 arg1;
 T2 arg2;
 void Execute() { if(object) (object->*method)(arg1, arg2); }

 CallbackMethodActionArg2Pte(OBJECT_ *object, METHOD_ method, T1 arg1, T2 arg2)
 : object(object), method(method), arg1(arg1), arg2(arg2) {}
};

template <class Object, class R, class O, class A, class B, class T1, class T2>
Callback pteback2(Object *object, R (O::*method)(A, B), T1 arg1, T2 arg2) {
 return Callback(new CallbackMethodActionArg2Pte<Object, R (O::*)(A, B), T1, T2>
                     (object, method, arg1, arg2));
}

template <class OBJECT_, class METHOD_, class T1, class T2>
struct CallbackMethodActionArg2 : public CallbackAction {
 OBJECT_ *object;
 METHOD_ method;
 T1 arg1;
 T2 arg2;
 void Execute() { (object->*method)(arg1, arg2); }

 CallbackMethodActionArg2(OBJECT_ *object, METHOD_ method, T1 arg1, T2 arg2)
 : object(object), method(method), arg1(arg1), arg2(arg2) {}
};

template <class Object, class R, class O, class A, class B, class T1, class T2>
Callback callback2(Object *object, R (O::*method)(A, B), T1 arg1, T2 arg2) {
 return Callback(new CallbackMethodActionArg2<Object, R (O::*)(A, B), T1, T2>
                     (object, method, arg1, arg2));
}

template <class Object, class R, class O, class A, class B, class T1, class T2>
Callback callback2(const Object *object, R (O::*method)(A, B) const, T1 arg1, T2 arg2) {
 return Callback(new CallbackMethodActionArg2<Object, R (O::*)(A, B) const, T1, T2>
                     (object, method, arg1, arg2));
}

template <class X, class T1, class T2, class HC = X>
struct CallbackActionCallArg2 : public CallbackAction {
 X x;
 T1 arg1;
 T2 arg2;
 void Execute() { x(arg1, arg2); }

 CallbackActionCallArg2(X x, T1 arg1, T2 arg2) : x(x), arg1(arg1), arg2(arg2) {}
};

template <class R, class A, class B, class T1, class T2>
Callback callback2(R (*fn)(A, B), T1 arg1, T2 arg2) {
 return Callback(new CallbackActionCallArg2<R (*)(A, B), T1, T2, uintptr_t>(fn, arg1, arg2));
}

template <class A, class B, class T1, class T2>
Callback callback2(Callback2<A, B> cb, T1 arg1, T2 arg2) {
 return Callback(new CallbackActionCallArg2<Callback2<A, B>, T1, T2>(cb, arg1, arg2));
}
# 214 "C:/upp/uppsrc/Core/Callback.h"
template <class T>
class CallbackArgTarget
{
 T result;

 void SetResult(const T& value) { result = value; }

public:
 typedef CallbackArgTarget CLASSNAME;

 operator const T&() { return result; }
 bool IsNullInstance() const { return IsNull(result); }

 Callback operator[](const T& value) { return callback1(this, &CLASSNAME::SetResult, value); }

 CallbackArgTarget() { result = Null; }
};
# 388 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Util.h" 1
# 12 "C:/upp/uppsrc/Core/Util.h"
class TimeStop {
 dword starttime;

public:
 int Elapsed() const { return GetTickCount() - starttime; }
 String ToString() const;

 TimeStop();
};

void SetAssertFailedHook(void (*h)(const char *));

void SetIniFile(const char *name);
String GetIniKey(const char *name);
VectorMap<String, String> LoadIniFile(const char *filename);

String timeFormat(double second);

String Garble(const char *s, const char *e);
String Garble(const String& s);

String Encode64(const String& s);
String Decode64(const String& s);





String ToSystemCharset(const String& src);
String FromSystemCharset(const String& src);



String GetErrorMessage(dword dwError);







String GetLastErrorMessage();

void BeepInformation();
void BeepExclamation();
void BeepQuestion();

inline
void memsetw(void *t, word value, int count)
{
 word *w = (word *)t;
 word *lim = w + count;
 while(w < lim)
  *w++ = value;
}

inline
void memsetd(void *t, dword value, int count)
{
 dword *w = (dword *)t;
 dword *lim = w + count;
 while(w < lim)
  *w++ = value;
}

inline
void memsetex(void *t, const void *item, int item_size, int count) {
 ;
 byte *q = (byte *)t;
 while(count--) {
  memcpy(q, item, item_size);
  q += item_size;
 }
}

char *PermanentCopy(const char *s);

int MemICmp(const void *dest, const void *src, int count);

String NormalizeSpaces(const char *s);
String NormalizeSpaces(const char *begin, const char *end);





template <class T>
void Zero(T& obj)
{
 ::memset(&obj, 0, sizeof(obj));
}

template <class T>
T& Reconstruct(T& object)
{
 object.~T();
 ::new(&object) T;
 return object;
}




inline int Peek16le(const void *ptr) { return *(const word *)ptr; }
inline int Peek32le(const void *ptr) { return *(const dword *)ptr; }
inline int64 Peek64le(const void *ptr) { return *(const int64 *)ptr; }

inline void Poke16le(const void *ptr, int val) { *(word *)ptr = val; }
inline void Poke32le(const void *ptr, int val) { *(dword *)ptr = val; }
inline void Poke64le(const void *ptr, int64 val) { *(int64 *)ptr = val; }
# 132 "C:/upp/uppsrc/Core/Util.h"
inline int Peek16be(const void *ptr) { return ((WORD)(((BYTE)(((byte *)ptr)[1]))|(((WORD)((BYTE)(((byte *)ptr)[0])))<<8))); }
inline int Peek32be(const void *ptr) { return ((LONG)(((WORD)(Peek16be((byte *)ptr + 2)))|(((DWORD)((WORD)(Peek16be(ptr))))<<16))); }
inline int64 Peek64be(const void *ptr) { return ((qword) (((dword) (Peek32be((byte *)ptr + 4))) | ((qword) ((dword) (Peek32be(ptr)))) << 32)); }

inline void Poke16be(const void *ptr, int val) { ((byte *)ptr)[1] = ((BYTE)(val)); ((byte *)ptr)[0] = ((BYTE)(((WORD)(val)>>8)&0xFF)); }
inline void Poke32be(const void *ptr, int val) { Poke16le(ptr, ((WORD)(((DWORD)(val)>>16)&0xFFFF))); Poke16le((byte *)ptr + 2, ((WORD)((DWORD)(val)))); }
inline void Poke64be(const void *ptr, int64 val) { Poke32le(ptr, (dword)((val) >> 32)); Poke32le((byte *)ptr + 4, dword(val)); }

inline void EndianSwap(word& v) { byte *x = (byte *)(&v); Swap(x[0], x[1]); }
inline void EndianSwap(int16& v) { EndianSwap(*(word *)&v); }
inline void EndianSwap(dword& v) { byte *x = (byte *)&v; Swap(x[0], x[3]); Swap(x[1], x[2]); }
inline void EndianSwap(int& v) { EndianSwap(*(dword *)&v); }

inline void EndianSwap(int64& v) { byte *x = (byte *)&v; Swap(x[0], x[7]); Swap(x[1], x[6]); Swap(x[2], x[5]); Swap(x[3], x[4]); }
inline void EndianSwap(uint64& v) { EndianSwap(*(int64 *)&v); }

inline word SwapEndian(word v) { EndianSwap(v); return v; }
inline int16 SwapEndian(int16 v) { EndianSwap(v); return v; }
inline dword SwapEndian(dword v) { EndianSwap(v); return v; }
inline int SwapEndian(int v) { EndianSwap(v); return v; }

inline int64 SwapEndian(int64 v) { EndianSwap(v); return v; }
inline uint64 SwapEndian(uint64 v) { EndianSwap(v); return v; }

void EndianSwap(word *v, int count);
void EndianSwap(int16 *v, int count);
void EndianSwap(dword *v, int count);
void EndianSwap(int *v, int count);

void EndianSwap(int64 *v, int count);
void EndianSwap(uint64 *v, int count);



inline double sqr (double a) { return a * a; }
inline double argsinh (double s) { return log(s + sqrt(s * s + 1)); }
inline double argcosh (double c) { ; return log(c + sqrt(c * c - 1)); }
inline double argtanh (double t) { ; return log((1 + t) / (1 - t)) / 2; }

int iscale(int x, int y, int z);
int iscalefloor(int x, int y, int z);
int iscaleceil(int x, int y, int z);
int idivfloor(int x, int y);
int idivceil(int x, int y);
int itimesfloor(int x, int y);
int itimesceil(int x, int y);

int fround(double x);
int ffloor(double x);
int fceil(double x);

int64 fround64(double x);
int64 ffloor64(double x);
int64 fceil64(double x);

String AsString(double x, int nDigits);
double modulo(double x, double y);

int ilog10 (double d);
double ipow10 (int i);
double normalize (double d, int& exponent);

double roundr (double d, int digits);
double floorr (double d, int digits);
double ceilr (double d, int digits);
# 233 "C:/upp/uppsrc/Core/Util.h"
class BitAndPtr {
 uintptr_t bap;

public:
 void SetBit(bool b) { bap = (~1 & bap) | (uintptr_t)b; }
 void SetPtr(void *p) { bap = (1 & bap) | (uintptr_t)p; }

 bool GetBit() const { return bap & 1; }
 void *GetPtr() const { return (void *) (bap & ~1); }

 void Set0(void *ptr) { bap = (uintptr_t)ptr; }
 void Set1(void *ptr) { bap = (uintptr_t)ptr | 1; }

 BitAndPtr() { bap = 0; }
};

class Exc : public String {
public:
 Exc();
 Exc(const String& desc) : String(desc) {}


};

class AbortExc : public Exc {
public:
 AbortExc();
};
# 276 "C:/upp/uppsrc/Core/Util.h"
struct TextTest {
 virtual const char *Accept(const char *s) const = 0;
};

class CharFilterTextTest : public TextTest {
 int (*filter)(int);

public:
 virtual const char *Accept(const char *s) const;
 CharFilterTextTest(int (*filter)(int));
 ~CharFilterTextTest();
};

Vector<String> Split(const char *s, const TextTest& delim, bool ignoreempty = true);
Vector<String> Split(const char *s, int (*filter)(int), bool ignoreempty = true);
Vector<String> Split(const char *s, int chr, bool ignoreempty = true);
String Join(const Vector<String>& im, const String& delim);

class StringC {
 BitAndPtr bap;

 bool IsString() const { return bap.GetBit(); }
 void Free();

public:
 void SetString(const String& s);
 void SetCharPtr(const char *s);

 bool IsEmpty() const;

 operator const char *() const;
 operator String() const;

 ~StringC();
};



class TextSettings {
 VectorMap< String, VectorMap< String, String > > settings;

public:
 String Get(const char *group, const char *key) const;
 String Get(const char *key) const { return Get("", key); }

 String operator()(const char *group, const char *key) const { return Get(group, key); }
 String operator()(const char *key) const { return Get(key); }

 void Clear() { settings.Clear(); }
 void Load(const char *filename);
};



bool Load(Callback1<Stream&> serialize, Stream& stream);
bool Store(Callback1<Stream&> serialize, Stream& stream);
bool LoadFromFile(Callback1<Stream&> serialize, const char *file = __null);
bool StoreToFile(Callback1<Stream&> serialize, const char *file = __null);

template <class T>
bool Load(T& x, Stream& s) {
 return Load(callback(&x, &T::Serialize), s);
}

template <class T>
bool Store(T& x, Stream& s) {
 return Store(callback(&x, &T::Serialize), s);
}

template <class T>
bool LoadFromFile(T& x, const char *name = __null) {
 return LoadFromFile(callback(&x, &T::Serialize), name);
}

template <class T>
bool StoreToFile(T& x, const char *name = __null) {
 return StoreToFile(callback(&x, &T::Serialize), name);
}

template <class T>
String StoreAsString(T& x) {
 StringStream ss;
 Store(x, ss);
 return ss;
}

template <class T>
bool LoadFromString(T& x, const String& s) {
 StringStream ss(s);
 return Load(x, ss);
}

void RegisterGlobalConfig(const char *name);
void RegisterGlobalConfig(const char *name, Callback WhenFlush);

String GetGlobalConfigData(const char *name);
void SetGlobalConfigData(const char *name, const String& data);

template <class T>
bool LoadFromGlobal(T& x, const char *name)
{
 StringStream ss(GetGlobalConfigData(name));
 return ss.IsEof() || Load(x, ss);
}

template <class T>
void StoreToGlobal(T& x, const char *name)
{
 StringStream ss;
 Store(x, ss);
 SetGlobalConfigData(name, ss);
}

void SerializeGlobalConfigs(Stream& s);
# 389 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Format.h" 1
String FormatIntBase(int i, int base, int width = 0, char lpad = ' ', int sign = 0);
String FormatInt(int i);
String FormatIntDec(int i, int width, char lpad = ' ', bool always_sign = false);
String FormatIntHex(int i, int width = 8, char lpad = '0');
String FormatIntOct(int i, int width = 12, char lpad = '0');
String FormatIntRoman(int i, bool upper = false);
String FormatIntAlpha(int i, bool upper = true);
String Format64(uint64 a);
String Format64Hex(uint64 a);




inline String FormatIntHex(const void *ptr) { return FormatIntHex((int)ptr); }


String FormatInteger(int a);
String FormatUnsigned(unsigned long a);
String FormatDouble(double a);
String FormatBool(bool a);
String FormatInt64(int64 a);

template<> inline String AsString(const short& a) { return FormatInteger(a); }
template<> inline String AsString(const unsigned short& a) { return FormatUnsigned(a); }
template<> inline String AsString(const int& a) { return FormatInteger(a); }
template<> inline String AsString(const unsigned int& a) { return FormatUnsigned(a); }
template<> inline String AsString(const long& a) { return FormatInteger(a); }
template<> inline String AsString(const unsigned long& a) { return FormatUnsigned(a); }
template<> inline String AsString(const double& a) { return FormatDouble(a); }
template<> inline String AsString(const float& a) { return FormatDouble(a); }

template<> inline String AsString(const int64& a) { return FormatInt64(a); }
template<> inline String AsString(const uint64& a) { return Format64(a); }

enum
{
 FD_SIGN = 0x01,
 FD_REL = 0x02,
 FD_SIGN_EXP = 0x04,
 FD_CAP_E = 0x08,
 FD_ZERO = 0x10,
 FD_FIX = 0x20,
 FD_EXP = 0x40,
};
String FormatDoubleDigits(double d, int digits, int flags, int& exponent);
String FormatDouble(double d, int digits, int flags = 0, int fill_exp = 0);
String FormatDoubleFix(double d, int digits, int flags = 0);
String FormatDoubleExp(double d, int digits, int flags = 0, int fill_exp = 0);

String FormatDate(Date date, const char *format, int language = 0);
String FormatTime(Time time, const char *format, int language = 0);

inline String IntStr(int i) { return FormatInt(i); }
inline String DblStr(double d) { return FormatDouble(d, 10); }






struct Formatting
{
 int language;
 int maxn;
 Value arg;
 String format;
 String id;
};

typedef String (*Formatter)(const Formatting& fmt);

void RegisterFormatter(int type, const char *id, Formatter f);
void RegisterNullFormatter(const char *id, Formatter f);
void RegisterNumberFormatter(const char *id, Formatter f);
void RegisterStringFormatter(const char *id, Formatter f);
void RegisterDateTimeFormatter(const char *id, Formatter f);
void RegisterValueFormatter(const char *id, Formatter f);
# 86 "C:/upp/uppsrc/Core/Format.h"
String NFormat(const char *fmt, Value p1); String NFormat(int language, const char *fmt, Value p1); String NFormat(const char *fmt, Value p1, Value p2); String NFormat(int language, const char *fmt, Value p1, Value p2); String NFormat(const char *fmt, Value p1, Value p2, Value p3); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); String NFormat(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); String NFormat(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10);





String NFormat(const char *s, const Vector<Value>& v);
String NFormat(int language, const char *s, const Vector<Value>& v);

String VFormat(const char *fmt, va_list args);
String Sprintf(const char *fmt, ...);
# 107 "C:/upp/uppsrc/Core/Format.h"
String Format(const char *fmt, Value p1); String Format(int language, const char *fmt, Value p1); String Format(const char *fmt, Value p1, Value p2); String Format(int language, const char *fmt, Value p1, Value p2); String Format(const char *fmt, Value p1, Value p2, Value p3); String Format(int language, const char *fmt, Value p1, Value p2, Value p3); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); String Format(const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); String Format(int language, const char *fmt, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10);




String Format(const char *s, const Vector<Value>& v);
String Format(int language, const char *s, const Vector<Value>& v);







String DeFormat(const char *text);
# 391 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Convert.h" 1
unsigned stou(const char *ptr, void *endptr = __null, unsigned base = 10);
inline unsigned stou(const byte *ptr, void *endptr = __null, unsigned base = 10) { return stou((const char *)ptr, endptr, base); }
unsigned stou(const wchar *ptr, void *endptr = __null, unsigned base = 10);

uint64 stou64(const char *s, void *endptr = __null, unsigned base = 10);

int ScanInt(const char *ptr, const char **endptr = __null, int radix = 10);
int ScanInt(const wchar *ptr, const wchar **endptr = __null, int radix = 10);

double ScanDouble(const char *ptr, const char **endptr = __null, bool accept_comma = true);
double ScanDouble(const wchar *ptr, const wchar **endptr = __null, bool accept_comma = true);

Value StrIntValue(const char *s);
inline int StrInt(const char* s) { return ScanInt(s); }
inline double IntDbl(int i) { return IsNull(i) ? double(Null) : double(i); }
inline int DblInt(double d) { return IsNull(d) ? int(Null) : fround(d); }
Value StrDblValue(const char* s);
inline double StrDbl(const char* s) { return ScanDouble(s); }

class Convert {
public:




 virtual ~Convert() {}


 virtual Value Format(const Value& q) const;
 virtual Value Scan(const Value& text) const;
 virtual int Filter(int chr) const;

 Value operator()(const Value& q) const { return Format(q); }
};

const Convert& StdConvert();

String StdFormat(const Value& q);

class ConvertInt : public Convert {
public:
 virtual Value Scan(const Value& text) const;
 virtual int Filter(int chr) const;

protected:
 int minval, maxval;
 bool notnull;

public:
 ConvertInt& MinMax(int _min, int _max) { minval = _min; maxval = _max; return *this; }
 ConvertInt& Min(int _min) { minval = _min; return *this; }
 ConvertInt& Max(int _max) { maxval = _max; return *this; }
 ConvertInt& NotNull(bool b = true) { notnull = b; return *this; }
 ConvertInt& NoNotNull() { return NotNull(false); }
 int GetMin() const { return minval; }
 int GetMax() const { return maxval; }
 bool IsNotNull() const { return notnull; }





 ConvertInt(int minval = -2147483647, int maxval = 2147483647, bool notnull = false)
  : minval(minval), maxval(maxval), notnull(notnull) {}

};

const ConvertInt& StdConvertInt();
const ConvertInt& StdConvertIntNotNull();

class ConvertDouble : public Convert {
public:
 virtual Value Format(const Value& q) const;
 virtual Value Scan(const Value& text) const;
 virtual int Filter(int chr) const;

protected:
 double minval, maxval;
 bool notnull;
 String pattern;

public:
 ConvertDouble& Pattern(const char *p) { pattern = p; return *this; }
 ConvertDouble& MinMax(double _min, double _max) { minval = _min; maxval = _max; return *this; }
 ConvertDouble& Min(double _min) { minval = _min; return *this; }
 ConvertDouble& Max(double _max) { maxval = _max; return *this; }
 ConvertDouble& NotNull(bool b = true) { notnull = b; return *this; }
 ConvertDouble& NoNotNull() { return NotNull(false); }
 double GetMin() const { return minval; }
 double GetMax() const { return maxval; }
 bool IsNotNull() const { return notnull; }

 ConvertDouble(double minval = DOUBLE_NULL_LIM, double maxval = -DOUBLE_NULL_LIM,
            bool notnull = false);



};

const ConvertDouble& StdConvertDouble();
const ConvertDouble& StdConvertDoubleNotNull();

class ConvertDate : public Convert {
public:
 virtual Value Scan(const Value& text) const;
 virtual int Filter(int chr) const;

protected:
 Date minval, maxval;
 bool notnull;

public:
 ConvertDate& MinMax(Date _min, Date _max) { minval = _min; maxval = _max; return *this; }
 ConvertDate& Min(Date _min) { minval = _min; return *this; }
 ConvertDate& Max(Date _max) { maxval = _max; return *this; }
 ConvertDate& NotNull(bool b = true) { notnull = b; return *this; }
 ConvertDate& NoNotNull() { return NotNull(false); }
 Date GetMin() const { return minval; }
 Date GetMax() const { return maxval; }
 bool IsNotNull() const { return notnull; }

 ConvertDate(Date minval = Date::Low(), Date maxval = Date::High(), bool notnull = false);
 virtual ~ConvertDate();
};

const ConvertDate& StdConvertDate();
const ConvertDate& StdConvertDateNotNull();

class ConvertTime : public Convert {
public:
 virtual Value Scan(const Value& text) const;
 virtual int Filter(int chr) const;

protected:
 Time minval, maxval;
 bool notnull;

public:
 ConvertTime& MinMax(Time _min, Time _max) { minval = _min; maxval = _max; return *this; }
 ConvertTime& NotNull(bool b = true) { notnull = b; return *this; }
 ConvertTime& NoNotNull() { return NotNull(false); }
 Time GetMin() const { return minval; }
 Time GetMax() const { return maxval; }
 bool IsNotNull() const { return notnull; }

 ConvertTime(Time minval = ToTime(Date::Low()), Time maxval = ToTime(Date::High()), bool notnull = false);
 virtual ~ConvertTime();
};

const ConvertTime& StdConvertTime();
const ConvertTime& StdConvertTimeNotNull();

class ConvertString : public Convert {
public:
 virtual Value Scan(const Value& text) const;

protected:
 int maxlen;
 bool notnull;

public:
 ConvertString& MaxLen(int _maxlen) { maxlen = _maxlen; return *this; }
 int GetMaxLength() const { return maxlen; }
 ConvertString& NotNull(bool b = true) { notnull = b; return *this; }
 ConvertString& NoNotNull() { return NotNull(false); }
 bool IsNotNull() const { return notnull; }





 ConvertString(int maxlen = 2147483647, bool notnull = false)
  : maxlen(maxlen), notnull(notnull) {}

};

const ConvertString& StdConvertString();
const ConvertString& StdConvertStringNotNull();

class NoConvertClass : public Convert {
public:
 virtual Value Format(const Value& q) const;
};

const NoConvertClass& NoConvert();

class MapConvert : public Convert {
public:
 virtual Value Format(const Value& q) const;

protected:
 VectorMap<Value, Value> map;

public:
 void Clear() { map.Clear(); }
 MapConvert& Add(const Value& a, const Value& b) { map.Add(a, b); return *this; }

 int GetCount() const { return map.GetCount(); }
 int Find(const Value& v) const { return map.Find(v); }
 const Value& GetKey(int i) const { return map.GetKey(i); }
 const Value& GetValue(int i) const { return map[i]; }
 const Value& operator[](int i) const { return map[i]; }

 virtual ~MapConvert() {}
};

class JoinConvert : public Convert {
public:
 virtual Value Format(const Value& v) const;

protected:
 struct Item {
  int pos;
  const Convert *convert;
  String text;
 };
 Array<Item> item;

 int NextPos() const;

public:
 JoinConvert& Add(const char *text);
 JoinConvert& Add(int pos, const Convert& cv);
 JoinConvert& Add(int pos);
 JoinConvert& Add(const Convert& cv);
 JoinConvert& Add();
};

class FormatConvert : public Convert {
public:
 virtual Value Format(const Value& v) const;

private:
 String format;

public:
 void SetFormat(const char *fmt) { format = fmt; }
};
# 392 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Thread.h" 1


class Thread {

 HANDLE handle;





public:
 bool Run(Callback cb);

 void Detach();
 int Wait(int timeout_msec = Null);

 bool IsOpen() const { return handle; }


 HANDLE GetHandle() const { return handle; }





 void Priority(int percent);

 static void Sleep(int ms);

 static int GetCount();
 static void ShutdownThreads();
 static bool IsShutdownThreads();


 Thread();
 ~Thread() { Detach(); }

private:
 void operator=(const Thread&);
 Thread(const Thread&);
};





class SyncObject {
protected:
 HANDLE handle;

public:
 bool Wait(int time_ms);
 bool Wait();

 HANDLE GetHandle() const { return handle; }

 SyncObject();
 ~SyncObject();
};

class Event : public SyncObject {
public:
 void Set();

 Event();
};

class Semaphore : public SyncObject {
public:
 void Release(int add);

 Semaphore();
};
# 394 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/z.h" 1
String ZGCompress(String s, bool gzip, Gate2<int, int> progress = false);
String ZGDecompress(String s, bool gzip, Gate2<int, int> progress = false);
void ZGCompress(Stream& out, Stream& in, bool gzip, Gate2<int, int> progress = false);
void ZGDecompress(Stream& out, Stream& in, bool gzip, Gate2<int, int> progress = false);

inline String ZCompress(String s, Gate2<int, int> progress = false) { return ZGCompress(s, false, progress); }
inline String ZDecompress(String s, Gate2<int, int> progress = false) { return ZGDecompress(s, false, progress); }
inline void ZCompress(Stream& out, Stream& in, Gate2<int, int> progress = false) { ZGCompress(out, in, false, progress); }
inline void ZDecompress(Stream& out, Stream& in, Gate2<int, int> progress = false) { ZGDecompress(out, in, false, progress); }

String ZCompress(const void *data, int len, Gate2<int, int> progress = false);
String ZDecompress(const void *data, int len, Gate2<int, int> progress = false);

inline String GZCompress(String s, Gate2<int, int> progress = false) { return ZGCompress(s, true, progress); }
inline String GZDecompress(String s, Gate2<int, int> progress = false) { return ZGDecompress(s, true, progress); }
inline void GZCompress(Stream& out, Stream& in, Gate2<int, int> progress = false) { ZGCompress(out, in, true, progress); }
inline void GZDecompress(Stream& out, Stream& in, Gate2<int, int> progress = false) { ZGDecompress(out, in, true, progress); }
# 396 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Parser.h" 1
inline bool iscib(int c) {
 return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_';
}

inline bool iscid(int c) {
 return iscib(c) || c >= '0' && c <= '9';
}

class CParser {
protected:
 const char *term;
 int line;
 String fn;
 bool skipspaces;

 bool Spaces0();
 bool Id0(const char *id);
 void DoSpaces() { if(skipspaces) Spaces(); }

public:
 struct Error : public Exc { Error(const char *s) : Exc(s) {}};

 void ThrowError(const char *s);

 void NoSkipSpaces() { skipspaces = false; }
 void SkipSpaces() { skipspaces = true; }

 bool Spaces() { return (byte)*term <= ' ' || *term == '/' ? Spaces0() : false; }
 char PeekChar() { return *term; }
 char GetChar();

 bool IsChar(char c) { return *term == c; }
 bool IsChar2(char c1, char c2) { return term[0] == c1 && term[1] == c2; }
 bool IsChar3(char c1, char c2, char c3) { return term[0] == c1 && term[1] == c2 && term[2] == c3; }
 bool Char(char c);
 bool Char2(char c1, char c2);
 bool Char3(char c1, char c2, char c3);
 void PassChar(char c) throw(Error);
 void PassChar2(char c1, char c2) throw(Error);
 void PassChar3(char c1, char c2, char c3) throw(Error);
 bool Id(const char *s) { return term[0] == s[0] && term[1] == s[1] && Id0(s + 2); }
 void PassId(const char *s) throw(Error);
 bool IsId() { return iscib(*term); }
 String ReadId() throw(Error);
 String ReadIdt() throw(Error);
 bool IsInt();
 int ReadInt() throw(Error);
 bool IsNumber() { return IsDigit(*term); }
 bool IsNumber(int base);
 uint32 ReadNumber(int base = 10) throw(Error);
 bool IsDouble() { return IsInt(); }
 double ReadDouble() throw(Error);
 bool IsString() { return IsChar('\"'); };
 String ReadOneString(bool chkend = false) throw(Error);
 String ReadString(bool chkend = false) throw(Error);
 String ReadOneString(int delim, bool chkend = false) throw(Error);
 String ReadString(int delim, bool chkend = false) throw(Error);

 void SkipTerm();

 struct Pos {
  const char *ptr;
  int line;
  String fn;

  Pos(const char *ptr = __null, int line = 1, String fn = Null) : ptr(ptr), line(line), fn(fn) {}
 };

 const char *GetPtr() { return (const char *)term; }

 Pos GetPos();
 void SetPos(const Pos& pos);

 bool IsEof() const { return *term == '\0'; }
 operator bool() const { return *term; }

 int GetLine() const { return line; }
 String GetFileName() const { return fn; }

 CParser(const char *ptr);
 CParser(const char *ptr, const char *fn, int line = 1);
 CParser();
};

inline bool CParser::Char(char c)
{
 if(IsChar(c)) {
  term++;
  DoSpaces();
  return true;
 }
 return false;
}

inline bool CParser::Char2(char c1, char c2)
{
 if(IsChar2(c1, c2)) {
  term += 2;
  DoSpaces();
  return true;
 }
 return false;
}

inline bool CParser::Char3(char c1, char c2, char c3)
{
 if(IsChar3(c1, c2, c3)) {
  term += 3;
  DoSpaces();
  return true;
 }
 return false;
}

enum {
 ASCSTRING_SMART = 0x01,
 ASCSTRING_OCTALHI = 0x02,
};

String AsCString(const char *s, const char *end, int linemax = 2147483647, const char *linepfx = __null,
                 dword flags = 0);
String AsCString(const char *s, int linemax = 2147483647, const char *linepfx = __null,
                 dword flags = 0);
String AsCString(const String& s, int linemax = 2147483647, const char *linepfx = __null,
                 dword flags = 0);
# 398 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/XML.h" 1
# 1 "C:/upp/uppsrc/Core/Core.h" 1
# 2 "C:/upp/uppsrc/Core/XML.h" 2

String DeXml(const char *s, byte charset = 0);
String XmlPI(const char *text);
String XmlHeader(const char *encoding = "UTF-8", const char *version = "1.0", const char *standalone = "yes");
String XmlDecl(const char *text);
String XmlDocType(const char *text);
String XmlDoc(const char *name, const char *xmlbody);
String XmlComment(const char *text);


class XmlTag : Moveable<XmlTag> {
 String tag;
 String end;

public:
 XmlTag& Tag(const char *s);

 String operator()();
 String operator()(const char *text);
 String operator()(const String& text) { return operator()(~text); }
 String Text(const char *s, byte charset = 0);
 String Text(const String& s, byte charset = 0) { return Text(~s, charset); }

 XmlTag& operator()(const char *attr, const char *val);
 XmlTag& operator()(const char *attr, int q);
 XmlTag& operator()(const char *attr, double q);

 XmlTag() {}
 XmlTag(const char *tag) { Tag(tag); }
};

enum { XML_DOC, XML_TAG, XML_END, XML_TEXT, XML_DECL, XML_PI, XML_COMMENT, XML_EOF };

struct XmlError : public Exc
{
 XmlError(const char *s) : Exc(s) {}
};

class XmlParser {
 struct Nesting {
  Nesting(String tag = Null, bool blanks = false) : tag(tag), preserve_blanks(blanks) {}
  String tag;
  bool preserve_blanks;
 };

 const char *begin;
 const char *term;
 String attr1, attrval1;
 VectorMap<String, String> attr;
 Array<Nesting> stack;

 int type;
 String nattr1, nattrval1;
 VectorMap<String, String> nattr;
 String text;
 bool empty_tag;
 bool npreserve;

 int line;

 void Ent(StringBuffer& out);
 void Next();

public:
 void SkipWhites();

 bool IsEof();

 bool IsTag();
 String ReadTag();
 bool Tag(const char *tag);
 void PassTag(const char *tag);
 bool IsEnd();
 bool End();
 void PassEnd();
 bool TagE(const char *tag);
 void PassTagE(const char *tag);

 int GetAttrCount() const { return attr.GetCount() + !IsNull(attr1); }
 String GetAttr(int i) const { return i ? attr.GetKey(i - 1) : attr1; }
 String operator[](int i) const { return i ? attr[i - 1] : attrval1; }
 String operator[](const char *id) const { return attr1 == id ? attrval1 : attr.Get(id, Null); }
 int Int(const char *id, int def = Null) const;
 double Double(const char *id, double def = Null) const;

 bool IsText();
 String ReadText();
 String ReadTextE();

 bool IsDecl();
 String ReadDecl();

 bool IsPI();
 String ReadPI();

 bool IsComment();
 String ReadComment();

 void Skip();
 void SkipEnd();

 VectorMap<String, String> PickAttrs() const;

 int GetLine() const { return line; }
 int GetColumn() const;

 XmlParser(const char *s);
};

class XmlNode {
 int type;
 String text;
 VectorMap<String, String> attr;
 Array<XmlNode> node;

public:
 int GetType() const { return type; }
 String GetText() const { return text; }
 String GetTag() const { return text; }
 bool IsTag() const { return type == XML_TAG; }
 bool IsTag(const char *tag) const { return IsTag() && text == tag; }
 bool IsText() const { return type == XML_TEXT; }

 void Clear() { text.Clear(); attr.Clear(); node.Clear(); type = -1; }
 void CreateTag(const char *tag) { type = XML_TAG; text = tag; }
 void CreateText(const String& txt) { type = XML_TEXT; text = txt; }
 void CreatePI(const String& pi) { type = XML_PI; text = pi; }
 void CreateDecl(const String& decl) { type = XML_DECL; text = decl; }
 void CreateComment(const String& comment) { type = XML_COMMENT; text = comment; }
 void CreateDocument() { Clear(); }
 bool IsEmpty() const { return type == XML_DOC && node.GetCount() == 0; }
 operator bool() const { return !IsEmpty(); }

 int GetCount() const { return node.GetCount(); }
 XmlNode& At(int i) { return node.At(i); }
 const XmlNode& Node(int i) const { return node[i]; }
 const XmlNode& operator[](int i) const { return node[i]; }
 const XmlNode& operator[](const char *tag) const;
 XmlNode& Add() { return node.Add(); }
 void AddText(const String& txt) { Add().CreateText(txt); }
 int FindTag(const char *tag) const;
 XmlNode& Add(const char *tag);
 XmlNode& GetAdd(const char *tag);
 XmlNode& operator()(const char *tag) { return GetAdd(tag); }
 void Remove(const char *tag);

 String GatherText() const;

 int GetAttrCount() const { return attr.GetCount(); }
 String AttrId(int i) const { return attr.GetKey(i); }
 String Attr(int i) const { return attr[i]; }
 String Attr(const char *id) const { return attr.Get(id, Null); }
 XmlNode& SetAttr(const char *id, const String& val);
 int AttrInt(const char *id, int def = Null) const;
 XmlNode& SetAttr(const char *id, int val);

 void SetAttrsPick(const VectorMap<String, String>& a) { attr = a; }

 XmlNode() { type = XML_DOC; }
};

enum {
 XML_IGNORE_DECLS = 0x01,
 XML_IGNORE_PIS = 0x02,
 XML_IGNORE_COMMENTS = 0x04,
};

XmlNode ParseXML(XmlParser& p, dword style = XML_IGNORE_DECLS|XML_IGNORE_PIS|XML_IGNORE_COMMENTS);
XmlNode ParseXML(const char *s, dword style = XML_IGNORE_DECLS|XML_IGNORE_PIS|XML_IGNORE_COMMENTS);

enum {
 XML_HEADER = 0x01,
 XML_DOCTYPE = 0x02,
};

String AsXML(const XmlNode& n, dword style = XML_HEADER|XML_DOCTYPE);
# 399 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Lang.h" 1







int LNGFromText(const char *s);
String LNGAsText(int d);

Convert& LNGConvert();

byte GetLNGCharset(int d);
int SetLNGCharset(int lng, byte chrset);







void SetLanguage(int lang);
int GetCurrentLanguage();

int GetSystemLNG();

VectorMap<String, String> GetLanguage(int lang);
Vector<int> GetLanguages();
const int *GetAllLanguages();

String GetLangName(int language);
String GetNativeLangName(int language);
byte GetLangCharset(int language);

String txtGet(const char *id, int language = -1);

void ExportLNGtoT();


LCID GetLanguageLCID(int language);
String GetLocaleInfoA(LCID lcid, LCTYPE lctype);
WString GetLocaleInfoW(LCID lcid, LCTYPE lctype);


class LanguageInfo
{
public:
 LanguageInfo(int language);
 virtual ~LanguageInfo() {}

 String ToString() const;

 virtual String FormatInt(int value) const;
 virtual String FormatDouble(double value, int digits, int FD_flags = 0, int fill_exp = 0) const;
 virtual String FormatDate(Date date) const;
 virtual String FormatTime(Time time) const;






 virtual WString GetIndexLetter(const wchar *text) const;

 virtual int Compare(const wchar *a, const wchar *b, int a_length, int b_length) const;
 int Compare(const wchar *a, const wchar *b) const { return Compare(a, b, wstrlen(a), wstrlen(b)); }
 int Compare(WString a, WString b) const { return Compare(a, b, a.GetLength(), b.GetLength()); }
 int Compare(const char *a, const char *b) const { return Compare(ToUnicode(a, 0), ToUnicode(b, 0)); }
 int Compare(String a, String b) const { return Compare(a.ToWString(), b.ToWString()); }

 bool operator () (const wchar *a, const wchar *b) const { return Compare(a, b) < 0; }
 bool operator () (WString a, WString b) const { return Compare(a, b) < 0; }
 bool operator () (const char *a, const char *b) const { return Compare(a, b) < 0; }
 bool operator () (String a, String b) const { return Compare(a, b) < 0; }

 struct WildcardCompare
 {
  virtual ~WildcardCompare() {}
  virtual bool Matches(const wchar *s) const = 0;
 };

 virtual One<WildcardCompare> GetWildcardCompare(const wchar *wildcard_text) const;

 static ArrayMap<int, LanguageInfo>& Map();
 static void Register(One<LanguageInfo> info);

public:
 int language;
 String english_name;
 WString native_name;
 byte charset;

 String thousand_separator;
 String decimal_point;
 String date_format;
 String time_format;

 WString month_names[12], short_month_names[12];
 WString day_names[7], short_day_names[7];
};

const LanguageInfo& GetLanguageInfo(int lcode);
const LanguageInfo& GetLanguageInfo();



# 1 "C:/upp/uppsrc/Core/Lang_s.h" 1
# 108 "C:/upp/uppsrc/Core/Lang.h" 2

struct LangModuleRecord {
 const char *id;
 const char **ptr;
};

struct LangTextRecord {
 const char **ptr;
 const char *text;
};

void AddLangModule(const char *file, const char *modulename, int masterlang, const LangModuleRecord *module);
void AddLanguage(const char *modulename, int lang, const LangTextRecord *langtext);
# 400 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/i18n.h" 1
struct LngEntry__ {
 int lang;
 const char *text;
};

void AddModule(const LngEntry__ *entry, const char *modulename = __null);


const char *t_GetLngString(const char *id);



const char *GetENUS(const char *id);



# 1 "C:/upp/uppsrc/Core/t_.h" 1
# 18 "C:/upp/uppsrc/Core/i18n.h" 2
# 45 "C:/upp/uppsrc/Core/i18n.h"
String GetLngString(const char *id);

String GetLngString(int lang, const char *id);

Index<int> GetLngSet();
void SaveLngFile(FileOut& out, int lang);
bool LoadLngFile(const char *file);

void SetCurrentLanguage(int lang);

void LngSetAdd(const char *id, int lang, const char *txt, bool addid);
# 401 "C:/upp/uppsrc/Core/Core.h" 2
# 1 "C:/upp/uppsrc/Core/Topic.h" 1



struct Topic : Moveable<Topic> {
 String title;
 String text;
 String link;
 String label;

 operator const String&() const { return text; }
 operator const char *() const { return text; }
};

struct TopicLink {
 String package;
 String group;
 String topic;
 String label;

 operator bool() const { return !IsNull(topic); }
};

String TopicLinkString(const TopicLink& tl);
TopicLink ParseTopicLink(const char *link);

Topic GetTopic(const String& package, const String& group, const String& topic);
Topic GetTopic(const char *path);

VectorMap<String, VectorMap<String, Vector<String> > >& TopicBase();
# 402 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/App.h" 1
String GetExeFilePath();
String GetExeDirFile(const char *fp);
# 12 "C:/upp/uppsrc/Core/App.h"
String GetExeTitle();
String ConfigFile(const char *file);
String ConfigFile();

const Vector<String>& CommandLine();
const VectorMap<String, String>& Environment();

void SetExitCode(int code);
int GetExitCode();

bool IsMainRunning();





void AppExit__();



void AppInit__(int argc, const char **argv);
void AppInitEnvironment__();
# 69 "C:/upp/uppsrc/Core/App.h"
String GetDataFile(const char *filename);

void LaunchWebBrowser(const String& url);
# 404 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Xmlize.h" 1
class XmlIO;

template <class T>
void XmlAttrLoad(T& var, const String& text)
{
 var.XmlAttrLoad(text);
}

template <class T>
String XmlAttrStore(const T& var)
{
 return var.XmlAttrStore();
}

class XmlIO {
 XmlNode& node;
 bool loading;

public:
 bool IsLoading() const { return loading; }
 bool IsStoring() const { return !loading; }

 XmlNode *operator->() { return &node; }

 template <class T> XmlIO operator()(const char *tag, T& var);

 template <class T> XmlIO Attr(const char *id, T& var) {
  if(IsLoading())
   XmlAttrLoad(var, node.Attr(id));
  else
   node.SetAttr(id, XmlAttrStore(var));
  return *this;
 }

 template <class T> XmlIO Attr(const char *id, T& var, T def) {
  if(IsLoading())
      if(IsNull(node.Attr(id)))
    var = def;
      else
    XmlAttrLoad(var, node.Attr(id));
  else
  if(var != def)
   node.SetAttr(id, XmlAttrStore(var));
  return *this;
 }

 XmlIO At(int i) { XmlIO m(node.At(i), IsLoading()); return m; }
 XmlIO Add() { XmlIO m(node.Add(), IsLoading()); return m; }
 XmlIO Add(const char *id) { XmlIO m(node.Add(id), IsLoading()); return m; }
 XmlIO GetAdd(const char *id) { XmlIO m(node.GetAdd(id), IsLoading()); return m; }

 XmlIO(XmlNode& xml, bool loading) : node(xml), loading(loading) {}
 XmlIO(XmlIO xml, const char *tag) : node(xml.node.GetAdd(tag)), loading(xml.loading) {}
};

template <class T>
void Xmlize(XmlIO xml, T& var)
{
 var.Xmlize(xml);
}

template <class T> XmlIO XmlIO::operator()(const char *tag, T& var) {
 XmlIO n(*this, tag);
 Xmlize(n, var);
 return *this;
}

template<> void XmlAttrLoad(int& var, const String& text);
template<> String XmlAttrStore(const int& var);
template<> void XmlAttrLoad(dword& var, const String& text);
template<> String XmlAttrStore(const dword& var);
template<> void XmlAttrLoad(double& var, const String& text);
template<> String XmlAttrStore(const double& var);
template<> void XmlAttrLoad(bool& var, const String& text);
template<> String XmlAttrStore(const bool& var);

template<> inline void XmlAttrLoad(String& var, const String& text)
{
 var = text;
}

template<> inline String XmlAttrStore(const String& var)
{
 return var;
}

template<> void Xmlize(XmlIO xml, String& var);

template<> void Xmlize(XmlIO xml, int& var);
template<> void Xmlize(XmlIO xml, dword& var);
template<> void Xmlize(XmlIO xml, double& var);
template<> void Xmlize(XmlIO xml, bool& var);
template<> void Xmlize(XmlIO xml, Point& p);
template<> void Xmlize(XmlIO xml, Size& sz);
template<> void Xmlize(XmlIO xml, Rect& r);
template<> void Xmlize(XmlIO xml, Color& c);

void XmlizeLangAttr(XmlIO xml, int& lang, const char *id = "lang");
void XmlizeLang(XmlIO xml, const char *tag, int& lang, const char *id = "id");

template<class T>
void XmlizeContainer(XmlIO xml, const char *tag, T& data)
{
 if(xml.IsStoring())
  for(int i = 0; i < data.GetCount(); i++)
   Xmlize(xml.Add(tag), data[i]);
 else {
  data.Clear();
  for(int i = 0; i < xml->GetCount(); i++)
   if(xml->Node(i).IsTag(tag))
    Xmlize(xml.At(i), data.Add());
 }
}

template<class T>
void Xmlize(XmlIO xml, Vector<T>& data)
{
 XmlizeContainer(xml, "item", data);
}

template<class T>
void Xmlize(XmlIO xml, Array<T>& data)
{
 XmlizeContainer(xml, "item", data);
}

template<class T>
void XmlizeStore(XmlIO xml, const T& data)
{
 ;
 Xmlize(xml, const_cast<T&>(data));
}

template<class K, class V, class T>
void XmlizeMap(XmlIO xml, const char *keytag, const char *valuetag, T& data)
{
 if(xml.IsStoring()) {
  for(int i = 0; i < data.GetCount(); i++)
   if(!data.IsUnlinked(i)) {
    XmlizeStore(xml.Add(keytag), data.GetKey(i));
    XmlizeStore(xml.Add(valuetag), data[i]);
   }
 }
 else {
  int i = 0;
  while(i < xml->GetCount() - 1 && xml->Node(i).IsTag(keytag) && xml->Node(i + 1).IsTag(valuetag)) {
   K key;
   Xmlize(xml.At(i++), key);
   Xmlize(xml.At(i++), data.Add(key));
  }
 }
}

template<class K, class V, class H>
void Xmlize(XmlIO xml, VectorMap<K, V, H>& data)
{
 XmlizeMap<K, V>(xml, "key", "value", data);
}

template<class K, class V, class H>
void Xmlize(XmlIO xml, ArrayMap<K, V, H>& data)
{
 XmlizeMap<K, V>(xml, "key", "value", data);
}

template <class T>
struct ParamHelper__ {
 T& data;
 void Invoke(XmlIO xml) {
  Xmlize(xml, data);
 }

 ParamHelper__(T& data) : data(data) {}
};

String StoreAsXML(Callback1<XmlIO> xmlize, const char *name);
bool LoadFromXML(Callback1<XmlIO> xmlize, const String& xml);

template <class T>
String StoreAsXML(T& data, const char *name)
{
 ParamHelper__<T> p(data);
 return StoreAsXML(callback(&p, &ParamHelper__<T>::Invoke), name);
}

template <class T>
bool LoadFromXML(T& data, const String& xml)
{
 ParamHelper__<T> p(data);
 return LoadFromXML(callback(&p, &ParamHelper__<T>::Invoke), xml);
}

bool StoreAsXMLFile(Callback1<XmlIO> xmlize, const char *name = __null, const char *file = __null);
bool LoadFromXMLFile(Callback1<XmlIO> xmlize, const char *file = __null);

template <class T>
bool StoreAsXMLFile(T& data, const char *name = __null, const char *file = __null)
{
 ParamHelper__<T> p(data);
 return StoreAsXMLFile(callback(&p, &ParamHelper__<T>::Invoke), name, file);
}

template <class T>
bool LoadFromXMLFile(T& data, const char *file = __null)
{
 ParamHelper__<T> p(data);
 return LoadFromXMLFile(callback(&p, &ParamHelper__<T>::Invoke), file);
}
# 406 "C:/upp/uppsrc/Core/Core.h" 2

# 1 "C:/upp/uppsrc/Core/Win32Com.h" 1
# 10 "C:/upp/uppsrc/Core/Win32Com.h"
inline bool IsWinNT() { return GetVersion() < 0x80000000; }
bool IsWin2K();
bool IsWinXP();


HINSTANCE AppGetHandle();
void AppSetHandle(HINSTANCE dll_instance);

String AsString(const wchar_t *buffer);
String AsString(const wchar_t *buffer, int count);
String AsString(const wchar_t *buffer, const wchar_t *end);

String GetWinRegString(const char *value, const char *path, HKEY base_key = ((HKEY)0x80000002));
int GetWinRegInt(const char *value, const char *path, HKEY base_key = ((HKEY)0x80000002));
bool SetWinRegString(const String& string, const char *value, const char *path, HKEY base_key = ((HKEY)0x80000002));
bool SetWinRegInt(int data, const char *value, const char *path, HKEY base_key = ((HKEY)0x80000002));
void DeleteWinReg(const String& key, HKEY base = ((HKEY)0x80000002));


String GetSystemDirectoryA();
String GetWindowsDirectoryA();

String GetModuleFileNameA(HINSTANCE instance = AppGetHandle());
# 408 "C:/upp/uppsrc/Core/Core.h" 2






inline void AssertMoveable0(POINT *) {}
inline void AssertMoveable0(SIZE *) {}
inline void AssertMoveable0(RECT *) {}


};
# 437 "C:/upp/uppsrc/Core/Core.h"
inline Upp::int64 abs(Upp::int64 x) { return x < 0 ? -x : x; }



void RegisterTopic__(const char *topicfile, const char *topic, const char *title, const Upp::byte *data, int len);


typedef HMODULE DLLHANDLE;




DLLHANDLE LoadDll__(Upp::String& fn, const char *const *names, void *const *procs);
void FreeDll__(DLLHANDLE dllhandle);


using Upp::byte;
# 7 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
namespace DRTE {};
# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 9 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1




namespace DRTE
{
class Stream
{
public:
 virtual char* Serialize(int* size_out)=0;
 virtual int Deserialize(char* data_in,int length)=0;
 virtual ~Stream();
};
}
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2







namespace DRTE
{
class Color : Stream
{
public:
 float r;
 float g;
 float b;
 Color();
 Color(float r, float g, float b);
 Color(Color* color);
 int Add(Color* color);
 int Add(float r, float g, float b);
 int Blend(Color* color);
 int Divide(float div);
 int Multiply(float mul);
 int Multiply(Color* color);
 int ToRGB();
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 ~Color();
};
}
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 18 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h"
namespace DRTE
{
class Vertex : Stream
{
public:
 float u;
 float v;
 float w;
 Vertex();
 Vertex(float u, float v, float w);
 ~Vertex();
};

class Vector : public Vertex
{
public:
 float norma;
 Vector();
 Vector(float u, float v, float w);

 float Norma();
 int Normalize();
 Vector* operator *= (float scalar);
 Vector* operator += (Vector *vector);
 float operator * (Vector *vector);
 Vector* operator + (Vector *vector);
 Vector* operator - (Vector *vector);
 Vector* operator ^ (Vector *vector);

 Vector* Copy();
 int Reverse();
 float Angle(Vector *vector);
 int Compare(Vector *vector);
 float Distance(Vector *vector);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 ~Vector();
};

class Point : public Vertex
{
public:
 DRTE::Color* color;
 DRTE::Color* light;
 Vector *normal;
 int group_id;

 float Distance(Vector *vector);
 float Distance(Point *point);
 int SetNormal(Vector *vector);
 int SetColor(DRTE::Color *color);
 int SetLight(DRTE::Color *color);

 Point();
 Point(float u, float v, float w);
 ~Point();
 int Equals(Point *pt);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2



namespace DRTE
{
class Ray
{
public:
 DRTE::Vector *origin;
 DRTE::Vector *direction;
 Ray();
 Ray(Vector *origin, Vector *direction);
 ~Ray();
 Point* GetPoint(float t);
};
}
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 1 3
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 3
       
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 1 3
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 3
       
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/localefwd.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/localefwd.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/localefwd.h" 3




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 49 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/localefwd.h" 2 3

namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;



  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
}
# 49 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3







namespace std
{
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 105 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 124 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    locale() throw();
# 133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 143 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 158 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 171 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 183 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 197 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 212 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 231 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 259 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 275 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 310 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    static const size_t _S_categories_size = 6 + 0;


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 343 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 374 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 434 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
 __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet* __cache, size_t __index) throw()
    {
      __cache->_M_add_reference();
      _M_caches[__index] = __cache;
    }
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      char* _M_tmp_names[_S_categories_size];
      size_t __i = 0;
      try
 {
   for (; __i < _S_categories_size; ++__i)
     {
       _M_tmp_names[__i] = new char[2];
       std::strcpy(_M_tmp_names[__i], "*");
     }
   _M_impl->_M_install_facet(&_Facet::id, __f);
 }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   for (size_t __j = 0; __j < __i; ++__j)
     delete [] _M_tmp_names[__j];
   throw;
 }

      for (size_t __k = 0; __k < _S_categories_size; ++__k)
 {
   delete [] _M_impl->_M_names[__k];
   _M_impl->_M_names[__k] = _M_tmp_names[__k];
 }
    }
}
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 2 3

namespace std
{




  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 201 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 253 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);


    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);


    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);


    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);




    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);



    static const fmtflags left = fmtflags(__ios_flags::_S_left);


    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);



    static const fmtflags right = fmtflags(__ios_flags::_S_right);


    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);



    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);



    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);


    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);


    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);


    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);



    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);


    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);


    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);


    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);
# 328 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = iostate(__ios_flags::_S_badbit);


    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);




    static const iostate failbit = iostate(__ios_flags::_S_failbit);


    static const iostate goodbit = iostate(0);
# 359 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = openmode(__ios_flags::_S_app);


    static const openmode ate = openmode(__ios_flags::_S_ate);





    static const openmode binary = openmode(__ios_flags::_S_bin);


    static const openmode in = openmode(__ios_flags::_S_in);


    static const openmode out = openmode(__ios_flags::_S_out);


    static const openmode trunc = openmode(__ios_flags::_S_trunc);
# 392 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = seekdir(0);


    static const seekdir cur = seekdir(1);


    static const seekdir end = seekdir(2);
# 420 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 437 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 449 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 559 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 575 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 592 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 619 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 668 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 680 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 691 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 701 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
# 719 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 735 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 756 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 773 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
}
# 50 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3






namespace std
{





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout);
# 122 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 145 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(__streambuf_type* __sbin,
     __streambuf_type* __sbout);

    protected:
# 169 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;






      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 197 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 214 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 227 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 254 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 268 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 286 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 308 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 327 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 341 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 366 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 393 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 419 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 433 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 451 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 467 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 478 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 498 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 514 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 524 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 545 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 560 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 571 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 583 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 596 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual int
      sync() { return 0; }
# 618 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 634 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 656 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 669 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 693 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 711 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 736 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 765 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 3
    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
}


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf.tcc" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf.tcc" 3
       
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      streamsize __ret = 0;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   const size_t __n = __sbin->egptr() - __sbin->gptr();
   if (__n > 1)
     {
       const size_t __wrote = __sbout->sputn(__sbin->gptr(), __n);
       __sbin->gbump(__wrote);
       __ret += __wrote;
       if (__wrote < __n)
  break;
       __c = __sbin->underflow();
     }
   else
     {
       __c = __sbout->sputc(_Traits::to_char_type(__c));
       if (_Traits::eq_int_type(__c, _Traits::eof()))
  break;
       ++__ret;
       __c = __sbin->snextc();
     }
 }
      return __ret;
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*);
# 161 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf.tcc" 3
}
# 782 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/streambuf" 2 3
# 51 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 1 3
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
       
# 40 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf_iterator.h" 1 3
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf_iterator.h" 3
       
# 40 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/streambuf_iterator.h" 3






namespace std
{


  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 const int_type __eof = traits_type::eof();
 if (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))
   _M_sbuf = 0;
 else
   _M_c = __eof;
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 const int_type __eof = traits_type::eof();
 istreambuf_iterator __old = *this;
 if (_M_sbuf
     && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()),
     __eof))
   _M_sbuf = 0;
 else
   _M_c = __eof;
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
           __eof))
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
}
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 2 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwctype" 1 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwctype" 3
       
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwctype" 3
# 79 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/cwctype" 3
namespace std
{
  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;



  using ::iswcntrl;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::iswctype;
  using ::towlower;
  using ::towupper;
  using ::towctrans;
  using ::wctrans;
  using ::wctype;
}
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3




namespace std
{
# 63 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/ctype_base.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 0x0001;
    static const mask lower = 0x0002;
    static const mask alpha = 0x0103;
    static const mask digit = 0x0004;
    static const mask xdigit = 0x0080;
    static const mask space = 0x0008;
    static const mask print = (0x0040 | 0x0010| 0x0103 | 0x0004);
    static const mask graph = (0x0010 | 0x0103 | 0x0004);
    static const mask cntrl = 0x0020;
    static const mask punct = 0x0010;
    static const mask alnum = (0x0103 | 0x0004);
  };
# 133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3
# 144 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 162 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 179 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 195 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 211 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 225 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 240 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 254 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 269 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 286 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 305 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 324 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 346 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 371 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 390 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 409 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 428 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 446 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 463 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 479 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 496 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 515 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 536 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 558 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 582 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 605 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 674 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 711 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 724 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 737 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 752 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 766 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 780 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 795 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 812 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 828 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 845 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 865 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 892 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 923 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 956 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

    protected:


      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();







      virtual
      ~ctype();
# 1003 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1020 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1036 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1053 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1073 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1096 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1122 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1148 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1508 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/ctype_inline.h" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  {
 return (_M_table[static_cast<unsigned char>(__c) ] & __m);
  }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }
# 1509 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 1 3
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
       
# 45 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 73 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 120 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 159 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 199 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 240 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };
# 452 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };
# 1534 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1656 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1693 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1707 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1721 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1734 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1765 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1778 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1791 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1808 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1820 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1833 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1846 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1859 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
# 1887 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1924 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1945 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1971 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2007 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2066 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2108 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;
# 2141 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;

    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2203 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2224 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2242 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2284 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2347 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2372 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2420 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;

    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2464 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 2491 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 2505 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 2522 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 2541 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 2555 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 2584 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 2600 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 2613 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
# 2639 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };
# 2672 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
# 2793 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 2830 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);

      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
# 2963 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/time_members.h" 1 3
# 37 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/time_members.h" 3
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      char* __tmp = new char[std::strlen(__s) + 1];
      std::strcpy(__tmp, __s);
      _M_name_timepunct = __tmp;
      _M_initialize_timepunct(__cloc);
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
# 2964 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3
# 2977 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 2999 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 3016 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 3040 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 3065 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 3093 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 3122 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 3148 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 3168 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual dateorder
      do_date_order() const;
# 3186 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3205 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3224 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 3243 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 3262 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 3317 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 3338 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 3357 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 3377 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 3404 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;

  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 3441 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 3562 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 3574 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 3589 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 3603 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 3616 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 3645 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 3658 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 3675 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 3692 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 3708 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 3743 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 3765 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 3777 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 3790 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 3803 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 3816 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 3829 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 3843 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 3857 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 3871 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
# 3919 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 3961 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 3983 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 4013 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 4043 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 4060 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 4071 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 4096 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4117 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 4137 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 4159 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 4187 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 4209 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;




  struct messages_base
  {
    typedef int catalog;
  };
# 4250 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 4278 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      messages(size_t __refs = 0);
# 4292 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 4305 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 4323 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 4341 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 4352 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 4372 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 4391 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 4448 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;







  template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/messages_members.h" 1 3
# 37 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/messages_members.h" 3
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }
# 4484 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 2 3
# 4492 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  template<typename _CharT>
    inline bool islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}
# 45 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 2 3

namespace std
{







  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 122 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 133 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 186 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 207 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 242 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 280 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 292 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 332 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 346 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 375 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 395 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 415 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 433 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };
}


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.tcc" 1 3
# 33 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.tcc" 3
       
# 34 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 159 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;





}
# 465 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/basic_ios.h" 2 3
# 52 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ios" 2 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 2 3

namespace std
{
# 57 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
# 104 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 130 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      inline __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      inline __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      inline __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
# 167 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned short>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned int>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);
# 248 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 309 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 322 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      flush();
# 333 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      pos_type
      tellp();
# 344 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 356 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      explicit
      basic_ostream() { }
    };
# 374 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
# 393 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
# 403 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      ~sentry()
      {

 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 421 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 442 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 482 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 516 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ostream.tcc" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ostream.tcc" 3
       
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ostream.tcc" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/locale" 1 3
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/locale" 3
       
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/locale" 3




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
       
# 37 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3





namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 83 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
# 105 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __np.grouping()[0] != 0;

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __mp.grouping()[0] != 0;

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
# 266 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef typename numpunct<_CharT>::__cache_type __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;


      bool __found_mantissa = false;


      if (__beg != __end)
 {
   const char_type __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       ++__beg;
     }
 }


      while (__beg != __end)
 {
   const char_type __c = *__beg;
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__beg;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      int __sep_pos = 0;
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
      while (__beg != __end)
        {


   const char_type __c = *__beg;
   const char_type* __q = __traits_type::find(__lit_zero, 10, __c);
          if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
     {
       if (!__found_dec && !__found_sci)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
        ++__beg;
      }
    else
      {
        __err |= ios_base::failbit;
        break;
      }
  }
       else
  break;
            }
   else if (__c == __lc->_M_decimal_point)
     {
       if (!__found_dec && !__found_sci)
  {



    if (__found_grouping.size())
      __found_grouping += static_cast<char>(__sep_pos);
    __xtrc += '.';
    __found_dec = true;
    ++__beg;
  }
       else
  break;
     }
          else if (__q != 0)
     {
       __xtrc += __num_base::_S_atoms_in[__q - __lit];
       __found_mantissa = true;
       ++__sep_pos;
       ++__beg;
     }
   else if ((__c == __lit[__num_base::_S_ie]
      || __c == __lit[__num_base::_S_iE])
     && __found_mantissa && !__found_sci)
     {

       if (__found_grouping.size() && !__found_dec)
  __found_grouping += static_cast<char>(__sep_pos);
       __xtrc += 'e';
       __found_sci = true;


       if (++__beg != __end)
  {
    const bool __plus = *__beg == __lit[__num_base::_S_iplus];
    if ((__plus || *__beg == __lit[__num_base::_S_iminus])
        && !(__lc->_M_use_grouping
      && *__beg == __lc->_M_thousands_sep)
        && !(*__beg == __lc->_M_decimal_point))
      {
        __xtrc += __plus ? '+' : '-';
        ++__beg;
      }
  }
     }
   else

     break;
        }



      if (__lc->_M_use_grouping && __found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __found_num = false;


 bool __negative = false;
 if (__beg != __end)
   {
     const char_type __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       ++__beg;
   }



 while (__beg != __end)
   {
     const char_type __c = *__beg;
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_num || __base == 10))
       {
  __found_num = true;
  ++__beg;
       }
     else if (__found_num)
       {
  if (__c == __lit[__num_base::_S_ix]
      || __c == __lit[__num_base::_S_iX])
    {
      if (__basefield == 0)
        __base = 16;
      if (__base == 16)
        {
   __found_num = false;
   ++__beg;
        }
    }
  else if (__basefield == 0)
    __base = 8;
  break;
       }
     else
       break;
   }



 const size_t __len = __base == 16 ? (__num_base::_S_iend
          - __num_base::_S_izero)
                                   : __base;


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 int __sep_pos = 0;
 bool __overflow = false;
 _ValueT __result = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
 if (__negative)
   {
     const _ValueT __min = numeric_limits<_ValueT>::min() / __base;
     for (; __beg != __end; ++__beg)
       {


  const char_type __c = *__beg;
  const char_type* __q = __traits_type::find(__lit_zero,
          __len, __c);
  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if (__q != 0)
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result < __min)
        __overflow = true;
      else
        {
   const _ValueT __new_result = __result * __base
                                - __digit;
   __overflow |= __new_result > __result;
   __result = __new_result;
   ++__sep_pos;
   __found_num = true;
        }
    }
  else

    break;
       }
   }
 else
   {
     const _ValueT __max = numeric_limits<_ValueT>::max() / __base;
     for (; __beg != __end; ++__beg)
       {
  const char_type __c = *__beg;
  const char_type* __q = __traits_type::find(__lit_zero,
          __len, __c);
  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if (__q != 0)
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result > __max)
        __overflow = true;
      else
        {
   const _ValueT __new_result = __result * __base
                                + __digit;
   __overflow |= __new_result < __result;
   __result = __new_result;
   ++__sep_pos;
   __found_num = true;
        }
    }
  else
    break;
       }
   }



 if (__lc->_M_use_grouping && __found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!(__err & ios_base::failbit) && !__overflow
     && __found_num)
   __v = __result;
 else
   __err |= ios_base::failbit;

 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef char_traits<_CharT> __traits_type;
   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
          for (__n = 0; __beg != __end; ++__n, ++__beg)
            {
       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = *__beg == __lc->_M_falsename[__n];
  else
    break;

       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = *__beg == __lc->_M_truename[__n];
  else
    break;

       if (!__testf && !__testt)
  break;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;

          if (__beg == __end)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);





      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);

      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      else
 __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long __ul = static_cast<unsigned long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ul = -__ul;
   __neg = true;
 }
      return __int_to_char(__bufend, __ul, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {

      return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long long __ull = static_cast<unsigned long long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ull = -__ull;
   __neg = true;
 }
      return __int_to_char(__bufend, __ull, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long long __v,
    const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false); }


  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __neg)
    {

      const bool __showbase = (__flags & ios_base::showbase) && __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __bufend - 1;

      if (__builtin_expect(__basefield != ios_base::oct &&
      __basefield != ios_base::hex, true))
 {

   do
     {
       *__buf-- = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
   if (__neg)
     *__buf-- = __lit[__num_base::_S_ominus];
   else if (__flags & ios_base::showpos)
     *__buf-- = __lit[__num_base::_S_oplus];
 }
      else if (__basefield == ios_base::oct)
 {

   do
     {
       *__buf-- = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
   if (__showbase)
     *__buf-- = __lit[__num_base::_S_odigits];
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *__buf-- = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
   if (__showbase)
     {

       *__buf-- = __lit[__num_base::_S_ox + __uppercase];

       *__buf-- = __lit[__num_base::_S_odigits];
     }
 }
      return __bufend - __buf - 1;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base& __io, _CharT* __new, _CharT* __cs, int& __len) const
    {





      streamsize __off = 0;
      const ios_base::fmtflags __basefield = __io.flags()
                                      & ios_base::basefield;
      if ((__io.flags() & ios_base::showbase) && __len > 1)
 if (__basefield == ios_base::oct)
   {
     __off = 1;
     __new[0] = __cs[0];
   }
 else if (__basefield == ios_base::hex)
   {
     __off = 2;
     __new[0] = __cs[0];
     __new[1] = __cs[1];
   }
      _CharT* __p;
      __p = std::__add_grouping(__new + __off, __sep, __grouping,
    __grouping_size, __cs + __off,
    __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;


 const int __ilen = 4 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 int __len;
 __len = __int_to_char(__cs + __ilen, __v, __lit, __io.flags());
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2, __cs, __len);
     __cs = __cs2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      _CharT* __p2;
      const int __declen = __p ? __p - __cs : __len;
      __p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size,
     __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 1050 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 streamsize __prec = __io.precision();
 if (__prec < static_cast<streamsize>(0))
   __prec = static_cast<streamsize>(6);

 const int __max_digits = numeric_limits<_ValueT>::digits10;


 int __len;

 char __fbuf[16];




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

 __num_base::_S_format_float(__io, __fbuf, __mod);
 __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
          _S_get_c_locale(), __prec);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
       _S_get_c_locale(), __prec);
   }
# 1114 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT __cdec = __ctype.widen('.');
      const _CharT __dec = __lc->_M_decimal_point;
      const _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);
      if (__p)
 __ws[__p - __ws] = __dec;


      if (__lc->_M_use_grouping)
 {


   _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __len * 2));
   _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __p, __ws2, __ws, __len);
   __ws = __ws2;
 }


      const streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len))
 {
   _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __w));
   _M_pad(__fill, __w, __io, __ws3, __ws, __len);
   __ws = __ws3;
 }
      __io.width(0);



      return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __b, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    {

      return _M_insert_float(__s, __io, __fill, char_type(),
         static_cast<double>(__v));



    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type* __q = __traits_type::find(__lit_zero,
              10, *__beg);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (*__beg == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && *__beg == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __testvalid = false;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (__beg == __end)
   __err |= ios_base::eofbit;


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);

 return __beg;
      }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      if (__intl)
 __beg = _M_extract<true>(__beg, __end, __io, __err, __str);
      else
 __beg = _M_extract<false>(__beg, __end, __io, __err, __str);





      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __units) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      const iter_type __ret = __intl ? _M_extract<true>(__beg, __end, __io,
       __err, __str)
                              : _M_extract<false>(__beg, __end, __io,
        __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __len));
   __ctype.widen(__str.data(), __str.data() + __len, __ws);
   __units.assign(__ws, __len);
 }

      return __ret;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (*__beg != __lit[money_base::_S_minus])
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     int __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      _CharT* __ws =
          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
             * 2 * __len));
        _CharT* __ws_end =
        std::__add_grouping(__ws, __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.assign(__ws, __ws_end - __ws);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      double __dunits = static_cast<double>(__units);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(__cs, __cs_size, "%.0f", __dunits,
     _S_get_c_locale(), 0);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(__cs, __cs_size, "%.*f", __dunits,
     _S_get_c_locale(), 0);
 }
# 1746 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      const string_type __digits(__ws, __len);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __err);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __err);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __err);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __err);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __err);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __err);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __err);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __err);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __err);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __err);
    if (!__err)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __err);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __err);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __err);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __err);
    if (!__err)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __err);


        if (__beg != __end && !__err && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __err);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __err);
   }
      }
    else
      __err |= ios_base::failbit;
    break;
  default:

    __err |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __err |= ios_base::failbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (__name[__pos] != *__beg)
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7, __io, __err);







      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_wday = __tmpwday;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __err);







      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_mon = __tmpmon;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {

      string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      string_type __ret;




      for (;;)
 {

   _CharT* __c =
     static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
   size_t __res = _M_transform(__c, __p, __len);


   if (__res >= __len)
     {
       __len = __res + 1;
       __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __len));
       __res = _M_transform(__c, __p, __res + 1);
     }

   __ret.append(__c, __res);
   __p += char_traits<_CharT>::length(__p);
   if (__p == __pend)
     return __ret;

   __p++;
   __ret.push_back(_CharT());
 }
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2441 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }

  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, __grouping_size - 1);
    size_t __i = __n;
    bool __test = true;




    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];


    __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
 {
   const bool __bump = __gsize != 1;
   __s = std::__add_grouping(__s, __sep, __gbeg + __bump,
        __gsize - __bump, __first,
        __last - *__gbeg);
   __first = __last - *__gbeg;
   *__s++ = __sep;
 }
      do
 *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);
# 2795 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/locale_facets.tcc" 3
}
# 48 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/locale" 2 3
# 41 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {



      return __pf(*this);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long __l = static_cast<unsigned long>(__n);
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long long __l = (static_cast<
        unsigned long long>(__n));
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       _CharT* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __w));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       char* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
            &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __traits_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   size_t __clen = __traits_type::length(__s);
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __clen));
   for (size_t __i = 0; __i < __clen; ++__i)
     __ws[__i] = __out.widen(__s[__i]);
   _CharT* __str = __ws;

   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(__clen);
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __ws, __w, __len, false);
    __str = __cs;
    __len = __w;
  }
       __out._M_write(__str, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    char* __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   const streamsize __w = __out.width();
   streamsize __len = static_cast<streamsize>(__str.size());
   const _CharT* __s = __str.data();



   if (__w > __len)
     {
       _CharT* __cs = (static_cast<
         _CharT*>(__builtin_alloca(sizeof(_CharT) * __w)));
       __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, __s,
          __w, __len, false);
       __s = __cs;
       __len = __w;
     }
   __out._M_write(__s, __len);
   __out.width(0);
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
# 697 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/ostream.tcc" 3
}
# 546 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/ostream" 2 3
# 46 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3




namespace std
{
# 58 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 104 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 131 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      inline __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      inline __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      inline __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
# 169 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);
# 230 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 240 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      inline streamsize
      gcount() const
      { return _M_gcount; }
# 272 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      int_type
      get();
# 286 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      get(char_type& __c);
# 313 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 324 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 347 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 357 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 386 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 397 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 416 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());
# 427 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      int_type
      peek();
# 445 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 464 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 480 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      putback(char_type __c);
# 495 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      unget();
# 513 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      int
      sync();
# 527 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      pos_type
      tellg();
# 542 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      seekg(pos_type);
# 558 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }
    };
# 578 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 610 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 620 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
      operator bool() const { return _M_ok; }

    private:
      bool _M_ok;
    };
# 639 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 680 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 702 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }




      virtual
      ~basic_iostream() { }

    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
# 765 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/istream.tcc" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/istream.tcc" 3
       
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    { return __pf(*this); }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<short>::min() <= __l
        && __l <= numeric_limits<short>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<int>::min() <= __l
        && __l <= numeric_limits<int>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       if (!__copy_streambufs(this->rdbuf(), __sbout))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
          try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    streamsize __size = std::min(streamsize(__sb->egptr()
         - __sb->gptr()),
            __n - _M_gcount - 1);
    if (__size > 1)
      {
        const char_type* __p = traits_type::find(__sb->gptr(),
              __size,
              __delim);
        if (__p)
   __size = __p - __sb->gptr();
        traits_type::copy(__s, __sb->gptr(), __size);
        __s += __size;
        __sb->gbump(__size);
        _M_gcount += __size;
        __c = __sb->sgetc();
      }
    else
      {
        *__s++ = traits_type::to_char_type(__c);
        ++_M_gcount;
        __c = __sb->snextc();
      }
  }

       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __idelim))
  {
    ++_M_gcount;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c;

       if (__n != numeric_limits<streamsize>::max())
  --__n;
       while (_M_gcount <= __n
       && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))
  {
    ++_M_gcount;
    if (traits_type::eq_int_type(__c, __delim))
      break;
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template class basic_iostream<char>;
# 1190 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/istream.tcc" 3
}
# 772 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/istream" 2 3
# 47 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 2 3

namespace std
{
# 63 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;
# 77 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/iostream" 3
  static ios_base::Init __ioinit;
}
# 11 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 25 "C:/Enrique/Programas/MyApps/DRTECore/Object.h"
namespace DRTE
{
class Object : Stream
{
public:
 enum
 {
  NONE,
  WORLD,
  DIRECTIONAL_LIGHT,
  OMNI_LIGHT,
  CUBE,
  SPHERE,
  TORUS,
  C0NE,
  LINE,
  POINT,
  PLANE,
  CAMERA,
  MESH,
  TRIANGLE
 };

 int type;
 int group_id;


 Vector *normal;

 virtual Point* Intersection(Ray *ray){return __null;};
 Object();
 virtual ~Object();

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};



class World : Object
{
public:
 DRTE::Color* world_color;
 DRTE::Color* world_light;

 World();
 World(DRTE::Color* world_color,DRTE::Color* world_light);

 ~World();

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 2



namespace DRTE
{
class Camera : Object
{
private:





 int d_width;
 int d_height;

 int s_x;
 int s_y;
 int s_width;
 int s_height;

 int total_dirs;
 struct direction
 {
  float u;
  float v;
  float w;
 };
 void ReleaseMemory();
public:
# 42 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h"
 direction *directions;
 Vector *eye;
 Vector *lt;
 Vector *rt;
 Vector *lb;
 Camera();

 Camera(Vector* eye, Vector* lt, Vector* rt, Vector* lb);
 ~Camera();
 int SetDisplayDims(int d_width, int d_height);
 int SetSectorDims(int s_x, int s_y, int s_width, int s_height);

 Vector* Translate(int x,int y);
 int Rotate();
 Ray* GetRay(int x, int y);

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 11 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 12 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Camera.h" 2
# 4 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 2
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 3
       
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 2 3




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 1 3
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 2 3


namespace std
{





  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      struct _Vector_impl
 : public _Alloc {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl (_Alloc const& __a)
   : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const { return *static_cast<const _Alloc*>(&this->_M_impl); }

      _Vector_base(const allocator_type& __a) : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
 : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n) { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      { if (__p) _M_impl.deallocate(__p, __n); }
    };
# 140 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:





      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 191 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
          __n, __value); }
# 204 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      explicit
      vector(size_type __n)
      : _Base(__n, allocator_type())
      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
          __n, value_type()); }
# 219 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x.get_allocator())
      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(), __x.end(),
        this->_M_impl._M_start);
      }
# 240 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector() { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }
# 266 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 279 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 295 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin() { return iterator (this->_M_impl._M_start); }






      const_iterator
      begin() const { return const_iterator (this->_M_impl._M_start); }






      iterator
      end() { return iterator (this->_M_impl._M_finish); }






      const_iterator
      end() const { return const_iterator (this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const { return const_reverse_iterator(begin()); }



      size_type
      size() const { return size_type(end() - begin()); }


      size_type
      max_size() const { return size_type(-1) / sizeof(value_type); }
# 392 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size < size())
   erase(begin() + __new_size, end());
 else
   insert(end(), __new_size - size(), __x);
      }
# 411 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      resize(size_type __new_size) { resize(__new_size, value_type()); }





      size_type
      capacity() const
      { return size_type(const_iterator(this->_M_impl._M_end_of_storage) - begin()); }





      bool
      empty() const { return begin() == end(); }
# 446 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 461 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) { return *(begin() + __n); }
# 475 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const { return *(begin() + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 499 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      reference
      at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
# 513 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }





      reference
      front() { return *begin(); }





      const_reference
      front() const { return *begin(); }





      reference
      back() { return *(end() - 1); }





      const_reference
      back() const { return *(end() - 1); }
# 555 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     std::_Construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 576 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 std::_Destroy(this->_M_impl._M_finish);
      }
# 594 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 610 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 628 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 653 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 674 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 686 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
      }







      void
      clear() { erase(begin(), end()); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::uninitialized_copy(__first, __last, __result);
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
            __n, __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, input_iterator_tag)
        {
   for ( ; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, forward_iterator_tag)
        {
   size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish = std::uninitialized_copy(__first, __last,
          this->_M_impl._M_start);
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);
    };
# 874 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return __x.size() == __y.size() &&
             std::equal(__x.begin(), __x.end(), __y.begin());
    }
# 893 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_bvector.h" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_bvector.h" 3
namespace std
{
  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == _S_word_bit - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = _S_word_bit - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / _S_word_bit;
      __n = __n % _S_word_bit;
      if (__n < 0)
 {
   _M_offset = static_cast<unsigned int>(__n + _S_word_bit);
   --_M_p;
 }
      else
 _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }


  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  template<class _Alloc>
    class _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base() { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + _S_word_bit - 1) / _S_word_bit); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
       _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };
}




namespace std
{
# 414 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>
  {
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;

    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;

    allocator_type get_allocator() const
    { return _Bvector_base<_Alloc>::get_allocator(); }

  protected:
    using _Bvector_base<_Alloc>::_M_allocate;
    using _Bvector_base<_Alloc>::_M_deallocate;

  protected:
    void _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q
                                + (__n + _S_word_bit - 1) / _S_word_bit;
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
        / _S_word_bit;
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
    void _M_initialize_range(_InputIterator __first, _InputIterator __last,
                             input_iterator_tag)
    {
      this->_M_impl._M_start = iterator();
      this->_M_impl._M_finish = iterator();
      this->_M_impl._M_end_of_storage = 0;
      for ( ; __first != __last; ++__first)
        push_back(*__first);
    }

    template<class _ForwardIterator>
    void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                             forward_iterator_tag)
    {
      const size_type __n = std::distance(__first, __last);
      _M_initialize(__n);
      std::copy(__first, __last, this->_M_impl._M_start);
    }

    template<class _InputIterator>
    void _M_insert_range(iterator __pos, _InputIterator __first,
    _InputIterator __last, input_iterator_tag)
    {
      for ( ; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

    template<class _ForwardIterator>
    void _M_insert_range(iterator __position, _ForwardIterator __first,
    _ForwardIterator __last, forward_iterator_tag)
    {
      if (__first != __last)
 {
   size_type __n = std::distance(__first, __last);
   if (capacity() - size() >= __n)
     {
       std::copy_backward(__position, end(),
          this->_M_impl._M_finish + difference_type(__n));
       std::copy(__first, __last, __position);
       this->_M_impl._M_finish += difference_type(__n);
     }
   else
     {
       const size_type __len = size() + std::max(size(), __n);
       _Bit_type * __q = this->_M_allocate(__len);
       iterator __i = std::copy(begin(), __position, iterator(__q, 0));
       __i = std::copy(__first, __last, __i);
       this->_M_impl._M_finish = std::copy(__position, end(), __i);
       this->_M_deallocate();
       this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
                                  / _S_word_bit;
       this->_M_impl._M_start = iterator(__q, 0);
     }
 }
    }

  public:
    iterator begin()
    { return this->_M_impl._M_start; }

    const_iterator begin() const
    { return this->_M_impl._M_start; }

    iterator end()
    { return this->_M_impl._M_finish; }

    const_iterator end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator rend() const
    { return const_reverse_iterator(begin()); }

    size_type size() const
    { return size_type(end() - begin()); }

    size_type max_size() const
    { return size_type(-1); }

    size_type capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }
    bool empty() const
    { return begin() == end(); }

    reference operator[](size_type __n)
    { return *(begin() + difference_type(__n)); }

    const_reference operator[](size_type __n) const
    { return *(begin() + difference_type(__n)); }

    void _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

    reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    explicit vector(const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a) { }

    vector(size_type __n, bool __value,
    const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    explicit vector(size_type __n)
    : _Bvector_base<_Alloc>(allocator_type())
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, 0);
    }

    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator())
    {
      _M_initialize(__x.size());
      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    template<class _Integer>
    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
    }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_initialize_dispatch(__first, __last, _Integral());
    }

    ~vector() { }

    vector& operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      std::copy(__x.begin(), __x.end(), begin());
      this->_M_impl._M_finish = begin() + difference_type(__x.size());
      return *this;
    }






    void _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   erase(begin() + __n, end());
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    void assign(size_t __n, bool __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
    void assign(_InputIterator __first, _InputIterator __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_assign_dispatch(__first, __last, _Integral());
    }

    template<class _Integer>
    void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
    { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
    void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
       __false_type)
    { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    template<class _InputIterator>
    void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                       input_iterator_tag)
    {
      iterator __cur = begin();
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

    template<class _ForwardIterator>
    void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                       forward_iterator_tag)
    {
      const size_type __len = std::distance(__first, __last);
      if (__len < size())
        erase(std::copy(__first, __last, begin()), end());
      else
 {
   _ForwardIterator __mid = __first;
   std::advance(__mid, size());
   std::copy(__first, __mid, begin());
   insert(end(), __mid, __last);
 }
    }

    void reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = std::copy(begin(), end(),
           iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;
 }
    }

    reference front()
    { return *begin(); }

    const_reference front() const
    { return *begin(); }

    reference back()
    { return *(end() - 1); }

    const_reference back() const
    { return *(end() - 1); }

    void push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
    }


    static void swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator insert(iterator __position, bool __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }



    template<class _Integer>
    void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                            __true_type)
    { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
    void _M_insert_dispatch(iterator __pos,
                            _InputIterator __first, _InputIterator __last,
                            __false_type)
    { _M_insert_range(__pos, __first, __last,
        std::__iterator_category(__first)); }

    template<class _InputIterator>
    void insert(iterator __position,
                _InputIterator __first, _InputIterator __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_insert_dispatch(__position, __first, __last, _Integral());
    }

    void _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   std::fill_n(__i, __n, __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
                                     / _S_word_bit;
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void insert(iterator __position, size_type __n, bool __x)
    { _M_fill_insert(__position, __n, __x); }

    void pop_back()
    { --this->_M_impl._M_finish; }

    iterator erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator erase(iterator __first, iterator __last)
    {
      this->_M_impl._M_finish = std::copy(__last, end(), __first);
      return __first;
    }

    void resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        erase(begin() + difference_type(__new_size), end());
      else
        insert(end(), __new_size - size(), __x);
    }

    void flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void clear()
    { erase(begin(), end()); }
  };
}
# 73 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 2 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/vector.tcc" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/vector.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
            this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())
      {
        std::_Construct(this->_M_impl._M_finish, __x);
        ++this->_M_impl._M_finish;
      }
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      std::_Destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      iterator __i(std::copy(__last, end(), __first));
      std::_Destroy(__i, end());
      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp,_Alloc>&
    vector<_Tp,_Alloc>::
    operator=(const vector<_Tp,_Alloc>& __x)
    {
      if (&__x != this)
      {
        const size_type __xlen = __x.size();
        if (__xlen > capacity())
        {
          pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
          _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
          this->_M_impl._M_start = __tmp;
          this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
        }
        else if (size() >= __xlen)
        {
          iterator __i(std::copy(__x.begin(), __x.end(), begin()));
          std::_Destroy(__i, end());
        }
        else
        {
          std::copy(__x.begin(), __x.begin() + size(), this->_M_impl._M_start);
          std::uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_impl._M_finish);
        }
        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
      {
        vector __tmp(__n, __val, get_allocator());
        __tmp.swap(*this);
      }
      else if (__n > size())
      {
        std::fill(begin(), end(), __val);
        this->_M_impl._M_finish
   = std::uninitialized_fill_n(this->_M_impl._M_finish, __n - size(), __val);
      }
      else
        erase(fill_n(begin(), __n, __val), end());
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_InputIterator __first, _InputIterator __last, input_iterator_tag)
    {
      iterator __cur(begin());
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                  forward_iterator_tag)
    {
      size_type __len = std::distance(__first, __last);

      if (__len > capacity())
      {
        pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
        _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish = this->_M_impl._M_start + __len;
      }
      else if (size() >= __len)
      {
        iterator __new_finish(std::copy(__first, __last, this->_M_impl._M_start));
        std::_Destroy(__new_finish, end());
        this->_M_impl._M_finish = __new_finish.base();
      }
      else
      {
        _ForwardIterator __mid = __first;
        std::advance(__mid, size());
        std::copy(__first, __mid, this->_M_impl._M_start);
        this->_M_impl._M_finish = std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        std::_Construct(this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));
        ++this->_M_impl._M_finish;
        _Tp __x_copy = __x;
        std::copy_backward(__position,
      iterator(this->_M_impl._M_finish-2),
      iterator(this->_M_impl._M_finish-1));
        *__position = __x_copy;
      }
      else
      {
        const size_type __old_size = size();
        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
        iterator __new_start(this->_M_allocate(__len));
        iterator __new_finish(__new_start);
        try
          {
            __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),
         __position,
         __new_start);
            std::_Construct(__new_finish.base(), __x);
            ++__new_finish;
            __new_finish = std::uninitialized_copy(__position,
         iterator(this->_M_impl._M_finish),
         __new_finish);
          }
        catch(...)
          {
            std::_Destroy(__new_start,__new_finish);
            _M_deallocate(__new_start.base(),__len);
            throw;
          }
        std::_Destroy(begin(), end());
        _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __new_start.base();
        this->_M_impl._M_finish = __new_finish.base();
        this->_M_impl._M_end_of_storage = __new_start.base() + __len;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
      {
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
   {
           value_type __x_copy = __x;
    const size_type __elems_after = end() - __position;
    iterator __old_finish(this->_M_impl._M_finish);
    if (__elems_after > __n)
      {
        std::uninitialized_copy(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish);
        this->_M_impl._M_finish += __n;
        std::copy_backward(__position, __old_finish - __n, __old_finish);
        std::fill(__position, __position + __n, __x_copy);
      }
    else
      {
        std::uninitialized_fill_n(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy);
        this->_M_impl._M_finish += __n - __elems_after;
        std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);
        this->_M_impl._M_finish += __elems_after;
        std::fill(__position, __old_finish, __x_copy);
      }
   }
        else
   {
     const size_type __old_size = size();
     const size_type __len = __old_size + std::max(__old_size, __n);
     iterator __new_start(this->_M_allocate(__len));
     iterator __new_finish(__new_start);
     try
       {
  __new_finish = std::uninitialized_copy(begin(), __position,
             __new_start);
  __new_finish = std::uninitialized_fill_n(__new_finish, __n, __x);
  __new_finish = std::uninitialized_copy(__position, end(),
             __new_finish);
       }
     catch(...)
       {
  std::_Destroy(__new_start,__new_finish);
  _M_deallocate(__new_start.base(),__len);
  throw;
       }
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
     this->_M_impl._M_start = __new_start.base();
     this->_M_impl._M_finish = __new_finish.base();
     this->_M_impl._M_end_of_storage = __new_start.base() + __len;
   }
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __pos,
                    _InputIterator __first, _InputIterator __last,
                    input_iterator_tag)
    {
      for ( ; __first != __last; ++__first)
      {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __position,_ForwardIterator __first,
      _ForwardIterator __last, forward_iterator_tag)
    {
      if (__first != __last)
      {
        size_type __n = std::distance(__first, __last);
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
        {
          const size_type __elems_after = end() - __position;
          iterator __old_finish(this->_M_impl._M_finish);
          if (__elems_after > __n)
          {
            std::uninitialized_copy(this->_M_impl._M_finish - __n,
        this->_M_impl._M_finish,
        this->_M_impl._M_finish);
            this->_M_impl._M_finish += __n;
            std::copy_backward(__position, __old_finish - __n, __old_finish);
            std::copy(__first, __last, __position);
          }
          else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, __elems_after);
            std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);
            this->_M_impl._M_finish += __n - __elems_after;
            std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);
            this->_M_impl._M_finish += __elems_after;
            std::copy(__first, __mid, __position);
          }
        }
        else
        {
          const size_type __old_size = size();
          const size_type __len = __old_size + std::max(__old_size, __n);
          iterator __new_start(this->_M_allocate(__len));
          iterator __new_finish(__new_start);
          try
            {
              __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),
           __position, __new_start);
              __new_finish = std::uninitialized_copy(__first, __last,
           __new_finish);
              __new_finish = std::uninitialized_copy(__position,
           iterator(this->_M_impl._M_finish),
           __new_finish);
            }
          catch(...)
            {
              std::_Destroy(__new_start,__new_finish);
              _M_deallocate(__new_start.base(), __len);
              throw;
            }
          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
          _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
          this->_M_impl._M_start = __new_start.base();
          this->_M_impl._M_finish = __new_finish.base();
          this->_M_impl._M_end_of_storage = __new_start.base() + __len;
        }
      }
    }
}
# 76 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/vector" 2 3
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 2





namespace DRTE
{
class Light : Object
{
public:
 float intensity;
 Vector *center;
 Color* color;
 Light();
 Light(Vector *center, Color* color,float intensity);
 ~Light();
 Point* Illumination(Point *point, std::vector<Object *> *objects);
 int ApplyLight(Point *pt, float intensity);
 int ApplyShadow(Point *pt, float intensity);
 Point* Intersection(Ray *ray);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 5 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Sphere.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Sphere.h" 2



namespace DRTE
{
class Sphere : public Object
{
public:
 float r;
 Vector *center;

 Sphere();
 Sphere(Vector *center, float r, int group_id);
 ~Sphere();
 Point* Intersection(Ray *ray);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 6 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Triangle.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Triangle.h" 2



namespace DRTE
{
class Triangle : public Object
{
private:
 int intersect_triangle(float origin[3], float dir[3], float vert0[3], float vert1[3], float vert2[3], float *t, float *u, float *v);
 int CalcEdges();

public:
 Vector *v1;
 Vector *v2;
 Vector *v3;


 float edge1[3],edge2[3];
 float *vert0,*vert1,*vert2;

 Triangle();
 Triangle(Vector *v1, Vector *v2, Vector *v3, int group_id);
 ~Triangle();
 Point* Intersection(Ray *ray);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 7 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2



namespace DRTE
{
class Texture : Stream
{
public:

 enum
 {
  CHECKERS,
  FRACTAL,
  BITMAP
 };

 int type;


 Texture();
 Texture(int preset_id);
 ~Texture();

 int LoadPreset(int preset_id);
 int GetTexel(float x, float y, Color* color_out);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);

};
}
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2







namespace DRTE
{
class Material : Stream
{
public:

 enum
 {
  VACUUM,
  AIR,
  METAL,
  WATER,
  ICE,
  GLASS,
  DIAMOND,
  PLASTIC,
  OTHER
 };

 Color* diffuse_color;
 float refraction_index;
 float reflection_index;
 float transparency_index;
 float specular_index;
 int type;
 int id;
 int has_texture;
 Texture *texture;


 int LoadPreset(int preset_id);
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 int SetTexture(Texture *texture);

 Material(int id);
 Material(int id, Color* diffuse);
 Material(int id, Color* diffuse, int preset_id);
 Material(int id, Color* diffuse, float reflection, float transparency);
 ~Material();
};
}
# 10 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 11 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 2
# 14 "C:/Enrique/Programas/MyApps/DRTECore/Group.h"
namespace DRTE
{
class Group : Stream
{
public:

 int id;
 int material_id;
 int name_size;
 char* name;


 Group(int id, char* name);

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 ~Group();

};
}
# 12 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2



# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 1 3
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
       
# 44 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/basic_file.h" 1 3
# 42 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/basic_file.h" 3
       
# 43 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/mingw32/bits/basic_file.h" 3




namespace std
{

  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0);

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode);

      __basic_file*
      close();

      bool
      is_open() const;

      int
      fd();

      __c_file*
      file();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way);

      int
      sync();

      streamsize
      showmanyc();
    };
}
# 50 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 2 3


namespace std
{
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;







      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;


      friend class ios_base;

    protected:







      __c_lock _M_lock;







      __file_type _M_file;






      ios_base::openmode _M_mode;







      __state_type _M_state_beg;
# 135 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __state_type _M_state_cur;
# 144 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __state_type _M_state_last;






      char_type* _M_buf;
# 160 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      size_t _M_buf_size;







      bool _M_buf_allocated;
# 179 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      bool _M_reading;
      bool _M_writing;
# 190 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;
# 206 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      char* _M_ext_buf;






      streamsize _M_ext_buf_size;
# 222 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      const char* _M_ext_next;
      char* _M_ext_end;
# 232 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }
# 251 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(this->_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw() { return _M_file.is_open(); }
# 300 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 314 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __filebuf_type*
      close() throw();

    protected:





      void
      _M_allocate_internal_buffer();






      void
      _M_destroy_internal_buffer() throw();



      virtual streamsize
      showmanyc();







      virtual int_type
      underflow();


      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 364 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());
# 374 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      bool
      _M_convert_to_external(char_type*, streamsize);
# 389 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);


      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);







      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);


      virtual int
      sync();


      virtual void
      imbue(const locale& __loc);


      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);


      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);







      bool
      _M_terminate_output();
# 450 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = this->_M_mode & ios_base::in;
  const bool __testout = this->_M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);
 else
   this->setg(this->_M_buf, this->_M_buf, this->_M_buf);

 if (__testout && __off == 0 && this->_M_buf_size > 1 )
   this->setp(this->_M_buf, this->_M_buf + this->_M_buf_size - 1);
 else
   this->setp(__null, __null);
      }
    };
# 477 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 509 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 522 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_ifstream()
      { }
# 546 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 568 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 599 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 631 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 645 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_ofstream()
      { }
# 670 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 692 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 724 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 757 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 769 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(__null), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_fstream()
      { }
# 794 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 816 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
}


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/fstream.tcc" 1 3
# 38 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/fstream.tcc" 3
       
# 39 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/fstream.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !this->_M_buf)
 {
   this->_M_buf = new char_type[this->_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] this->_M_buf;
   this->_M_buf = __null;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = __null;
      _M_ext_buf_size = 0;
      _M_ext_next = __null;
      _M_ext_end = __null;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(__null), _M_buf_size(512),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = __null;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       this->_M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close() throw()
    {
      __filebuf_type* __ret = __null;
      if (this->is_open())
 {
   bool __testfail = false;
   try
     {
       if (!_M_terminate_output())
  __testfail = true;
     }
   catch(...)
     { __testfail = true; }


   this->_M_mode = ios_base::openmode(0);
   this->_M_pback_init = false;
   _M_destroy_internal_buffer();
   _M_reading = false;
   _M_writing = false;
   _M_set_buffer(-1);
   _M_state_last = _M_state_cur = _M_state_beg;

   if (!_M_file.close())
     __testfail = true;

   if (!__testfail)
     __ret = this;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();
   if (__check_facet(_M_codecvt).encoding() >= 0)
     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = this->_M_buf_size > 1
                           ? this->_M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      std::memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  std::memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend;
    __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
           _M_ext_end, _M_ext_next, this->eback(),
           this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>(_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {


   const bool __testpb = this->_M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = this->_M_mode & ios_base::out;
      if (__testout && !_M_reading)
 {
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (this->_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsgetn(_CharT* __s, streamsize __n)
     {

       streamsize __ret = 0;
       if (_M_pback_init)
  {
    if (__n > 0 && this->gptr() == this->eback())
      {
        *__s++ = *this->gptr();
        this->gbump(1);
        __ret = 1;
        --__n;
      }
    _M_destroy_pback();
  }




       const bool __testin = _M_mode & ios_base::in;
       const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;
       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
    && __testin && !_M_writing)
  {

    const streamsize __avail = this->egptr() - this->gptr();
    if (__avail != 0)
      {
        if (__avail == 1)
   *__s = *this->gptr();
        else
   traits_type::copy(__s, this->gptr(), __avail);
        __s += __avail;
        this->gbump(__avail);
        __ret += __avail;
        __n -= __avail;
      }



    streamsize __len;
    for (;;)
      {
        __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
          __n);
        if (__len == -1)
   __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

        if (__len == 0)
   break;

        __n -= __len;
        __ret += __len;
        if (__n == 0)
   break;

        __s += __len;
      }

    if (__n == 0)
      {
        _M_set_buffer(0);
        _M_reading = true;
      }
    else if (__len == 0)
      {



        _M_set_buffer(-1);
        _M_reading = false;
      }
  }
       else
  __ret += __streambuf_type::xsgetn(__s, __n);

       return __ret;
     }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsputn(const _CharT* __s, streamsize __n)
     {



       streamsize __ret = 0;
       const bool __testout = this->_M_mode & ios_base::out;
       if (__check_facet(_M_codecvt).always_noconv()
    && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && this->_M_buf_size > 1)
     __bufavail = this->_M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 if (__s == 0 && __n == 0)
   this->_M_buf_size = 1;
 else if (__s && __n > 0)
   {
# 643 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/fstream.tcc" 3
     this->_M_buf = __s;
     this->_M_buf_size = __n;
   }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {

   _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       if (_M_codecvt->always_noconv())
  __computed_off += this->gptr() - this->egptr();
       else
  {



    const int __gptr_off =
      _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
           this->gptr() - this->eback());
    __computed_off += _M_ext_buf + __gptr_off - _M_ext_end;



    __state = _M_state_last;
  }
     }
   __ret = _M_seek(__computed_off, __way, __state);
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {

   __ret = pos_type(_M_file.seekoff(__off, __way));
   _M_reading = false;
   _M_writing = false;
   _M_ext_next = _M_ext_end = _M_ext_buf;
   _M_set_buffer(-1);
   _M_state_cur = __state;
   __ret.state(_M_state_cur);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, this->_M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   std::memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }





  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;
# 889 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/fstream.tcc" 3
}
# 841 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/fstream" 2 3
# 16 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 3
       
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tree.h" 1 3
# 70 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tree.h" 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/cpp_type_traits.h" 1 3
# 40 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/cpp_type_traits.h" 3
       
# 41 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/cpp_type_traits.h" 3
# 69 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/cpp_type_traits.h" 3
namespace __gnu_internal
{
  typedef char __one;
  typedef char __two[2];

  template <typename _Tp>
  __one __test_type (int _Tp::*);
  template <typename _Tp>
  __two& __test_type (...);
}

namespace std
{

  template<typename, typename>
    struct __are_same
    {
      enum
 {
   _M_type = 0
 };
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum
 {
   _M_type = 1
 };
    };


  template<typename, bool>
    struct __enable_if
    {
    };

  template<typename _Tp>
    struct __enable_if<_Tp, true>
    {
      typedef _Tp _M_type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum
 {
   _M_type = 0
 };
    };

  template<>
    struct __is_void<void>
    {
      enum
 {
   _M_type = 1
 };
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum
 {
   _M_type = 0
 };
    };




  template<>
    struct __is_integer<bool>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<char>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<signed char>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum
 {
   _M_type = 1
 };
    };
# 194 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<int>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<long>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<long long>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum
 {
   _M_type = 1
 };
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum
 {
   _M_type = 0
 };
    };


  template<>
    struct __is_floating<float>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_floating<double>
    {
      enum
 {
   _M_type = 1
 };
    };

  template<>
    struct __is_floating<long double>
    {
      enum
 {
   _M_type = 1
 };
    };




  template<typename _Tp>
    struct __is_arithmetic
    {
      enum
 {
   _M_type = __is_integer<_Tp>::_M_type || __is_floating<_Tp>::_M_type
 };
    };




  template<typename _Tp>
    struct __is_fundamental
    {
      enum
 {
   _M_type = __is_void<_Tp>::_M_type || __is_arithmetic<_Tp>::_M_type
 };
    };




  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   _M_type = (sizeof(__gnu_internal::__test_type<_Tp>(0))
       != sizeof(__gnu_internal::__one))
 };
    };

}
# 71 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tree.h" 2 3

namespace std
{
# 90 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                       _Rb_tree_node_base*& __root);

  void
  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                        _Rb_tree_node_base*& __root);

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef const _Rb_tree_node* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

    protected:
      _Rb_tree_node*
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Rb_tree_node* __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { std::_Construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      destroy_node(_Link_type __p)
      {
 std::_Destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = std::__is_pod<_Key_compare>::_M_type>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };



      template<typename _Key_compare>
        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator
 {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      { return static_cast<_Const_Link_type>(this->_M_impl._M_header._M_parent); }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

    public:

      _Rb_tree()
      { }

      _Rb_tree(const _Compare& __comp)
      : _M_impl(allocator_type(), __comp)
      { }

      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
      : _M_impl(__a, __comp)
      { }

      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)
      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&
      operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const
      { return static_cast<_Const_Link_type>(this->_M_impl._M_header._M_left); }

      iterator
      end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      const_iterator
      end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return size_type(-1); }

      void
      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t);


      pair<iterator,bool>
      insert_unique(const value_type& __x);

      iterator
      insert_equal(const value_type& __x);

      iterator
      insert_unique(iterator __position, const value_type& __x);

      iterator
      insert_equal(iterator __position, const value_type& __x);

      template<typename _InputIterator>
      void
      insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
      void
      insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __x);

      const_iterator
      find(const key_type& __x) const;

      size_type
      count(const key_type& __x) const;

      iterator
      lower_bound(const key_type& __x);

      const_iterator
      lower_bound(const key_type& __x) const;

      iterator
      upper_bound(const key_type& __x);

      const_iterator
      upper_bound(const key_type& __x) const;

      pair<iterator,iterator>
      equal_range(const key_type& __x);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
        const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
        const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
        const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
        const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
  _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      _Link_type __z = _M_create_node(__v);
      bool __insert_left;

      __insert_left = __x != 0 || __p == _M_end()
               || _M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(__p));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t)
    {
      if (_M_root() == 0)
      {
 if (__t._M_root() != 0)
 {
   _M_root() = __t._M_root();
   _M_leftmost() = __t._M_leftmost();
   _M_rightmost() = __t._M_rightmost();
          _M_root()->_M_parent = _M_end();

   __t._M_root() = 0;
   __t._M_leftmost() = __t._M_end();
   __t._M_rightmost() = __t._M_end();
 }
      }
      else if (__t._M_root() == 0)
      {
 __t._M_root() = _M_root();
 __t._M_leftmost() = _M_leftmost();
 __t._M_rightmost() = _M_rightmost();
        __t._M_root()->_M_parent = __t._M_end();

 _M_root() = 0;
 _M_leftmost() = _M_end();
 _M_rightmost() = _M_end();
      }
      else
      {
 std::swap(_M_root(),__t._M_root());
 std::swap(_M_leftmost(),__t._M_leftmost());
 std::swap(_M_rightmost(),__t._M_rightmost());

 _M_root()->_M_parent = _M_end();
 __t._M_root()->_M_parent = __t._M_end();
      }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,
    bool>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 if (__j == begin())
   return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
 else
   --__j;
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator,bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_leftmost())
 {

   if (size() > 0
       && _M_impl._M_key_compare(_KeyOfValue()(__v),
     _S_key(__position._M_node)))
     return _M_insert(__position._M_node, __position._M_node, __v);

   else
     return insert_unique(__v).first;
 }
      else if (__position._M_node == _M_end())
 {

   if (_M_impl._M_key_compare(_S_key(_M_rightmost()),
         _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_unique(__v).first;
 }
      else
 {
   iterator __before = __position;
   --__before;
   if (_M_impl._M_key_compare(_S_key(__before._M_node),
         _KeyOfValue()(__v))
       && _M_impl._M_key_compare(_KeyOfValue()(__v),
     _S_key(__position._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node, __position._M_node, __v);

     }
   else
     return insert_unique(__v).first;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_equal(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_leftmost())
 {

   if (size() > 0
       && !_M_impl._M_key_compare(_S_key(__position._M_node),
      _KeyOfValue()(__v)))
     return _M_insert(__position._M_node, __position._M_node, __v);

   else
     return insert_equal(__v);
 }
      else if (__position._M_node == _M_end())
 {

   if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_equal(__v);
 }
      else
 {
   iterator __before = __position;
   --__before;
   if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__before._M_node))
       && !_M_impl._M_key_compare(_S_key(__position._M_node),
      _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node, __position._M_node, __v);

     }
   else
     return insert_equal(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
      insert_equal(_II __first, _II __last)
      {
 for ( ; __first != __last; ++__first)
   insert_equal(*__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
    void
    _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
    insert_unique(_II __first, _II __last)
    {
      for ( ; __first != __last; ++__first)
 insert_unique(*__first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase(__position._M_node,
            this->_M_impl._M_header));
      destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)
    {
      pair<iterator,iterator> __p = equal_range(__x);
      size_type __n = std::distance(__p.first, __p.second);
      erase(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last) erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      iterator __j = iterator(__y);
      return (__j == end()
   || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    find(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

     while (__x != 0)
       {
  if (!_M_impl._M_key_compare(_S_key(__x), __k))
    __y = __x, __x = _S_left(__x);
  else
    __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end()
   || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,
      _Compare,_Alloc>::iterator,
  typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KoV,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    { return pair<const_iterator, const_iterator>(lower_bound(__k),
        upper_bound(__k)); }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
}
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 1 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
namespace std
{

  template<class _Key, class _Compare = less<_Key>,
    class _Alloc = allocator<_Key> >
    class set;

  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const set<_Key,_Compare,_Alloc>& __x,
        const set<_Key,_Compare,_Alloc>& __y);

  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const set<_Key,_Compare,_Alloc>& __x,
       const set<_Key,_Compare,_Alloc>& __y);
# 106 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    class set
    {

     
     


    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;


    private:
      typedef _Rb_tree<key_type, value_type,
         _Identity<value_type>, key_compare, _Alloc> _Rep_type;
      _Rep_type _M_t;
    public:


      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::allocator_type allocator_type;




      set()
      : _M_t(_Compare(), allocator_type()) {}







      explicit set(const _Compare& __comp,
     const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) {}
# 171 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
        : _M_t(_Compare(), allocator_type())
        { _M_t.insert_unique(__first, __last); }
# 187 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t.insert_unique(__first, __last); }
# 201 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      set(const set<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 211 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      set<_Key,_Compare,_Alloc>&
      operator=(const set<_Key, _Compare, _Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }





      iterator
      begin() const
      { return _M_t.begin(); }





      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 293 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      void
      swap(set<_Key,_Compare,_Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 311 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      pair<iterator,bool>
      insert(const value_type& __x)
      {
 pair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x);
 return pair<iterator, bool>(__p.first, __p.second);
      }
# 337 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 return _M_t.insert_unique((_Rep_iterator&)__position, __x);
      }
# 352 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      template<class _InputIterator>
      void
      insert(_InputIterator __first, _InputIterator __last)
      { _M_t.insert_unique(__first, __last); }
# 366 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      void
      erase(iterator __position)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 _M_t.erase((_Rep_iterator&)__position);
      }
# 384 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x) { return _M_t.erase(__x); }
# 398 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);
      }







      void
      clear()
      { _M_t.clear(); }
# 425 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 443 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 464 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 480 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 505 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
      pair<iterator,iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      pair<const_iterator,const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<class _K1, class _C1, class _A1>
        friend bool
        operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);

      template<class _K1, class _C1, class _A1>
        friend bool
        operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);
    };
# 534 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const set<_Key,_Compare,_Alloc>& __x,
        const set<_Key,_Compare,_Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 551 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const set<_Key,_Compare,_Alloc>& __x,
       const set<_Key,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const set<_Key,_Compare,_Alloc>& __x,
        const set<_Key,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const set<_Key,_Compare,_Alloc>& __x,
       const set<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const set<_Key,_Compare,_Alloc>& __x,
        const set<_Key,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const set<_Key,_Compare,_Alloc>& __x,
        const set<_Key,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline void
    swap(set<_Key,_Compare,_Alloc>& __x, set<_Key,_Compare,_Alloc>& __y)
    { __x.swap(__y); }

}
# 68 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 2 3
# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 1 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
namespace std
{


  template <class _Key, class _Compare = less<_Key>,
     class _Alloc = allocator<_Key> >
    class multiset;

  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const multiset<_Key,_Compare,_Alloc>& __x,
        const multiset<_Key,_Compare,_Alloc>& __y);

  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y);
# 104 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    class multiset
    {

     
     


    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;

    private:

      typedef _Rb_tree<key_type, value_type,
         _Identity<value_type>, key_compare, _Alloc> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::allocator_type allocator_type;






      multiset()
      : _M_t(_Compare(), allocator_type()) { }

      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 164 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t.insert_equal(__first, __last); }
# 180 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t.insert_equal(__first, __last); }
# 194 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      multiset(const multiset<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 204 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      multiset<_Key,_Compare,_Alloc>&
      operator=(const multiset<_Key,_Compare,_Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 288 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      void
      swap(multiset<_Key,_Compare,_Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 304 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t.insert_equal(__x); }
# 328 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 return _M_t.insert_equal((_Rep_iterator&)__position, __x);
      }
# 343 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      template <class _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t.insert_equal(__first, __last); }
# 358 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 _M_t.erase((_Rep_iterator&)__position);
      }
# 376 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 391 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      {
 typedef typename _Rep_type::iterator _Rep_iterator;
 _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);
      }







      void
      clear()
      { _M_t.clear(); }
# 415 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 433 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 454 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 470 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 495 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
      pair<iterator,iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      pair<const_iterator,const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <class _K1, class _C1, class _A1>
        friend bool
        operator== (const multiset<_K1,_C1,_A1>&,
      const multiset<_K1,_C1,_A1>&);

      template <class _K1, class _C1, class _A1>
        friend bool
        operator< (const multiset<_K1,_C1,_A1>&,
     const multiset<_K1,_C1,_A1>&);
    };
# 525 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const multiset<_Key,_Compare,_Alloc>& __x,
        const multiset<_Key,_Compare,_Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 542 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const multiset<_Key,_Compare,_Alloc>& __x,
        const multiset<_Key,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const multiset<_Key,_Compare,_Alloc>& __x,
        const multiset<_Key,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const multiset<_Key,_Compare,_Alloc>& __x,
        const multiset<_Key,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline void
    swap(multiset<_Key,_Compare,_Alloc>& __x,
  multiset<_Key,_Compare,_Alloc>& __y)
    { __x.swap(__y); }

}
# 69 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/set" 2 3
# 18 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2






# 1 "C:/Enrique/Programas/MyApps/DRTECore/MS3DFile.h" 1





#pragma pack(1)


typedef unsigned char byte;



typedef unsigned short word;


typedef struct
{
    char id[10];
    int version;
} ms3d_header_t;

typedef struct
{
    byte flags;
    float vertex[3];
    char boneId;
    byte referenceCount;
} ms3d_vertex_t;

typedef struct
{
    word flags;
    word vertexIndices[3];
    float vertexNormals[3][3];
    float s[3];
    float t[3];
    byte smoothingGroup;
    byte groupIndex;
} ms3d_triangle_t;

typedef struct
{
 word edgeIndices[2];
} ms3d_edge_t;

typedef struct
{
    byte flags;
    char name[32];
    word numtriangles;
 word* triangleIndices;
    char materialIndex;
} ms3d_group_t;

typedef struct
{
    char name[32];
    float ambient[4];
    float diffuse[4];
    float specular[4];
    float emissive[4];
    float shininess;
    float transparency;
    char mode;
    char texture[128];
    char alphamap[128];
} ms3d_material_t;

typedef struct
{
    float time;
    float rotation[3];
} ms3d_keyframe_rot_t;

typedef struct
{
    float time;
    float position[3];
} ms3d_keyframe_pos_t;

typedef struct
{
    byte flags;
    char name[32];
    char parentName[32];
    float rotation[3];
    float position[3];

    word numKeyFramesRot;
    word numKeyFramesTrans;

 ms3d_keyframe_rot_t* keyFramesRot;
    ms3d_keyframe_pos_t* keyFramesTrans;
} ms3d_joint_t;


#pragma pack()

class CMS3DFileI;
class CMS3DFile
{
public:
 CMS3DFile();
 virtual ~CMS3DFile();

public:
 bool LoadFromFile(const char* lpszFileName);
 void Clear();

 int GetNumVertices();
 void GetVertexAt(int nIndex, ms3d_vertex_t **ppVertex);
 int GetNumTriangles();
 void GetTriangleAt(int nIndex, ms3d_triangle_t **ppTriangle);
 int GetNumEdges();
 void GetEdgeAt(int nIndex, ms3d_edge_t **ppEdge);
 int GetNumGroups();
 void GetGroupAt(int nIndex, ms3d_group_t **ppGroup);
 int GetNumMaterials();
 void GetMaterialAt(int nIndex, ms3d_material_t **ppMaterial);
 int GetNumJoints();
 void GetJointAt(int nIndex, ms3d_joint_t **ppJoint);
 int FindJointByName(const char* lpszName);

 float GetAnimationFPS();
 float GetTickCount();
 int GetTotalFrames();

private:
 CMS3DFileI *_i;

private:
 CMS3DFile(const CMS3DFile& rhs);
 CMS3DFile& operator=(const CMS3DFile& rhs);
};
# 25 "C:/Enrique/Programas/MyApps/DRTECore/DRTEScene.h" 2

namespace DRTE
{
class DRTEScene : Stream
{
private:
 int Mesh(Object *object);





 CMS3DFile *ms3dfile;

public:
 World *world;

 int num_cameras;
 int num_lights;
 int num_objects;
 int num_materials;
 int num_groups;







 Upp::Vector<Camera *> *cameras;
 Upp::Vector<Light *> *lights;
 Upp::Vector<Object *> *objects;
 Upp::Vector<Material *> *materials;
 Upp::Vector<Group *> *groups;

 DRTEScene();
 ~DRTEScene();
 int Demo();
 int LoadScene(const char* filename);
 int AddTriangles(ms3d_group_t* ms3dgroup);
 Sphere* CreateSphere(ms3d_group_t* ms3dgroup);
 Light* CreateLightFromSphere(ms3d_group_t* ms3dgroup,CMS3DFile* ms3dfile);
 int CreateLightsFromMesh(ms3d_group_t* ms3dgroup,CMS3DFile* ms3dfile);
 int DeleteAll();

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
};
}
# 13 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Group.h" 2
# 14 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Image.h" 1




namespace DRTE
{
class Image
{
public:
 int width;
 int height;
 char* data;
};
}
# 15 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Light.h" 2
# 16 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 17 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Texture.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Material.h" 2
# 18 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/MS3DFile.h" 1
# 19 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 1
# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 2 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2



# 1 "C:/upp/uppsrc/Web/Web.h" 1
# 10 "C:/upp/uppsrc/Web/Web.h"
# 1 "C:/upp/mingw/include/winsock2.h" 1
# 11 "C:/upp/uppsrc/Web/Web.h" 2

typedef int socklen_t;
# 33 "C:/upp/uppsrc/Web/Web.h"
namespace Upp {

# 1 "C:/upp/uppsrc/Web/util.h" 1



bool IsSameTextFile(const char *p, const char *q);
String StringSample(const char *s, int limit);
String FormatIP(dword _ip);
String UrlEncode(String s);
String UrlEncode(String s, const char *specials);
String UrlDecode(String s);
String GetRandomIdent(int length);
String OtpEncode(String password, String otp_key);
String EncryptString(String password, String otp_key);
String BinHexEncode(const char *b, const char *e);
inline String BinHexEncode(String data) { return BinHexEncode(data.Begin(), data.End()); }
String BinHexDecode(const char *b, const char *e);
inline String BinHexDecode(String data) { return BinHexDecode(data.Begin(), data.End()); }
String Base64Encode(const char *b, const char *e);
inline String Base64Encode(String data) { return Base64Encode(data.Begin(), data.End()); }
String Base64Decode(const char *b, const char *e);
inline String Base64Decode(String data) { return Base64Decode(data.Begin(), data.End()); }
String ASCII85Encode(const byte *p, int length);
inline String ASCII85Encode(String s) { return ASCII85Encode(s, s.GetLength()); }
String ASCII85Decode(const byte *p, int length);
inline String ASCII85Decode(String s) { return ASCII85Decode(s, s.GetLength()); }
dword AddCRC(dword crc, const byte *data, int count);
inline dword AddCRC(dword crc, String s) { return AddCRC(crc, s, s.GetLength()); }
inline dword GetCRC(const byte *data, int count) { return AddCRC(0x80000000, data, count); }
inline dword GetCRC(String s) { return AddCRC(0x80000000, s, s.GetLength()); }
int LocateLine(String old_file, int old_line, String new_file);
void AppVersion(const char *ver);
String MD5Digest(const char *text, int length);
inline String MD5Digest(String s) { return MD5Digest(s.Begin(), s.GetLength()); }



class RefBase
{
public:
 RefBase()
 {
  refcount = 0;



 }

 RefBase(const RefBase& rb)
 {
  refcount = 0;



 }

 virtual ~RefBase()
 {
  ;
 }

 void AddRef() const { if(this) AtomicInc(refcount); }
 int GetRefCount() const { return AtomicXAdd(refcount, 0); }
 void Release() const { if(this && !AtomicDec(refcount)) delete this; }




private:
 mutable Atomic refcount;





private:
 RefBase& operator = (const RefBase& rb) { ; return *this; }
};

template <class T>
class RefCon : Moveable< RefCon<T> >
{
public:
 RefCon(const Nuller& = Null) : t(0) {}
 RefCon(const T *t);
 RefCon(const RefCon<T>& rp);
 ~RefCon();

 void Clear() { if(t) { t->Release(); t = __null; } }
 bool IsNullInstance() const { return !t; }

 RefCon<T>& operator = (const RefCon<T>& rp);

 bool operator ! () const { return !t; }
 const T *Get() const { return t; }
 const T *operator ~ () const { return t; }
 const T *operator -> () const { ; return t; }
 const T& operator * () const { ; return *t; }

 String ToString() const { return t ? AsString(*t) : String("NULL"); }

 friend bool operator == (RefCon<T> a, RefCon<T> b) { return a.t == b.t; }
 friend bool operator != (RefCon<T> a, RefCon<T> b) { return a.t != b.t; }
 friend unsigned GetHashValue(RefCon<T> r) { return GetHashValue(r.t); }

protected:
 const T *t;
};

template <class T>
RefCon<T>::RefCon(const T *t)
: t(t)
{
 t->AddRef();




}

template <class T>
RefCon<T>::RefCon(const RefCon<T>& rp)
: t(rp.t)
{ t->AddRef(); }

template <class T>
RefCon<T>::~RefCon()
{




 t->Release();
}

template <class T>
RefCon<T>& RefCon<T>::operator = (const RefCon<T>& rp)
{
 const T *old = t;
 t = rp.t;
 t->AddRef();




 old->Release();
 return *this;
}

template <class T>
class RefPtr : public RefCon<T>, public Moveable< RefPtr<T> >
{
public:
 RefPtr(const Nuller& = Null) {}
 RefPtr(T *t) : RefCon<T>(t) {}
 RefPtr(const RefPtr<T>& rp) : RefCon<T>(rp) {}

 RefPtr<T>& operator = (const RefPtr<T>& rp) { RefCon<T>::operator = (rp); return *this; }

 T *Get() const { return const_cast<T *>(this->t); }
 T *operator ~ () const { return Get(); }
 T *operator -> () const { ; return Get(); }
 T& operator * () const { ; return *Get(); }
};

template <class T>
class RefValueRep : public RawValueRep<T>
{
public:
 RefValueRep(T v) : RawValueRep<T>(v) {}

 virtual bool IsNull() const { return this->v == 0; }
 virtual unsigned GetHashValue() const { return (unsigned)~this->v; }
 virtual bool IsEqual(const Value::Void *p);
 virtual String AsString() { return !!this->v ? Upp::AsString(*this->v) : String(Null); }

 static const RawValueRep<T> *Cast(const Value::Void *p)
 { ; return (const RawValueRep<T> *)p; }
};

template <class T>
bool RefValueRep<T>::IsEqual(const Value::Void *p)
{
 const RawValueRep<T> *cast = dynamic_cast<const RawValueRep<T> *>(p);
 return cast && cast->Get() == this->v;
}

template <class T>
class RefPCValue : public Value
{
protected:
 typedef RefValueRep<T> Rep;

public:
 RefPCValue(T x) : Value(new Rep(x)) {}
 static T Get(const Value& v) { return Upp::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
 static T Extract(const Value& v) { return Upp::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
};

template <class T>
inline Value RefConToValue(RefCon<T> p) { return RefPCValue< RefCon<T> >(p); }

template <class T>
inline Value RefPtrToValue(RefPtr<T> p) { return RefPCValue< RefPtr<T> >(p); }

class HttpQuery
{
private:
 class Data : public RefBase
 {
 public:
  Data() {}
  Data(const Data& d) : map(d.map, 0) {}

  VectorMap<String, String> map;
 };

public:
 HttpQuery(const Nuller& = Null) : data(Empty()) {}
 explicit HttpQuery(String url) { data = Empty(); SetURL(url); }

 void Serialize(Stream& stream);

 String GetHidden() const;
 String GetQuery(bool empty = false) const;
 String GetQuery(HttpQuery patch, bool empty = false) const;

 void Clear() { data = Empty(); }

 bool IsEmpty() const { return data -> map.IsEmpty(); }
 bool IsEmpty(String key) const;

 int GetCount() const { return data -> map.GetCount(); }
 int Find(String key) const { return data -> map.Find(key); }
 String GetKey(int i) const { return data -> map.GetKey(i); }
 String GetValue(int i) const { return data -> map[i]; }
 bool IsInternal(int i) const;

 void Get(String key, Ref p1) const;
 HttpQuery& SetValue(String key, Value v);
 HttpQuery& Set(String key, String value);
 HttpQuery& SetRaw(String key, String value);

 bool GetBool(String key) const;
 bool GetBool(String key, bool dflt) const;
 HttpQuery& SetBool(String key, bool b);

 int GetInt(String key) const;
 int GetInt(String key, int min, int max, int dflt = 0) const;
 HttpQuery& SetInt(String key, int i);

 double GetDouble(String key) const;
 double GetDouble(String key, double min, double max, double dflt = Null) const;
 HttpQuery& SetDouble(String key, double f);

 String GetString(String key) const;
 String GetString(String key, String dflt) const;
 HttpQuery& SetString(String key, String s) { return Set(key, s); }

 Date GetDate(String key) const;
 Date GetDate(String key, Date dflt) const { return Nvl(GetDate(key), dflt); }
 HttpQuery& SetDate(String key, Date d);

 Time GetTime(String key) const;
 Time GetTime(String key, Time dflt) const { return Nvl(GetTime(key), dflt); }
 HttpQuery& SetTime(String key, Time t);

 Color GetColor(String key) const;
 Color GetColor(String key, Color dflt) const { return Nvl(GetColor(key), dflt); }
 HttpQuery& SetColor(String key, Color c);

 HttpQuery& Set(HttpQuery query);
 HttpQuery& SetURL(String url);

 HttpQuery& Remove(String key);
 HttpQuery& Remove(const Vector<String>& keys);
 HttpQuery& Remove(const Vector<Id>& keys);

 String ToString() const;

private:
 static RefPtr<Data> Empty();
 void Clone() { if(data -> GetRefCount() > 1) data = new Data(*data); }

private:
 RefPtr<Data> data;
};
# 36 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/html.h" 1







String ToHtml(const char *s);

class HtmlTag;

class Htmls : public String, Moveable<Htmls> {
public:
 bool IsNullInstance() const { return IsEmpty(); }

 Htmls& Text(const char *s);
 Htmls& Quote(const char *text);

 Htmls& Color(class Color color);
 Htmls& Percent(double d);

 Htmls& Color(const char *name, class Color color);
 Htmls& Percent(const char *name, double d);

 Htmls& Attr(const char *attr);
 Htmls& Attr(const char *attr, const char *s);
 Htmls& Attr(const char *attr, String s);
 Htmls& Attr(const char *attr, int i);
 Htmls& Attr(const char *attr, double d);
 Htmls& Attr(const char *attr, Date date);
 Htmls& Attr(const char *attr, Value v);

 Htmls& Attp(const char *attr, double val_or_percent);
 Htmls& Atth(const char *attr, const char *href);

 Htmls& Tag(const char *tag);
 Htmls& Gat();

 Htmls& Cat(const HtmlTag& tag);
 Htmls& Cat(String s) { String::Cat(s); return *this; }
 Htmls& Cat(const char *s) { String::Cat(s); return *this; }
 Htmls& Cat(char c) { String::Cat(c); return *this; }
 Htmls& Cat(const char *s, int n) { String::Cat(s, n); return *this; }

 Htmls& Nbsp();
 Htmls& Br();
 Htmls& Hr();
 Htmls& Lf();

 Htmls(const char *s) : String(s) {}
 Htmls(const String& s) : String(s) {}
 Htmls() {}
 Htmls(const Nuller&) {}
};

class HtmlTag : Moveable<HtmlTag> {
protected:
 Htmls tag;
 String end;

public:
 HtmlTag& Text(const char *s) { tag.Text(s); return *this; }
 HtmlTag& Quote(const char *s) { tag.Quote(s); return *this; }

 HtmlTag& Percent(double d) { tag.Percent(d); return *this; }

 HtmlTag& Color(const char *name, class Color color) { tag.Color(name, color); return *this; }
 HtmlTag& Percent(const char *name, double d) { tag.Percent(name, d); return *this; }

 HtmlTag& Attr(const char *attr) { tag.Attr(attr); return *this; }
 HtmlTag& Attr(const char *attr, const char *v) { tag.Attr(attr, v); return *this; }
 HtmlTag& Attr(const char *attr, String v) { tag.Attr(attr, v); return *this; }
 HtmlTag& Attr(const char *attr, int v) { tag.Attr(attr, v); return *this; }
 HtmlTag& Attr(const char *attr, double v) { tag.Attr(attr, v); return *this; }
 HtmlTag& Attr(const char *attr, Date v) { tag.Attr(attr, v); return *this; }
 HtmlTag& Attr(const char *attr, const Value& v) { tag.Attr(attr, v); return *this; }

 HtmlTag& Attp(const char *attr, double vp) { tag.Attp(attr, vp); return *this; }
 HtmlTag& Atth(const char *attr, const char *href) { tag.Atth(attr, href); return *this; }

 HtmlTag& Type(const char *s);

 HtmlTag& Name(const char *s);
 HtmlTag& Name(String id);

 HtmlTag& Data(const char *v);
 HtmlTag& Data(String v);
 HtmlTag& Data(double d);
 HtmlTag& Data(Value v);

 HtmlTag& ReadOnly();
 HtmlTag& Multiple();
 HtmlTag& Selected();

 HtmlTag& Align(Alignment align);
 HtmlTag& Left();
 HtmlTag& Right();
 HtmlTag& Center();

 HtmlTag& VAlign(Alignment align);
 HtmlTag& Top();
 HtmlTag& VCenter();
 HtmlTag& Bottom();

 HtmlTag& HotKey(char c);

 HtmlTag& Size(int c);
 HtmlTag& Size(int cx, int cy);

 HtmlTag& Color(class Color color);
 HtmlTag& BorderColor(class Color color);
 HtmlTag& BgColor(class Color color);

 HtmlTag& Face(const char *s);
 HtmlTag& Border(int i);
 HtmlTag& CellSpacing(int i);
 HtmlTag& CellPadding(int i);

 HtmlTag& Width(double d);
 HtmlTag& Height(double d);

 HtmlTag& RowSpan(int i);
 HtmlTag& ColSpan(int i);

 HtmlTag& Class(const char *s);
 HtmlTag& DataFld(const char *s);
 HtmlTag& DataSrc(const char *s);
 HtmlTag& Href(const char *s);
 HtmlTag& HtmlId(const char *s);
 HtmlTag& Lang(const char *s);
 HtmlTag& Language(const char *s);
 HtmlTag& JavaScript();
 HtmlTag& VbScript();
 HtmlTag& Methods(const char *s);
 HtmlTag& Rel(const char *s);
 HtmlTag& Rev(const char *s);
 HtmlTag& Style(const char *s);
 HtmlTag& TabIndex(int i);
 HtmlTag& Target(const char *s);
 HtmlTag& TargetBlank();
 HtmlTag& TargetParent();
 HtmlTag& TargetSelf();
 HtmlTag& TargetTop();
 HtmlTag& Title(const char *s);
 HtmlTag& Urn(const char *s);
 HtmlTag& Alt(const char *s);
 HtmlTag& Coords(const char *s);
 HtmlTag& NoHref();
 HtmlTag& Shape(const char *s);
 HtmlTag& ShapeCirc();
 HtmlTag& ShapePoly();
 HtmlTag& ShapeRect();
 HtmlTag& Balance(double v);
 HtmlTag& Loop(int i);
 HtmlTag& Volume(double v);
 HtmlTag& Src(const char *s);
 HtmlTag& Alink(class Color c);
 HtmlTag& Vlink(class Color c);
 HtmlTag& Link(class Color c);
 HtmlTag& Background(const char *s);

 HtmlTag& OnClick(const char *js);

 Htmls GetTag() const;
 Htmls GetEndTag() const;

 void Combine(const HtmlTag& tag);

 Htmls ApplyTo(String s) const;
 Htmls ApplyTo(const char *s) const;

 HtmlTag& PairTag(const char *s);
 HtmlTag& SingleTag(const char *s);

 HtmlTag operator()() const { return *this; }
 Htmls operator~() const { return ApplyTo(Null); }
 operator Htmls() const { return ApplyTo(Null); }
 String ToString() const { return ApplyTo(Null); }

 const Htmls& Tag() const { return tag; }
 Htmls& Tag() { return tag; }

 const String& End() const { return end; }
 String& End() { return end; }

 bool IsEmpty() const { return tag.IsEmpty(); }

 HtmlTag(const char *s);
 HtmlTag() {}
};

HtmlTag HtmlSingleTag(const char *s);
HtmlTag HtmlInput(const char *type, const char *name = 0);
HtmlTag HtmlEdit(String name);
HtmlTag HtmlEdit(String name, int size, int maxlength = 256,
                 const char *defaultValue = 0, bool password = false);

HtmlTag HtmlHidden(String name, Value val);
HtmlTag HtmlHidden(const char *name, Value val);
HtmlTag HtmlHidden(Value val);

HtmlTag HtmlSubmit(const char *text);

HtmlTag HtmlSelect(String name);
Htmls HtmlOption(Value val, const char *text, bool selected = false);

HtmlTag HtmlTable();
HtmlTag HtmlRow();
HtmlTag HtmlCell();

HtmlTag HtmlHeader(const char *title, String css = Null, const char *other = __null);



HtmlTag HtmlLink(const char *link);

Htmls HtmlBlock(Htmls html, double width,
                  double left, double top = 0, double right = 0, double bottom = 0,
                  Alignment align = ALIGN_LEFT);

inline Htmls& operator<<(Htmls& s, const HtmlTag& tag) { s.Cat(tag); return s; }
inline Htmls& operator<<(Htmls& s, const Htmls& v) { s.Cat(v); return s; }
inline Htmls& operator<<(Htmls& s, String v) { s.Cat(v); return s; }
inline Htmls& operator<<(Htmls& s, const char *v) { s.Cat(v); return s; }

inline Htmls& operator+=(Htmls& s, const HtmlTag& tag) { s.Cat(tag); return s; }

Htmls operator+(const HtmlTag& tag1, const HtmlTag& tag2);
Htmls operator+(const String& s, const HtmlTag& tag);
Htmls operator+(const HtmlTag& tag, const String& s);
Htmls operator+(const char *s, const HtmlTag& tag);
Htmls operator+(const HtmlTag& tag, const char *s);

HtmlTag operator/(const HtmlTag& t1, const HtmlTag& t2);
HtmlTag& operator/=(HtmlTag& tag, const HtmlTag& s);

inline Htmls operator/(const HtmlTag& tag, String s) { return tag.ApplyTo(s); }
inline Htmls operator/(const HtmlTag& tag, const char *s) { return tag.ApplyTo(s); }




HtmlTag operator % (const HtmlTag& t1, const HtmlTag& t2);
Htmls operator % (const HtmlTag& tag, const char *s);
inline Htmls operator % (const HtmlTag& tag, String s) { return tag % ~s; }



inline HtmlTag HtmlBold() { return HtmlTag("B"); }
inline HtmlTag HtmlItalic() { return HtmlTag("I"); }
inline HtmlTag HtmlBig() { return HtmlTag("BIG"); }



HtmlTag HtmlFontColor(Color c);
HtmlTag HtmlFontSize(int s);



inline Htmls ToHtml(String s) { return ToHtml(~s); }
HtmlTag HtmlLink(const char *link, const char *target);
HtmlTag HtmlImg(String src, String alt = "");

Htmls HtmlTextArea(String id, Size size, const char *defaultValue = 0);

HtmlTag HtmlButton(String id, const char *text);
HtmlTag HtmlWarn(Color color = LtRed);
HtmlTag HtmlPackedTable();
HtmlTag HtmlForm(String action, bool multipart = false, String method = "POST");

Htmls HtmlCheck(String name, bool on);
Htmls HtmlUpload(String name);

HtmlTag HtmlTCell();
HtmlTag HtmlRowCell();
HtmlTag HtmlRowTCell();

Htmls HtmlMenu(bool active, const char *text, const char *url, int wd = 0);
HtmlTag HtmlDialog(int width = -100);
Htmls HtmlHead(String title, const char *charset = "windows-1250");
Htmls HtmlPage(String title, const Htmls& body, Color bgcolor = White, const char *charset = "windows-1250");
Htmls HtmlTitlePage(String title, const Htmls& body, Color bgcolor = White, const char *charset = "windows-1250");

HtmlTag HtmlLine();
HtmlTag HtmlPara();
HtmlTag HtmlCourier(int size);
HtmlTag HtmlArial(int size);
HtmlTag HtmlRoman(int size);
HtmlTag HtmlCourier();
HtmlTag HtmlArial();
HtmlTag HtmlRoman();
HtmlTag HtmlFntSize(int size);
# 37 "C:/upp/uppsrc/Web/Web.h" 2

# 1 "C:/upp/uppsrc/Web/socket.h" 1


static const int DEFAULT_CONNECT_TIMEOUT = 5000;

static const int SOCKKIND_STD = 1;

class Socket : Moveable<Socket>
{
public:
 class Data
 {
 public:
  Data();
  virtual ~Data() { CloseRaw(0); }

  bool Open(bool is_blocking);
  bool OpenServer(int port, bool nodelay, int listen_count, bool is_blocking);
  bool OpenClient(const char *host, int port, bool nodelay, dword *my_addr, int timeout, bool is_blocking);
  bool IsOpen() const { return socket != (SOCKET)(~0); }
  bool CloseRaw(int timeout_msec);

  bool IsEof() const { return is_eof && leftover.IsEmpty(); }
  bool IsError() const { return is_error; }
  void SetError() { is_error = true; }
  void ClearError() { is_error = false; }
  void SetSockError(String context);

  void NoDelay();
  void Linger(int msecs);
  void Block(bool b = true);


  void StopWrite();

  virtual int GetKind() const { return SOCKKIND_STD; }

  virtual bool Peek(int timeout_msec, bool write);
  virtual int Read(void *buf, int amount);
  virtual int Write(const void *buf, int amount);
  virtual bool Accept(Socket& socket, dword *ipaddr, bool nodelay, int timeout_msec);
  virtual bool Close(int timeout_msec);
  virtual Value GetInfo(String info) const;

 public:
  SOCKET socket;
  String leftover;
  bool is_blocking;
  bool is_error;
  bool is_eof;

  int fake_error;


 protected:
  SOCKET AcceptRaw(dword *ipaddr, int timeout_msec);
  void Attach(SOCKET socket, bool nodelay, bool is_blocking);
  void SetSockResError(String context);
 };

 Socket() {}
 Socket(One<Data> data) : data(data) {}

 static void Init();

 void Attach(One<Data> d) { data = d; }
 void Clear() { data.Clear(); }

 bool IsOpen() const { return !!data; }

 bool IsEof() const { return !data || data->IsEof(); }
 bool IsError() const { return data->IsError(); }
 void ClearError() { data->ClearError(); }

 SOCKET GetSocket() const { return IsOpen() ? data->socket : (SOCKET)(~0); }
 int GetNumber() const { return (int)GetSocket(); }

 int GetKind() const { return data->GetKind(); }
 Value GetInfo(String info) const { return data->GetInfo(info); }

 bool Accept(Socket& socket, dword *ipaddr = 0, bool nodelay = true, int timeout_msec = DEFAULT_CONNECT_TIMEOUT) { return data->Accept(socket, ipaddr, nodelay, timeout_msec); }
 bool Close(int msecs_timeout = 0);

 void NoDelay() { data->NoDelay(); }
 void Linger(int msecs) { data->Linger(msecs); }
 void NoLinger() { data->Linger(Null); }
 void Block(bool b = true) { data->Block(b); }
 void NoBlock() { data->Block(false); }

 static bool Wait(const Vector<SOCKET>& read, const Vector<SOCKET>& write, int timeout_msec);
 static bool Wait(const Vector<Socket *>& read, const Vector<Socket *>& write, int timeout_msec);

 bool Peek(int timeout_msec = 0) { return data->Peek(timeout_msec, false); }
 bool PeekWrite(int timeout_msec = 0) { return data->Peek(timeout_msec, true); }
 bool PeekAbort(int timeout_msec = 0);
 String PeekCount(int count, int timeout_msec = Null);
 String PeekUntil(char term, int timeout_msec = Null, int maxlen = 1000000);

 int ReadRaw(void *buffer, int maxlen) { return data->Read(buffer, maxlen); }
 String Read(int timeout_msec = Null, int maxlen = 1000000);
 int ReadCount(void *buffer, int count, int timeout_msec = Null);
 String ReadCount(int count, int timeout_msec = Null);
 String ReadUntil(char term, int timeout_msec = Null, int maxlen = 1000000);
 void UnRead(const void *buffer, int len);
 void UnRead(String data) { UnRead(data.Begin(), data.GetLength()); }

 int WriteRaw(const void *buffer, int maxlen) { return data->Write(buffer, maxlen); }
 int WriteWait(const char *s, int length, int timeout_msec);
 void Write(const char *s, int length) { WriteWait(s, length, Null); }
 void Write(String s) { Write(s.Begin(), s.GetLength()); }

 void StopWrite() { data->StopWrite(); }

 static String GetHostName();

 static String GetErrorText();
 static void SetErrorText(String text);
 static void ClearErrorText() { SetErrorText(Null); }
 static void SetSockError(const char *context) { SetSockError((SOCKET)(~0), context); }
 static void SetSockError(SOCKET socket, const char *context);
 static void SetSockError(SOCKET socket, const char *context, const char *errordesc);


 static int GetErrorCode() { return WSAGetLastError(); }
# 132 "C:/upp/uppsrc/Web/socket.h"
private:
 One<Data> data;
};


class SocketEvent : public Event {
public:
 SocketEvent() {}

 void Read(Socket& socket);
 void Write(Socket& socket);
 void Accept(Socket& socket);
 void Select(Socket& socket, int fd_flags);
};


bool ServerSocket(Socket& socket, int port, bool nodelay = true, int listen_count = 5, bool is_blocking = true);
bool ClientSocket(Socket& socket, const char *host, int port, bool nodelay = true, dword *my_addr = __null, int timeout = DEFAULT_CONNECT_TIMEOUT, bool is_blocking = true);
# 39 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/httpsrv.h" 1
String MIMECharsetName(byte charset);

inline String HttpContentType(String type) { return "Content-Type: " + type + "\r\n"; }

inline String HttpTextHtml(String encoding) { return "text/html; charset=" + encoding; }
inline String HttpTextHtml(byte charset = 0) { return HttpTextHtml(MIMECharsetName(charset)); }

inline String HttpTextPlain(String encoding) { return "text/plain; charset=" + encoding; }

inline String HttpTextPlain(byte charset = 0) { return HttpTextPlain(MIMECharsetName(charset)); }
inline String HttpTextXml() { return "text/xml"; }
inline String HttpImage(String format) { return "image/" + format; }
inline String HttpImageGif() { return "image/gif"; }
inline String HttpImageJpg() { return "image/jpeg"; }
inline String HttpImagePng() { return "image/png"; }
inline String HttpBinary() { return "application/octet-stream"; }

class HttpServer;

class HttpRequest
{
 friend class HttpServer;

public:
 HttpRequest(HttpServer& server, const Socket& socket, HttpQuery query);

 HttpServer& GetServer() { return server; }
 Socket& GetSocket() { return socket; }

 Event& GetEvent() { return event; }

 HttpQuery GetQuery() const { return query; }

 bool IsLogging() const;
 void LogTime(const char *s, int level);
 int GetDuration() const;

 void Write(String header, String body, int result_code, String result_text);
 void Write(String header, String body);
 void Write(String body) { Write(Null, body); }
 void Redirect(String url);
 void Error(String err);

private:
 HttpServer& server;
 Socket socket;

 SocketEvent event;

 HttpQuery query;
 dword request_ticks;
};

class HttpServer
{
public:
 HttpServer();

 bool Open(int port, int listen_count = 5);
 bool Reopen();
 void Close();

 bool IsOpen() const { return socket.IsOpen(); }
 bool IsError() const { return socket.IsError(); }
 int GetPort() const { return server_port; }
 Socket& GetSocket() { return socket; }
 Socket& GetConnSocket() { return connection; }

 Event& GetEvent() { return sock_event; }
 Event& GetConnEvent() { return conn_event; }


 void Logging(const char *log = __null, int max_log_size = 500000);
 void NoLogging() { logfile = Null; }
 bool IsLogging() const { return !logfile.IsEmpty(); }
 void Log(const char *s, int level);
 void LogTime(const char *s, int level);
 HttpServer& operator << (const char *s) { Log(s, 0); return *this; }

 static HttpServer *Wait(const Vector<HttpServer *>& list, int msec);
 bool Wait(int msec);
 One<HttpRequest> GetRequest();

 Time GetStartTime() const { return start_time; }
 double GetHitCount() const { return hit_count; }
 double GetResponseTime() const { return total_response_msec; }
 double GetAvgTime() const;
 double GetAvgLagTime() const;
 double GetElapsedTime() const;

 String GetDefaultHeader() const { return default_header; }
 void DefaultHeader(String h) { default_header = h; }

 int GetMaxPostSize() const { return max_post_size; }
 void MaxPostSize(int size) { max_post_size = size; }

 int GetMaxRequestTime() const { return max_request_time; }
 void MaxRequestTime(int time) { max_request_time = time; }

 bool IsShowQuery() const { return show_headers; }
 void ShowQuery(bool sh = true) { show_headers = sh; }

 void AddRequest(int duration_msec);
 void ReadPostData(Socket& socket, HttpQuery& query);

 void AddWrite(Socket socket, String data);
 bool DelayedWrite();
 bool IsDelayedWrite() const;

public:
 Callback2<String, int> WhenLog;

private:
 bool Accept();

private:
 Socket socket;
 Socket connection;

 SocketEvent sock_event;
 SocketEvent conn_event;

 class SocketWrite
 {
 public:
  SocketWrite(Socket socket, String data, int ticks = 0)
  : socket(socket), data(data), done(0), ticks(ticks) {}

 public:
  Socket socket;
  String data;
  int done;
  int ticks;
 };
 Array<SocketWrite> delayed_writes;

 int server_port;
 dword ipaddr;
 String default_header;
 String logfile;
 int max_log_size;
 enum { DEFAULT_MAX_POST_SIZE = 1000000 };
 int max_post_size;
 enum { DEFAULT_MAX_REQUEST_TIME = 60000 };
 int max_request_time;
 bool show_headers;

 int request_time;
 int request_state;
 enum { RS_FIRST, RS_SAPI, RS_GET_HEADERS, RS_POST_HEADERS, RS_POST_DATA };
 String first_line;
 String sapi_request;
 int sapi_length;
 int request_version;
 String header_line;
 int headers_length;
 int post_length;
 String post_data;
 HttpQuery request_query;

 Time start_time;
 double hit_count;
 double total_response_msec;

 enum { TRAILER = 10 };
 dword trailing_times[TRAILER];
 dword trailing_sum;
 int trailing_count;
};

inline bool HttpRequest::IsLogging() const { return server.IsLogging(); }

inline String GetHttpPath(HttpQuery query) { return query.GetString("$$PATH"); }
inline String GetHttpQuery(HttpQuery query) { return query.GetString("$$QUERY"); }
String GetHttpURI(HttpQuery query);
void GetHttpPostData(HttpQuery& query, String data);
String GetHttpQueryDump(HttpQuery query);
String GetHttpErrorPage(HttpQuery query, String err, bool show_query);
# 40 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/httpcli.h" 1



class HttpClient
{
public:
 HttpClient();

 HttpClient& TimeoutMsecs(int t) { timeout_msecs = t; return *this; }
 HttpClient& MaxHeaderSize(int m) { max_header_size = m; return *this; }
 HttpClient& MaxContentSize(int m) { max_content_size = m; return *this; }

 HttpClient& Host(String h) { host = h; return *this; }
 HttpClient& Port(int p) { port = p; return *this; }
 HttpClient& Path(String p) { path = p; return *this; }
 HttpClient& User(String u, String p) { username = u; password = p; return *this; }
 HttpClient& URL(const char *url);
 HttpClient& KeepAlive(bool k) { keepalive = k; return *this; }
 HttpClient& Proxy(String h, int p) { proxy_host = h; proxy_port = p; return *this; }
 HttpClient& Proxy(const char *url);

 HttpClient& Headers(String h) { client_headers = h; return *this; }
 HttpClient& ClearHeaders() { return Headers(Null); }
 HttpClient& AddHeaders(String h) { client_headers.Cat(h); return *this; }

 HttpClient& StdHeaders(bool sh) { std_headers = sh; return *this; }
 HttpClient& NoStdHeaders() { return StdHeaders(false); }
 HttpClient& Accept(String a) { accept = a; return *this; }
 HttpClient& Agent(String a) { agent = a; return *this; }

 HttpClient& Method(int m) { method = m; return *this; }
 HttpClient& Get() { return Method(METHOD_GET); }
 HttpClient& Post() { return Method(METHOD_POST); }

 HttpClient& PostData(String pd) { postdata = pd; return *this; }

 String Execute(Gate2<int, int> progress = false);
 String ExecuteRedirect(int max_redirect = DEFAULT_MAX_REDIRECT,
  int retries = DEFAULT_RETRIES, Gate2<int, int> progress = false);

 bool IsError() const { return !IsNull(error); }
 String GetError() const { return error; }
 bool IsAborted() const { return aborted; }

 int GetStatusCode() const { return status_code; }
 String GetStatusLine() const { return status_line; }
 String GetHeaders() const { return server_headers; }

 bool IsRedirect() const { return is_redirect; }
 String GetRedirectURL() const { return redirect_url; }

 void Close() { socket.Close(); }

public:
 Socket socket;
 bool keepalive;
 bool aborted;
 String error;

 int timeout_msecs;
 int max_header_size;
 int max_content_size;

 String host;
 int port;
 bool is_post;
 bool std_headers;
 int method;
 String proxy_host;
 int proxy_port;
 String path;
 String username;
 String password;
 String client_headers;
 String accept;
 String agent;
 String postdata;

 int status_code;
 String status_line;
 String server_headers;

 bool is_redirect;
 String redirect_url;

 enum {
  DEFAULT_PORT = 80,
  DEFAULT_TIMEOUT_MSECS = 120000,
  DEFAULT_MAX_HEADER_SIZE = 1000000,
  DEFAULT_MAX_CONTENT_SIZE = 10000000,
  DEFAULT_MAX_REDIRECT = 5,
  DEFAULT_RETRIES = 3,
 };

 enum {
  METHOD_GET,
  METHOD_POST,
 };

private:
 String ReadUntilProgress(char until, int start_time, int end_time, Gate2<int, int> progress);
};

String HttpClientGet(String url, String *server_headers = __null, String *error = __null,
 Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
 int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String username, String password,
 String *server_headers = __null, String *error = __null,
 Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
 int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String proxy,
 String *server_headers = __null, String *error = __null,
 Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
 int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String proxy, String username, String password,
 String *server_headers = __null, String *error = __null,
 Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
 int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);
# 41 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/auth.h" 1
class WebUser
{
public:
 WebUser(String name = Null, String pass = Null, String args = Null)
  : name(name), pass(pass), args(args) {}

 void Serialize(Stream& stream);


 static String CheckToken(String token);
 static String CreateToken(String args);
 static void DeleteToken(String token);


 static void SetMap(const Array<WebUser>& map);
 static Array<WebUser> GetMap();
 static void SerializeMap(String& s, bool write);
 static void ClearMap();

 void SetUser() const;
 String GetArgs() const;

 static String Login(const HttpQuery& map, String& args,
  const char *isapi_name = __null, bool *save_cfg = 0);

public:
 String name;
 String pass;
 String args;
};
# 42 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/smtp.h" 1
class SmtpMail
{
public:
 enum AS { TO, CC, BCC };

 SmtpMail();

 SmtpMail& Host(String h) { host = h; return *this; }
 SmtpMail& Port(int p) { port = p; return *this; }
 SmtpMail& From(String f) { from = f; return *this; }
 SmtpMail& To(String t, AS a = TO) { to.Add(t); as.Add(a); return *this; }
 SmtpMail& Text(String t, const char *m = 0) { text = t; mime = m; return *this; }
 SmtpMail& NoHeader() { no_header = true; return *this; }
 SmtpMail& NoHeaderSep() { no_header_sep = true; return *this; }
 SmtpMail& ReplyTo(String r) { reply_to = r; return *this; }
 SmtpMail& TimeSent(Time t) { time_sent = t; return *this; }
 SmtpMail& Subject(String s) { subject = s; return *this; }
 SmtpMail& Transcript(bool t = true) { transcript = t; return *this; }
 SmtpMail& AttachFile(const char *filename, const char *mime = 0);
 SmtpMail& Attach(const char *name, String data, const char *mime = 0);

 bool Send();

 String GetError() const { return error; }
 String GetTranscript() const { return transcript_text; }

private:
 struct Attachment
 {
  String name;
  String file;
  String mime;
  String data;
 };

 String host;
 int port;
 String from;
 Vector<String> to;
 Vector<char> as;
 String text;
 String mime;
 bool transcript;
 Array<Attachment> attachments;


 bool no_header;
 bool no_header_sep;
 Time time_sent;
 String reply_to;
 String subject;


 String error;
 String transcript_text;
};
# 43 "C:/upp/uppsrc/Web/Web.h" 2
# 1 "C:/upp/uppsrc/Web/sproc.h" 1
class SlaveProcess
{
public:
 SlaveProcess() {}
 virtual ~SlaveProcess() {}

 virtual void Kill() = 0;
 virtual bool IsRunning() = 0;
 virtual void Write(String s) = 0;
 virtual bool Read(String& s) = 0;
 virtual int GetExitCode() = 0;
 virtual void Detach() {};

private:
 SlaveProcess(const SlaveProcess& sp);
 void operator = (const SlaveProcess& sp);
};

One<SlaveProcess> StartLocalProcess(const char *cmdline, const char *envptr = __null);
One<SlaveProcess> StartRemoteProcess(const char *host, int port, const char *cmdline, const char *envptr = __null, int timeout = Null);
One<SlaveProcess> StartProcess(const char *cmdline, const char *envptr = __null, int timeout = Null);
# 44 "C:/upp/uppsrc/Web/Web.h" 2

};
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 3
       
# 65 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 3

# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 1 3
# 36 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 2 3




# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 1 3
# 66 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
namespace std
{






  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 110 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 186 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 295 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other

      _Node_Alloc_type;

      struct _List_impl
 : public _Node_Alloc_type {
 _List_node_base _M_node;
 _List_impl (const _Node_Alloc_type& __a)
   : _Node_Alloc_type(__a)
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_Alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_Alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(*static_cast<const _Node_Alloc_type*>(&this->_M_impl)); }

      _List_base(const allocator_type& __a)
 : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 388 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

     

      typedef _List_base<_Tp, _Alloc> _Base;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;







      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
# 432 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     std::_Construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }







      _Node*
      _M_create_node()
      {
 _Node* __p = this->_M_get_node();
 try
   {
     std::_Construct(&__p->_M_data);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 487 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __n, __value); }
# 499 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      explicit
      list(size_type __n)
      : _Base(allocator_type())
      { this->insert(begin(), __n, value_type()); }
# 511 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x.get_allocator())
      { this->insert(begin(), __x.begin(), __x.end()); }
# 529 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        { this->insert(begin(), __first, __last); }
# 550 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 563 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 579 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_node._M_next; }






      const_iterator
      begin() const
      { return this->_M_impl._M_node._M_next; }






      iterator
      end() { return &this->_M_impl._M_node; }






      const_iterator
      end() const
      { return &this->_M_impl._M_node; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return size_type(-1); }
# 693 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 705 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      resize(size_type __new_size)
      { this->resize(__new_size, value_type()); }






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(--end()); }





      const_reference
      back() const
      { return *(--end()); }
# 753 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 769 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 783 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 798 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(this->_M_impl._M_node._M_prev); }
# 813 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 829 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 847 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 872 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 894 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 911 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      swap(list& __x)
      { _List_node_base::swap(this->_M_impl._M_node,__x._M_impl._M_node); }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 938 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   this->_M_transfer(__position, __x.begin(), __x.end());
      }
# 954 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;
 this->_M_transfer(__position, __i, __j);
      }
# 976 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __first, iterator __last)
      {
 if (__first != __last)
   this->_M_transfer(__position, __first, __last);
      }
# 994 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1008 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _Predicate>
      void
      remove_if(_Predicate);
# 1022 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      unique();
# 1037 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1050 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1065 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   for ( ; __first != __last; ++__first)
     _M_insert(__pos, *__first);
 }



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
      {
 for ( ; __n > 0; --__n)
   _M_insert(__pos, __x);
      }



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node,__last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        std::_Destroy(&__n->_M_data);
        _M_put_node(__n);
      }
    };
# 1188 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    {
      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1217 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 2 3


# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/list.tcc" 1 3
# 64 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/bits/list.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp,_Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
      {
        _Node* __tmp = __cur;
        __cur = static_cast<_Node*>(__cur->_M_next);
        std::_Destroy(&__tmp->_M_data);
        _M_put_node(__tmp);
      }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return __tmp;
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    erase(iterator __position)
    {
      iterator __ret = __position._M_node->_M_next;
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp,_Alloc>&
    list<_Tp,_Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     *__first1++ = *__first2++;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for ( ; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp,_Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
      {
        iterator __next = __first;
        ++__next;
        if (*__first == __value)
          _M_erase(__first);
        __first = __next;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
      {
        if (*__first == *__next)
          _M_erase(__next);
        else
          __first = __next;
        __next = __first;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  (__counter != __fill) && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge( *(__counter-1) );
        swap( *(__fill-1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp,_Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
        {
          iterator __next = __first;
          ++__next;
          if (__pred(*__first))
     _M_erase(__first);
          __first = __next;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp,_Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last) return;
        iterator __next = __first;
        while (++__next != __last)
        {
          if (__binary_pred(*__first, *__next))
            _M_erase(__next);
          else
            __first = __next;
          __next = __first;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp,_Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp,_Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      (__counter != __fill) && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge( *(__counter-1), __comp );
     swap( *(__fill-1) );
   }
      }
}
# 75 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/c++/3.4.5/list" 2 3
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h" 1
# 35 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
# 1 "C:/Enrique/Programas/MyApps/DRTECore/zconf.h" 1
# 262 "C:/Enrique/Programas/MyApps/DRTECore/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;
# 36 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h" 2


extern "C" {
# 78 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;
    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 213 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern const char * zlibVersion (void);
# 243 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflate (z_streamp strm, int flush);
# 329 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateEnd (z_streamp strm);
# 364 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflate (z_streamp strm, int flush);
# 463 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateEnd (z_streamp strm);
# 539 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 578 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateCopy (z_streamp dest, z_streamp source);
# 596 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateReset (z_streamp strm);
# 607 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateParams (z_streamp strm, int level, int strategy);
# 628 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateTune (z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain);
# 645 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong deflateBound (z_streamp strm, uLong sourceLen);
# 654 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflatePrime (z_streamp strm, int bits, int value);
# 670 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateSetHeader (z_streamp strm, gz_headerp head);
# 737 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 759 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateSync (z_streamp strm);
# 774 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateCopy (z_streamp dest, z_streamp source);
# 790 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateReset (z_streamp strm);
# 800 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflatePrime (z_streamp strm, int bits, int value);
# 816 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateGetHeader (z_streamp strm, gz_headerp head);
# 878 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
typedef unsigned (*in_func) (void *, unsigned char * *);
typedef int (*out_func) (void *, unsigned char *, unsigned);

extern int inflateBack (z_streamp strm, in_func in, void *in_desc, out_func out, void *out_desc);
# 950 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int inflateBackEnd (z_streamp strm);







extern uLong zlibCompileFlags (void);
# 1010 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1025 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int compress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level);
# 1041 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong compressBound (uLong sourceLen);






extern int uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1067 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
typedef voidp gzFile;

extern gzFile gzopen (const char *path, const char *mode);
# 1086 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern gzFile gzdopen (int fd, const char *mode);
# 1099 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzsetparams (gzFile file, int level, int strategy);







extern int gzread (gzFile file, voidp buf, unsigned len);







extern int gzwrite (gzFile file, voidpc buf, unsigned len);







extern int gzprintf (gzFile file, const char *format, ...);
# 1136 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzputs (gzFile file, const char *s);






extern char * gzgets (gzFile file, char *buf, int len);
# 1152 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzputc (gzFile file, int c);





extern int gzgetc (gzFile file);





extern int gzungetc (int c, gzFile file);
# 1174 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzflush (gzFile file, int flush);
# 1184 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern long gzseek (gzFile file, long offset, int whence);
# 1202 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzrewind (gzFile file);






extern long gztell (gzFile file);
# 1218 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int gzeof (gzFile file);





extern int gzdirect (gzFile file);





extern int gzclose (gzFile file);






extern const char * gzerror (gzFile file, int *errnum);
# 1246 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern void gzclearerr (gzFile file);
# 1261 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong adler32 (uLong adler, const Bytef *buf, uInt len);
# 1277 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong adler32_combine (uLong adler1, uLong adler2, long len2);
# 1286 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong crc32 (uLong crc, const Bytef *buf, uInt len);
# 1302 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern uLong crc32_combine (uLong crc1, uLong crc2, long len2);
# 1318 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
extern int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size);

extern int inflateInit_ (z_streamp strm, const char *version, int stream_size);

extern int deflateInit2_ (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size);



extern int inflateInit2_ (z_streamp strm, int windowBits, const char *version, int stream_size);

extern int inflateBackInit_ (z_streamp strm, int windowBits, unsigned char *window, const char *version, int stream_size);
# 1347 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h"
    struct internal_state {int dummy;};


extern const char * zError (int);
extern int inflateSyncPoint (z_streamp z);
extern const uLongf * get_crc_table (void);


}
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2







namespace DRTE
{
class Package : Stream
{
public:
 enum
 {
  NONE,
  SHUTDOWN,
  UPDATE,
  REGISTER_NODE,
  WORK_RESPONSE,
  WORK_REQUEST,
  WORK_NEXT_FRAME,
  SCENE_DATA,
  SCENE_MOD,
  RENDER_START,
  RENDER_STOP,
  ID
 };

 int type;
 int size_data;
 int inflated_data_size;
 int compression_level;
 int node_id;
 int source_ip;
 int dest_ip;
 char* data;
 void* conn;
 Package();
 ~Package();
 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 int DeflateData(int level);
 int InflateData();

};
}
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2
# 17 "C:/Enrique/Programas/MyApps/DRTECore/Network.h"
namespace DRTE
{
class Network
{
private:
 SOCKET _skt;


 Upp::Socket _socket;


 in_addr *_ip;
 char host[16];

 void BuffSize();

public:
 bool connected;
 Network();

 Network(Upp::Socket& socket);

 Network(SOCKET skt);
 char* GetLocalAddress();
 long GetLocalAddressLong();
 char* GetAddress();
 long GetAddressLong();
 int SetAddress(char* ip);
 int SetAddressLong(long ip);
 int Init();
 int ListenMode();
 int Connect();
 Network* AcceptConn();
 int DataWaiting();
 int Send(char* data, int length);
 int SendPackage(Package *pkg);
 int Receive(char* buffer, int length);
 Package* ReceivePackage();
 int QueueLength();
 ~Network();
};
}
# 20 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Node.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Node.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 1
# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 2 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2






# 1 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Network.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Node.h" 2



namespace DRTE
{
class Node
{
public:
 int id;
 int version;
 int status;
 int type;
 int ip;
 Network *conn;

 enum
 {
  CLIENT_NODE,
  RENDER_NODE
 };

 Node();
 ~Node();

 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);

};
}
# 21 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 22 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Package.h" 2
# 23 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 24 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Sphere.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Sphere.h" 2
# 25 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 26 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Triangle.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 1

# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Ray.h" 2
# 7 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/globals.h" 1
# 8 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 9 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 10 "C:/Enrique/Programas/MyApps/DRTECore/Object.h" 2
# 3 "C:/Enrique/Programas/MyApps/DRTECore/Triangle.h" 2
# 27 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Update.h" 1





namespace DRTE
{
class Update
{
public:
 enum
 {
  CLIENT,
  MANAGER,
  RENDER
 };
 int version;
 int type;
 int size;
 char* name;
 char* data;
};
}
# 28 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Color.h" 2
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Vector.h" 2
# 29 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Work.h" 1


# 1 "C:/Enrique/Programas/MyApps/DRTECore/multi_platform.h" 1
# 4 "C:/Enrique/Programas/MyApps/DRTECore/Work.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Image.h" 1
# 5 "C:/Enrique/Programas/MyApps/DRTECore/Work.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/Stream.h" 1
# 6 "C:/Enrique/Programas/MyApps/DRTECore/Work.h" 2






namespace DRTE
{
class Work : Stream
{
public:
 int node_id;
 int sector_x;
 int sector_y;
 int sector_width;
 int sector_height;
 int resolution_width;
 int resolution_height;
 int camera_id;
 int type;
 int frame_id;
 int options;
 int threads;
 int image_size;
 char *image;
 int frame_parts;
 int done_parts;

 enum
 {
  REQUEST=1,
  RESPONSE=2,
  PPM=1
 };





 char* Serialize(int* size_out);
 int Deserialize(char* data_in,int length);
 Work();
 ~Work();
};
}
# 30 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 1 "C:/Enrique/Programas/MyApps/DRTECore/zlib.h" 1
# 31 "C:/Enrique/Programas/MyApps/DRTECore/DRTECore.h" 2
# 4 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.h" 2


# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 1
# 28 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h" 1
# 26 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 1
# 28 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config.h" 1
# 26 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_platform.h" 1
# 27 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config.h" 2
# 38 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config_win32.h" 1
# 39 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_config.h" 2
# 29 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 2
# 39 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
# 1 "C:/upp/mingw/include/stddef.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 1 3





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/include/stddef.h" 1 3 4
# 7 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stddef.h" 2 3
# 7 "C:/upp/mingw/include/stddef.h" 2
# 40 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 2
# 1 "C:/upp/mingw/include/stdarg.h" 1





# 1 "C:/upp/mingw/bin/../lib/gcc/mingw32/3.4.5/../../../../include/stdarg.h" 1 3
# 7 "C:/upp/mingw/include/stdarg.h" 2
# 41 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 2
# 80 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
typedef enum SDL_bool {
 SDL_FALSE = 0,
 SDL_TRUE = 1
} SDL_bool;

typedef int8_t Sint8;
typedef uint8_t Uint8;
typedef int16_t Sint16;
typedef uint16_t Uint16;
typedef int32_t Sint32;
typedef uint32_t Uint32;


typedef int64_t Sint64;

typedef uint64_t Uint64;
# 109 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
typedef int SDL_dummy_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_dummy_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_dummy_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_dummy_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_dummy_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_dummy_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_dummy_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_dummy_sint64[(sizeof(Sint64) == 8) * 2 - 1];
# 128 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
typedef enum {
 DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;


typedef int SDL_dummy_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];



# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 138 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 2


extern "C" {
# 198 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
extern __attribute__((dllexport)) char * SDL_getenv(const char *name);





extern __attribute__((dllexport)) int SDL_putenv(const char *variable);
# 381 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
extern __attribute__((dllexport)) size_t SDL_strlcpy(char *dst, const char *src, size_t maxlen);





extern __attribute__((dllexport)) size_t SDL_strlcat(char *dst, const char *src, size_t maxlen);





extern __attribute__((dllexport)) char * SDL_strdup(const char *string);
# 477 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
extern __attribute__((dllexport)) char* SDL_lltoa(Sint64 value, char *string, int radix);





extern __attribute__((dllexport)) char* SDL_ulltoa(Uint64 value, char *string, int radix);
# 495 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
extern __attribute__((dllexport)) Uint64 SDL_strtoull(const char *string, char **endp, int base);
# 555 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
extern __attribute__((dllexport)) int SDL_snprintf(char *text, size_t maxlen, const char *fmt, ...);





extern __attribute__((dllexport)) int SDL_vsnprintf(char *text, size_t maxlen, const char *fmt, va_list ap);
# 575 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h"
typedef struct _SDL_iconv_t *SDL_iconv_t;
extern __attribute__((dllexport)) SDL_iconv_t SDL_iconv_open(const char *tocode, const char *fromcode);
extern __attribute__((dllexport)) int SDL_iconv_close(SDL_iconv_t cd);

extern __attribute__((dllexport)) size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);



extern __attribute__((dllexport)) char * SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft);






}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 593 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_stdinc.h" 2
# 27 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h" 2
# 53 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h"
extern "C" int SDL_main(int argc, char *argv[]);





# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 60 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h" 2

extern "C" {



extern __attribute__((dllexport)) void SDL_SetModuleHandle(void *hInst);

extern __attribute__((dllexport)) int SDL_RegisterApp(char *name, Uint32 style, void *hInst);

extern __attribute__((dllexport)) void SDL_UnregisterApp(void);

}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 74 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_main.h" 2
# 29 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 1
# 29 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_error.h" 1
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_error.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_error.h" 2


extern "C" {



extern __attribute__((dllexport)) void SDL_SetError(const char *fmt, ...);
extern __attribute__((dllexport)) char * SDL_GetError(void);
extern __attribute__((dllexport)) void SDL_ClearError(void);




typedef enum {
 SDL_ENOMEM,
 SDL_EFREAD,
 SDL_EFWRITE,
 SDL_EFSEEK,
 SDL_UNSUPPORTED,
 SDL_LASTERROR
} SDL_errorcode;
extern __attribute__((dllexport)) void SDL_Error(SDL_errorcode code);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 60 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_error.h" 2
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h" 1
# 47 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 48 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h" 2


extern "C" {
# 60 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h"
static __inline__ Uint16 SDL_Swap16(Uint16 x)
{
 __asm__("xchgb %b0,%h0" : "=q" (x) : "0" (x));
 return x;
}
# 93 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h"
static __inline__ Uint32 SDL_Swap32(Uint32 x)
{
 __asm__("bswap %0" : "=r" (x) : "0" (x));
 return x;
}
# 129 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h"
static __inline__ Uint64 SDL_Swap64(Uint64 x)
{
 union {
  struct { Uint32 a,b; } s;
  Uint64 u;
 } v;
 v.u = x;
 __asm__("bswapl %0 ; bswapl %1 ; xchgl %0,%1"
         : "=r" (v.s.a), "=r" (v.s.b)
         : "0" (v.s.a), "1" (v.s.b));
 return v.u;
}
# 190 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h"
}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 193 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_endian.h" 2
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mutex.h" 1
# 34 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mutex.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 35 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mutex.h" 2


extern "C" {
# 54 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mutex.h"
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;


extern __attribute__((dllexport)) SDL_mutex * SDL_CreateMutex(void);



extern __attribute__((dllexport)) int SDL_mutexP(SDL_mutex *mutex);






extern __attribute__((dllexport)) int SDL_mutexV(SDL_mutex *mutex);


extern __attribute__((dllexport)) void SDL_DestroyMutex(SDL_mutex *mutex);







struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;


extern __attribute__((dllexport)) SDL_sem * SDL_CreateSemaphore(Uint32 initial_value);


extern __attribute__((dllexport)) void SDL_DestroySemaphore(SDL_sem *sem);





extern __attribute__((dllexport)) int SDL_SemWait(SDL_sem *sem);




extern __attribute__((dllexport)) int SDL_SemTryWait(SDL_sem *sem);







extern __attribute__((dllexport)) int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms);




extern __attribute__((dllexport)) int SDL_SemPost(SDL_sem *sem);


extern __attribute__((dllexport)) Uint32 SDL_SemValue(SDL_sem *sem);







struct SDL_cond;
typedef struct SDL_cond SDL_cond;


extern __attribute__((dllexport)) SDL_cond * SDL_CreateCond(void);


extern __attribute__((dllexport)) void SDL_DestroyCond(SDL_cond *cond);




extern __attribute__((dllexport)) int SDL_CondSignal(SDL_cond *cond);




extern __attribute__((dllexport)) int SDL_CondBroadcast(SDL_cond *cond);






extern __attribute__((dllexport)) int SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);







extern __attribute__((dllexport)) int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 161 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mutex.h" 2
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_thread.h" 1
# 37 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_thread.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 38 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_thread.h" 2


extern "C" {



struct SDL_Thread;
typedef struct SDL_Thread SDL_Thread;
# 92 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_thread.h"
extern __attribute__((dllexport)) SDL_Thread * SDL_CreateThread(int ( *fn)(void *), void *data);



extern __attribute__((dllexport)) Uint32 SDL_ThreadID(void);




extern __attribute__((dllexport)) Uint32 SDL_GetThreadID(SDL_Thread *thread);





extern __attribute__((dllexport)) void SDL_WaitThread(SDL_Thread *thread, int *status);


extern __attribute__((dllexport)) void SDL_KillThread(SDL_Thread *thread);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 118 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_thread.h" 2
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_rwops.h" 1
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_rwops.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 34 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_rwops.h" 2


extern "C" {




typedef struct SDL_RWops {




 int ( *seek)(struct SDL_RWops *context, int offset, int whence);





 int ( *read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);





 int ( *write)(struct SDL_RWops *context, const void *ptr, int size, int num);


 int ( *close)(struct SDL_RWops *context);

 Uint32 type;
 union {

     struct {
  int append;
  void *h;
  struct {
      void *data;
      int size;
      int left;
  } buffer;
     } win32io;


     struct {
  int autoclose;
   FILE *fp;
     } stdio;

     struct {
  Uint8 *base;
   Uint8 *here;
  Uint8 *stop;
     } mem;
     struct {
  void *data1;
     } unknown;
 } hidden;

} SDL_RWops;




extern __attribute__((dllexport)) SDL_RWops * SDL_RWFromFile(const char *file, const char *mode);


extern __attribute__((dllexport)) SDL_RWops * SDL_RWFromFP(FILE *fp, int autoclose);


extern __attribute__((dllexport)) SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern __attribute__((dllexport)) SDL_RWops * SDL_RWFromConstMem(const void *mem, int size);

extern __attribute__((dllexport)) SDL_RWops * SDL_AllocRW(void);
extern __attribute__((dllexport)) void SDL_FreeRW(SDL_RWops *area);
# 122 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_rwops.h"
extern __attribute__((dllexport)) Uint16 SDL_ReadLE16(SDL_RWops *src);
extern __attribute__((dllexport)) Uint16 SDL_ReadBE16(SDL_RWops *src);
extern __attribute__((dllexport)) Uint32 SDL_ReadLE32(SDL_RWops *src);
extern __attribute__((dllexport)) Uint32 SDL_ReadBE32(SDL_RWops *src);
extern __attribute__((dllexport)) Uint64 SDL_ReadLE64(SDL_RWops *src);
extern __attribute__((dllexport)) Uint64 SDL_ReadBE64(SDL_RWops *src);


extern __attribute__((dllexport)) int SDL_WriteLE16(SDL_RWops *dst, Uint16 value);
extern __attribute__((dllexport)) int SDL_WriteBE16(SDL_RWops *dst, Uint16 value);
extern __attribute__((dllexport)) int SDL_WriteLE32(SDL_RWops *dst, Uint32 value);
extern __attribute__((dllexport)) int SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
extern __attribute__((dllexport)) int SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
extern __attribute__((dllexport)) int SDL_WriteBE64(SDL_RWops *dst, Uint64 value);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 143 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_rwops.h" 2
# 34 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 36 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2


extern "C" {



typedef struct SDL_AudioSpec {
 int freq;
 Uint16 format;
 Uint8 channels;
 Uint8 silence;
 Uint16 samples;
 Uint16 padding;
 Uint32 size;






 void ( *callback)(void *userdata, Uint8 *stream, int len);
 void *userdata;
} SDL_AudioSpec;
# 81 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
typedef struct SDL_AudioCVT {
 int needed;
 Uint16 src_format;
 Uint16 dst_format;
 double rate_incr;
 Uint8 *buf;
 int len;
 int len_cvt;
 int len_mult;
 double len_ratio;
 void ( *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
 int filter_index;
} SDL_AudioCVT;
# 102 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) int SDL_AudioInit(const char *driver_name);
extern __attribute__((dllexport)) void SDL_AudioQuit(void);





extern __attribute__((dllexport)) char * SDL_AudioDriverName(char *namebuf, int maxlen);
# 152 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);




typedef enum {
 SDL_AUDIO_STOPPED = 0,
 SDL_AUDIO_PLAYING,
 SDL_AUDIO_PAUSED
} SDL_audiostatus;
extern __attribute__((dllexport)) SDL_audiostatus SDL_GetAudioStatus(void);
# 171 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) void SDL_PauseAudio(int pause_on);
# 190 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
# 199 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) void SDL_FreeWAV(Uint8 *audio_buf);
# 208 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
  Uint16 src_format, Uint8 src_channels, int src_rate,
  Uint16 dst_format, Uint8 dst_channels, int dst_rate);
# 220 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) int SDL_ConvertAudio(SDL_AudioCVT *cvt);
# 230 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h"
extern __attribute__((dllexport)) void SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);







extern __attribute__((dllexport)) void SDL_LockAudio(void);
extern __attribute__((dllexport)) void SDL_UnlockAudio(void);




extern __attribute__((dllexport)) void SDL_CloseAudio(void);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 252 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_audio.h" 2
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h" 2


extern "C" {
# 50 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h"
typedef enum {
 CD_TRAYEMPTY,
 CD_STOPPED,
 CD_PLAYING,
 CD_PAUSED,
 CD_ERROR = -1
} CDstatus;




typedef struct SDL_CDtrack {
 Uint8 id;
 Uint8 type;
 Uint16 unused;
 Uint32 length;
 Uint32 offset;
} SDL_CDtrack;


typedef struct SDL_CD {
 int id;
 CDstatus status;


 int numtracks;
 int cur_track;
 int cur_frame;
 SDL_CDtrack track[99 +1];
} SDL_CD;
# 98 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h"
extern __attribute__((dllexport)) int SDL_CDNumDrives(void);







extern __attribute__((dllexport)) const char * SDL_CDName(int drive);







extern __attribute__((dllexport)) SDL_CD * SDL_CDOpen(int drive);





extern __attribute__((dllexport)) CDstatus SDL_CDStatus(SDL_CD *cdrom);
# 141 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h"
extern __attribute__((dllexport)) int SDL_CDPlayTracks(SDL_CD *cdrom,
  int start_track, int start_frame, int ntracks, int nframes);




extern __attribute__((dllexport)) int SDL_CDPlay(SDL_CD *cdrom, int start, int length);


extern __attribute__((dllexport)) int SDL_CDPause(SDL_CD *cdrom);


extern __attribute__((dllexport)) int SDL_CDResume(SDL_CD *cdrom);


extern __attribute__((dllexport)) int SDL_CDStop(SDL_CD *cdrom);


extern __attribute__((dllexport)) int SDL_CDEject(SDL_CD *cdrom);


extern __attribute__((dllexport)) void SDL_CDClose(SDL_CD *cdrom);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 170 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cdrom.h" 2
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cpuinfo.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cpuinfo.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cpuinfo.h" 2


extern "C" {




extern __attribute__((dllexport)) SDL_bool SDL_HasRDTSC(void);



extern __attribute__((dllexport)) SDL_bool SDL_HasMMX(void);



extern __attribute__((dllexport)) SDL_bool SDL_HasMMXExt(void);



extern __attribute__((dllexport)) SDL_bool SDL_Has3DNow(void);



extern __attribute__((dllexport)) SDL_bool SDL_Has3DNowExt(void);



extern __attribute__((dllexport)) SDL_bool SDL_HasSSE(void);



extern __attribute__((dllexport)) SDL_bool SDL_HasSSE2(void);



extern __attribute__((dllexport)) SDL_bool SDL_HasAltiVec(void);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 74 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_cpuinfo.h" 2
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2


# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 1
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_active.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_active.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_active.h" 2


extern "C" {
# 49 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_active.h"
extern __attribute__((dllexport)) Uint8 SDL_GetAppState(void);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 57 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_active.h" 2
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h" 1
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keysym.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keysym.h"
typedef enum {

 SDLK_UNKNOWN = 0,
 SDLK_FIRST = 0,
 SDLK_BACKSPACE = 8,
 SDLK_TAB = 9,
 SDLK_CLEAR = 12,
 SDLK_RETURN = 13,
 SDLK_PAUSE = 19,
 SDLK_ESCAPE = 27,
 SDLK_SPACE = 32,
 SDLK_EXCLAIM = 33,
 SDLK_QUOTEDBL = 34,
 SDLK_HASH = 35,
 SDLK_DOLLAR = 36,
 SDLK_AMPERSAND = 38,
 SDLK_QUOTE = 39,
 SDLK_LEFTPAREN = 40,
 SDLK_RIGHTPAREN = 41,
 SDLK_ASTERISK = 42,
 SDLK_PLUS = 43,
 SDLK_COMMA = 44,
 SDLK_MINUS = 45,
 SDLK_PERIOD = 46,
 SDLK_SLASH = 47,
 SDLK_0 = 48,
 SDLK_1 = 49,
 SDLK_2 = 50,
 SDLK_3 = 51,
 SDLK_4 = 52,
 SDLK_5 = 53,
 SDLK_6 = 54,
 SDLK_7 = 55,
 SDLK_8 = 56,
 SDLK_9 = 57,
 SDLK_COLON = 58,
 SDLK_SEMICOLON = 59,
 SDLK_LESS = 60,
 SDLK_EQUALS = 61,
 SDLK_GREATER = 62,
 SDLK_QUESTION = 63,
 SDLK_AT = 64,



 SDLK_LEFTBRACKET = 91,
 SDLK_BACKSLASH = 92,
 SDLK_RIGHTBRACKET = 93,
 SDLK_CARET = 94,
 SDLK_UNDERSCORE = 95,
 SDLK_BACKQUOTE = 96,
 SDLK_a = 97,
 SDLK_b = 98,
 SDLK_c = 99,
 SDLK_d = 100,
 SDLK_e = 101,
 SDLK_f = 102,
 SDLK_g = 103,
 SDLK_h = 104,
 SDLK_i = 105,
 SDLK_j = 106,
 SDLK_k = 107,
 SDLK_l = 108,
 SDLK_m = 109,
 SDLK_n = 110,
 SDLK_o = 111,
 SDLK_p = 112,
 SDLK_q = 113,
 SDLK_r = 114,
 SDLK_s = 115,
 SDLK_t = 116,
 SDLK_u = 117,
 SDLK_v = 118,
 SDLK_w = 119,
 SDLK_x = 120,
 SDLK_y = 121,
 SDLK_z = 122,
 SDLK_DELETE = 127,



 SDLK_WORLD_0 = 160,
 SDLK_WORLD_1 = 161,
 SDLK_WORLD_2 = 162,
 SDLK_WORLD_3 = 163,
 SDLK_WORLD_4 = 164,
 SDLK_WORLD_5 = 165,
 SDLK_WORLD_6 = 166,
 SDLK_WORLD_7 = 167,
 SDLK_WORLD_8 = 168,
 SDLK_WORLD_9 = 169,
 SDLK_WORLD_10 = 170,
 SDLK_WORLD_11 = 171,
 SDLK_WORLD_12 = 172,
 SDLK_WORLD_13 = 173,
 SDLK_WORLD_14 = 174,
 SDLK_WORLD_15 = 175,
 SDLK_WORLD_16 = 176,
 SDLK_WORLD_17 = 177,
 SDLK_WORLD_18 = 178,
 SDLK_WORLD_19 = 179,
 SDLK_WORLD_20 = 180,
 SDLK_WORLD_21 = 181,
 SDLK_WORLD_22 = 182,
 SDLK_WORLD_23 = 183,
 SDLK_WORLD_24 = 184,
 SDLK_WORLD_25 = 185,
 SDLK_WORLD_26 = 186,
 SDLK_WORLD_27 = 187,
 SDLK_WORLD_28 = 188,
 SDLK_WORLD_29 = 189,
 SDLK_WORLD_30 = 190,
 SDLK_WORLD_31 = 191,
 SDLK_WORLD_32 = 192,
 SDLK_WORLD_33 = 193,
 SDLK_WORLD_34 = 194,
 SDLK_WORLD_35 = 195,
 SDLK_WORLD_36 = 196,
 SDLK_WORLD_37 = 197,
 SDLK_WORLD_38 = 198,
 SDLK_WORLD_39 = 199,
 SDLK_WORLD_40 = 200,
 SDLK_WORLD_41 = 201,
 SDLK_WORLD_42 = 202,
 SDLK_WORLD_43 = 203,
 SDLK_WORLD_44 = 204,
 SDLK_WORLD_45 = 205,
 SDLK_WORLD_46 = 206,
 SDLK_WORLD_47 = 207,
 SDLK_WORLD_48 = 208,
 SDLK_WORLD_49 = 209,
 SDLK_WORLD_50 = 210,
 SDLK_WORLD_51 = 211,
 SDLK_WORLD_52 = 212,
 SDLK_WORLD_53 = 213,
 SDLK_WORLD_54 = 214,
 SDLK_WORLD_55 = 215,
 SDLK_WORLD_56 = 216,
 SDLK_WORLD_57 = 217,
 SDLK_WORLD_58 = 218,
 SDLK_WORLD_59 = 219,
 SDLK_WORLD_60 = 220,
 SDLK_WORLD_61 = 221,
 SDLK_WORLD_62 = 222,
 SDLK_WORLD_63 = 223,
 SDLK_WORLD_64 = 224,
 SDLK_WORLD_65 = 225,
 SDLK_WORLD_66 = 226,
 SDLK_WORLD_67 = 227,
 SDLK_WORLD_68 = 228,
 SDLK_WORLD_69 = 229,
 SDLK_WORLD_70 = 230,
 SDLK_WORLD_71 = 231,
 SDLK_WORLD_72 = 232,
 SDLK_WORLD_73 = 233,
 SDLK_WORLD_74 = 234,
 SDLK_WORLD_75 = 235,
 SDLK_WORLD_76 = 236,
 SDLK_WORLD_77 = 237,
 SDLK_WORLD_78 = 238,
 SDLK_WORLD_79 = 239,
 SDLK_WORLD_80 = 240,
 SDLK_WORLD_81 = 241,
 SDLK_WORLD_82 = 242,
 SDLK_WORLD_83 = 243,
 SDLK_WORLD_84 = 244,
 SDLK_WORLD_85 = 245,
 SDLK_WORLD_86 = 246,
 SDLK_WORLD_87 = 247,
 SDLK_WORLD_88 = 248,
 SDLK_WORLD_89 = 249,
 SDLK_WORLD_90 = 250,
 SDLK_WORLD_91 = 251,
 SDLK_WORLD_92 = 252,
 SDLK_WORLD_93 = 253,
 SDLK_WORLD_94 = 254,
 SDLK_WORLD_95 = 255,


 SDLK_KP0 = 256,
 SDLK_KP1 = 257,
 SDLK_KP2 = 258,
 SDLK_KP3 = 259,
 SDLK_KP4 = 260,
 SDLK_KP5 = 261,
 SDLK_KP6 = 262,
 SDLK_KP7 = 263,
 SDLK_KP8 = 264,
 SDLK_KP9 = 265,
 SDLK_KP_PERIOD = 266,
 SDLK_KP_DIVIDE = 267,
 SDLK_KP_MULTIPLY = 268,
 SDLK_KP_MINUS = 269,
 SDLK_KP_PLUS = 270,
 SDLK_KP_ENTER = 271,
 SDLK_KP_EQUALS = 272,


 SDLK_UP = 273,
 SDLK_DOWN = 274,
 SDLK_RIGHT = 275,
 SDLK_LEFT = 276,
 SDLK_INSERT = 277,
 SDLK_HOME = 278,
 SDLK_END = 279,
 SDLK_PAGEUP = 280,
 SDLK_PAGEDOWN = 281,


 SDLK_F1 = 282,
 SDLK_F2 = 283,
 SDLK_F3 = 284,
 SDLK_F4 = 285,
 SDLK_F5 = 286,
 SDLK_F6 = 287,
 SDLK_F7 = 288,
 SDLK_F8 = 289,
 SDLK_F9 = 290,
 SDLK_F10 = 291,
 SDLK_F11 = 292,
 SDLK_F12 = 293,
 SDLK_F13 = 294,
 SDLK_F14 = 295,
 SDLK_F15 = 296,


 SDLK_NUMLOCK = 300,
 SDLK_CAPSLOCK = 301,
 SDLK_SCROLLOCK = 302,
 SDLK_RSHIFT = 303,
 SDLK_LSHIFT = 304,
 SDLK_RCTRL = 305,
 SDLK_LCTRL = 306,
 SDLK_RALT = 307,
 SDLK_LALT = 308,
 SDLK_RMETA = 309,
 SDLK_LMETA = 310,
 SDLK_LSUPER = 311,
 SDLK_RSUPER = 312,
 SDLK_MODE = 313,
 SDLK_COMPOSE = 314,


 SDLK_HELP = 315,
 SDLK_PRINT = 316,
 SDLK_SYSREQ = 317,
 SDLK_BREAK = 318,
 SDLK_MENU = 319,
 SDLK_POWER = 320,
 SDLK_EURO = 321,
 SDLK_UNDO = 322,



 SDLK_LAST
} SDLKey;


typedef enum {
 KMOD_NONE = 0x0000,
 KMOD_LSHIFT= 0x0001,
 KMOD_RSHIFT= 0x0002,
 KMOD_LCTRL = 0x0040,
 KMOD_RCTRL = 0x0080,
 KMOD_LALT = 0x0100,
 KMOD_RALT = 0x0200,
 KMOD_LMETA = 0x0400,
 KMOD_RMETA = 0x0800,
 KMOD_NUM = 0x1000,
 KMOD_CAPS = 0x2000,
 KMOD_MODE = 0x4000,
 KMOD_RESERVED = 0x8000
} SDLMod;
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h" 2


extern "C" {
# 54 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h"
typedef struct SDL_keysym {
 Uint8 scancode;
 SDLKey sym;
 SDLMod mod;
 Uint16 unicode;
} SDL_keysym;
# 73 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h"
extern __attribute__((dllexport)) int SDL_EnableUNICODE(int enable);
# 86 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h"
extern __attribute__((dllexport)) int SDL_EnableKeyRepeat(int delay, int interval);
extern __attribute__((dllexport)) void SDL_GetKeyRepeat(int *delay, int *interval);
# 96 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h"
extern __attribute__((dllexport)) Uint8 * SDL_GetKeyState(int *numkeys);




extern __attribute__((dllexport)) SDLMod SDL_GetModState(void);





extern __attribute__((dllexport)) void SDL_SetModState(SDLMod modstate);




extern __attribute__((dllexport)) char * SDL_GetKeyName(SDLKey key);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 120 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_keyboard.h" 2
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h" 1
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h" 2


extern "C" {







typedef struct SDL_Rect {
 Sint16 x, y;
 Uint16 w, h;
} SDL_Rect;

typedef struct SDL_Color {
 Uint8 r;
 Uint8 g;
 Uint8 b;
 Uint8 unused;
} SDL_Color;


typedef struct SDL_Palette {
 int ncolors;
 SDL_Color *colors;
} SDL_Palette;


typedef struct SDL_PixelFormat {
 SDL_Palette *palette;
 Uint8 BitsPerPixel;
 Uint8 BytesPerPixel;
 Uint8 Rloss;
 Uint8 Gloss;
 Uint8 Bloss;
 Uint8 Aloss;
 Uint8 Rshift;
 Uint8 Gshift;
 Uint8 Bshift;
 Uint8 Ashift;
 Uint32 Rmask;
 Uint32 Gmask;
 Uint32 Bmask;
 Uint32 Amask;


 Uint32 colorkey;

 Uint8 alpha;
} SDL_PixelFormat;




typedef struct SDL_Surface {
 Uint32 flags;
 SDL_PixelFormat *format;
 int w, h;
 Uint16 pitch;
 void *pixels;
 int offset;


 struct private_hwdata *hwdata;


 SDL_Rect clip_rect;
 Uint32 unused1;


 Uint32 locked;


 struct SDL_BlitMap *map;


 unsigned int format_version;


 int refcount;
} SDL_Surface;
# 144 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
   struct SDL_Surface *dst, SDL_Rect *dstrect);



typedef struct SDL_VideoInfo {
 Uint32 hw_available :1;
 Uint32 wm_available :1;
 Uint32 UnusedBits1 :6;
 Uint32 UnusedBits2 :1;
 Uint32 blit_hw :1;
 Uint32 blit_hw_CC :1;
 Uint32 blit_hw_A :1;
 Uint32 blit_sw :1;
 Uint32 blit_sw_CC :1;
 Uint32 blit_sw_A :1;
 Uint32 blit_fill :1;
 Uint32 UnusedBits3 :16;
 Uint32 video_mem;
 SDL_PixelFormat *vfmt;
 int current_w;
 int current_h;
} SDL_VideoInfo;
# 183 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
typedef struct SDL_Overlay {
 Uint32 format;
 int w, h;
 int planes;
 Uint16 *pitches;
 Uint8 **pixels;


 struct private_yuvhwfuncs *hwfuncs;
 struct private_yuvhwdata *hwdata;


 Uint32 hw_overlay :1;
 Uint32 UnusedBits :31;
} SDL_Overlay;



typedef enum {
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_SWAP_CONTROL
} SDL_GLattr;
# 240 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_VideoInit(const char *driver_name, Uint32 flags);
extern __attribute__((dllexport)) void SDL_VideoQuit(void);





extern __attribute__((dllexport)) char * SDL_VideoDriverName(char *namebuf, int maxlen);







extern __attribute__((dllexport)) SDL_Surface * SDL_GetVideoSurface(void);







extern __attribute__((dllexport)) const SDL_VideoInfo * SDL_GetVideoInfo(void);
# 276 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);
# 287 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Rect ** SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);
# 347 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Surface * SDL_SetVideoMode
   (int width, int height, int bpp, Uint32 flags);







extern __attribute__((dllexport)) void SDL_UpdateRects
  (SDL_Surface *screen, int numrects, SDL_Rect *rects);
extern __attribute__((dllexport)) void SDL_UpdateRect
  (SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h);
# 371 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_Flip(SDL_Surface *screen);
# 381 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetGamma(float red, float green, float blue);
# 395 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue);
# 406 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue);
# 423 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetColors(SDL_Surface *surface,
   SDL_Color *colors, int firstcolor, int ncolors);
# 442 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetPalette(SDL_Surface *surface, int flags,
       SDL_Color *colors, int firstcolor,
       int ncolors);




extern __attribute__((dllexport)) Uint32 SDL_MapRGB
(const SDL_PixelFormat * const format,
 const Uint8 r, const Uint8 g, const Uint8 b);




extern __attribute__((dllexport)) Uint32 SDL_MapRGBA
(const SDL_PixelFormat * const format,
 const Uint8 r, const Uint8 g, const Uint8 b, const Uint8 a);




extern __attribute__((dllexport)) void SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt,
    Uint8 *r, Uint8 *g, Uint8 *b);




extern __attribute__((dllexport)) void SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt,
     Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
# 507 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Surface * SDL_CreateRGBSurface
   (Uint32 flags, int width, int height, int depth,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern __attribute__((dllexport)) SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
   int width, int height, int depth, int pitch,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern __attribute__((dllexport)) void SDL_FreeSurface(SDL_Surface *surface);
# 533 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_LockSurface(SDL_Surface *surface);
extern __attribute__((dllexport)) void SDL_UnlockSurface(SDL_Surface *surface);







extern __attribute__((dllexport)) SDL_Surface * SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);
# 552 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SaveBMP_RW
  (SDL_Surface *surface, SDL_RWops *dst, int freedst);
# 568 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetColorKey
   (SDL_Surface *surface, Uint32 flag, Uint32 key);
# 586 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
# 600 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect);






extern __attribute__((dllexport)) void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);
# 621 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Surface * SDL_ConvertSurface
   (SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags);
# 698 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_UpperBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);



extern __attribute__((dllexport)) int SDL_LowerBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);
# 717 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_FillRect
  (SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
# 731 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Surface * SDL_DisplayFormat(SDL_Surface *surface);
# 745 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Surface * SDL_DisplayFormatAlpha(SDL_Surface *surface);
# 757 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) SDL_Overlay * SDL_CreateYUVOverlay(int width, int height,
    Uint32 format, SDL_Surface *display);


extern __attribute__((dllexport)) int SDL_LockYUVOverlay(SDL_Overlay *overlay);
extern __attribute__((dllexport)) void SDL_UnlockYUVOverlay(SDL_Overlay *overlay);







extern __attribute__((dllexport)) int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);


extern __attribute__((dllexport)) void SDL_FreeYUVOverlay(SDL_Overlay *overlay);
# 786 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_GL_LoadLibrary(const char *path);




extern __attribute__((dllexport)) void * SDL_GL_GetProcAddress(const char* proc);




extern __attribute__((dllexport)) int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
# 807 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_GL_GetAttribute(SDL_GLattr attr, int* value);




extern __attribute__((dllexport)) void SDL_GL_SwapBuffers(void);





extern __attribute__((dllexport)) void SDL_GL_UpdateRects(int numrects, SDL_Rect* rects);
extern __attribute__((dllexport)) void SDL_GL_Lock(void);
extern __attribute__((dllexport)) void SDL_GL_Unlock(void);
# 829 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) void SDL_WM_SetCaption(const char *title, const char *icon);
extern __attribute__((dllexport)) void SDL_WM_GetCaption(char **title, char **icon);







extern __attribute__((dllexport)) void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);






extern __attribute__((dllexport)) int SDL_WM_IconifyWindow(void);
# 862 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h"
extern __attribute__((dllexport)) int SDL_WM_ToggleFullScreen(SDL_Surface *surface);





typedef enum {
 SDL_GRAB_QUERY = -1,
 SDL_GRAB_OFF = 0,
 SDL_GRAB_ON = 1,
 SDL_GRAB_FULLSCREEN
} SDL_GrabMode;





extern __attribute__((dllexport)) SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode);


extern __attribute__((dllexport)) int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                                    SDL_Surface *dst, SDL_Rect *dstrect);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 890 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_video.h" 2
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h" 2


extern "C" {


typedef struct WMcursor WMcursor;
typedef struct SDL_Cursor {
 SDL_Rect area;
 Sint16 hot_x, hot_y;
 Uint8 *data;
 Uint8 *mask;
 Uint8 *save[2];
 WMcursor *wm_cursor;
} SDL_Cursor;
# 55 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h"
extern __attribute__((dllexport)) Uint8 SDL_GetMouseState(int *x, int *y);







extern __attribute__((dllexport)) Uint8 SDL_GetRelativeMouseState(int *x, int *y);




extern __attribute__((dllexport)) void SDL_WarpMouse(Uint16 x, Uint16 y);
# 83 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h"
extern __attribute__((dllexport)) SDL_Cursor * SDL_CreateCursor
  (Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);






extern __attribute__((dllexport)) void SDL_SetCursor(SDL_Cursor *cursor);




extern __attribute__((dllexport)) SDL_Cursor * SDL_GetCursor(void);




extern __attribute__((dllexport)) void SDL_FreeCursor(SDL_Cursor *cursor);
# 110 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h"
extern __attribute__((dllexport)) int SDL_ShowCursor(int toggle);
# 132 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h"
}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 135 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_mouse.h" 2
# 33 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h" 2


extern "C" {
# 43 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h"
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;






extern __attribute__((dllexport)) int SDL_NumJoysticks(void);






extern __attribute__((dllexport)) const char * SDL_JoystickName(int device_index);
# 67 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h"
extern __attribute__((dllexport)) SDL_Joystick * SDL_JoystickOpen(int device_index);




extern __attribute__((dllexport)) int SDL_JoystickOpened(int device_index);




extern __attribute__((dllexport)) int SDL_JoystickIndex(SDL_Joystick *joystick);




extern __attribute__((dllexport)) int SDL_JoystickNumAxes(SDL_Joystick *joystick);






extern __attribute__((dllexport)) int SDL_JoystickNumBalls(SDL_Joystick *joystick);




extern __attribute__((dllexport)) int SDL_JoystickNumHats(SDL_Joystick *joystick);




extern __attribute__((dllexport)) int SDL_JoystickNumButtons(SDL_Joystick *joystick);






extern __attribute__((dllexport)) void SDL_JoystickUpdate(void);
# 115 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h"
extern __attribute__((dllexport)) int SDL_JoystickEventState(int state);






extern __attribute__((dllexport)) Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
# 140 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h"
extern __attribute__((dllexport)) Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);






extern __attribute__((dllexport)) int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);





extern __attribute__((dllexport)) Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);




extern __attribute__((dllexport)) void SDL_JoystickClose(SDL_Joystick *joystick);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 166 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_joystick.h" 2
# 34 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_quit.h" 1
# 35 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 37 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2


extern "C" {







typedef enum {
       SDL_NOEVENT = 0,
       SDL_ACTIVEEVENT,
       SDL_KEYDOWN,
       SDL_KEYUP,
       SDL_MOUSEMOTION,
       SDL_MOUSEBUTTONDOWN,
       SDL_MOUSEBUTTONUP,
       SDL_JOYAXISMOTION,
       SDL_JOYBALLMOTION,
       SDL_JOYHATMOTION,
       SDL_JOYBUTTONDOWN,
       SDL_JOYBUTTONUP,
       SDL_QUIT,
       SDL_SYSWMEVENT,
       SDL_EVENT_RESERVEDA,
       SDL_EVENT_RESERVEDB,
       SDL_VIDEORESIZE,
       SDL_VIDEOEXPOSE,
       SDL_EVENT_RESERVED2,
       SDL_EVENT_RESERVED3,
       SDL_EVENT_RESERVED4,
       SDL_EVENT_RESERVED5,
       SDL_EVENT_RESERVED6,
       SDL_EVENT_RESERVED7,

       SDL_USEREVENT = 24,



       SDL_NUMEVENTS = 32
} SDL_EventType;



typedef enum {
 SDL_ACTIVEEVENTMASK = (1<<(SDL_ACTIVEEVENT)),
 SDL_KEYDOWNMASK = (1<<(SDL_KEYDOWN)),
 SDL_KEYUPMASK = (1<<(SDL_KEYUP)),
 SDL_KEYEVENTMASK = (1<<(SDL_KEYDOWN))|
                           (1<<(SDL_KEYUP)),
 SDL_MOUSEMOTIONMASK = (1<<(SDL_MOUSEMOTION)),
 SDL_MOUSEBUTTONDOWNMASK = (1<<(SDL_MOUSEBUTTONDOWN)),
 SDL_MOUSEBUTTONUPMASK = (1<<(SDL_MOUSEBUTTONUP)),
 SDL_MOUSEEVENTMASK = (1<<(SDL_MOUSEMOTION))|
                           (1<<(SDL_MOUSEBUTTONDOWN))|
                           (1<<(SDL_MOUSEBUTTONUP)),
 SDL_JOYAXISMOTIONMASK = (1<<(SDL_JOYAXISMOTION)),
 SDL_JOYBALLMOTIONMASK = (1<<(SDL_JOYBALLMOTION)),
 SDL_JOYHATMOTIONMASK = (1<<(SDL_JOYHATMOTION)),
 SDL_JOYBUTTONDOWNMASK = (1<<(SDL_JOYBUTTONDOWN)),
 SDL_JOYBUTTONUPMASK = (1<<(SDL_JOYBUTTONUP)),
 SDL_JOYEVENTMASK = (1<<(SDL_JOYAXISMOTION))|
                           (1<<(SDL_JOYBALLMOTION))|
                           (1<<(SDL_JOYHATMOTION))|
                           (1<<(SDL_JOYBUTTONDOWN))|
                           (1<<(SDL_JOYBUTTONUP)),
 SDL_VIDEORESIZEMASK = (1<<(SDL_VIDEORESIZE)),
 SDL_VIDEOEXPOSEMASK = (1<<(SDL_VIDEOEXPOSE)),
 SDL_QUITMASK = (1<<(SDL_QUIT)),
 SDL_SYSWMEVENTMASK = (1<<(SDL_SYSWMEVENT))
} SDL_EventMask ;



typedef struct SDL_ActiveEvent {
 Uint8 type;
 Uint8 gain;
 Uint8 state;
} SDL_ActiveEvent;


typedef struct SDL_KeyboardEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 SDL_keysym keysym;
} SDL_KeyboardEvent;


typedef struct SDL_MouseMotionEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 Uint16 x, y;
 Sint16 xrel;
 Sint16 yrel;
} SDL_MouseMotionEvent;


typedef struct SDL_MouseButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
 Uint16 x, y;
} SDL_MouseButtonEvent;


typedef struct SDL_JoyAxisEvent {
 Uint8 type;
 Uint8 which;
 Uint8 axis;
 Sint16 value;
} SDL_JoyAxisEvent;


typedef struct SDL_JoyBallEvent {
 Uint8 type;
 Uint8 which;
 Uint8 ball;
 Sint16 xrel;
 Sint16 yrel;
} SDL_JoyBallEvent;


typedef struct SDL_JoyHatEvent {
 Uint8 type;
 Uint8 which;
 Uint8 hat;
 Uint8 value;





} SDL_JoyHatEvent;


typedef struct SDL_JoyButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
} SDL_JoyButtonEvent;





typedef struct SDL_ResizeEvent {
 Uint8 type;
 int w;
 int h;
} SDL_ResizeEvent;


typedef struct SDL_ExposeEvent {
 Uint8 type;
} SDL_ExposeEvent;


typedef struct SDL_QuitEvent {
 Uint8 type;
} SDL_QuitEvent;


typedef struct SDL_UserEvent {
 Uint8 type;
 int code;
 void *data1;
 void *data2;
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
typedef struct SDL_SysWMEvent {
 Uint8 type;
 SDL_SysWMmsg *msg;
} SDL_SysWMEvent;


typedef union SDL_Event {
 Uint8 type;
 SDL_ActiveEvent active;
 SDL_KeyboardEvent key;
 SDL_MouseMotionEvent motion;
 SDL_MouseButtonEvent button;
 SDL_JoyAxisEvent jaxis;
 SDL_JoyBallEvent jball;
 SDL_JoyHatEvent jhat;
 SDL_JoyButtonEvent jbutton;
 SDL_ResizeEvent resize;
 SDL_ExposeEvent expose;
 SDL_QuitEvent quit;
 SDL_UserEvent user;
 SDL_SysWMEvent syswm;
} SDL_Event;
# 244 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h"
extern __attribute__((dllexport)) void SDL_PumpEvents(void);
# 258 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h"
typedef enum {
 SDL_ADDEVENT,
 SDL_PEEKEVENT,
 SDL_GETEVENT
} SDL_eventaction;

extern __attribute__((dllexport)) int SDL_PeepEvents(SDL_Event *events, int numevents,
    SDL_eventaction action, Uint32 mask);





extern __attribute__((dllexport)) int SDL_PollEvent(SDL_Event *event);





extern __attribute__((dllexport)) int SDL_WaitEvent(SDL_Event *event);





extern __attribute__((dllexport)) int SDL_PushEvent(SDL_Event *event);







typedef int ( *SDL_EventFilter)(const SDL_Event *event);
# 308 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h"
extern __attribute__((dllexport)) void SDL_SetEventFilter(SDL_EventFilter filter);





extern __attribute__((dllexport)) SDL_EventFilter SDL_GetEventFilter(void);
# 328 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h"
extern __attribute__((dllexport)) Uint8 SDL_EventState(Uint8 type, int state);




}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 336 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_events.h" 2
# 36 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_loadso.h" 1
# 47 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_loadso.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 48 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_loadso.h" 2


extern "C" {






extern __attribute__((dllexport)) void * SDL_LoadObject(const char *sofile);





extern __attribute__((dllexport)) void * SDL_LoadFunction(void *handle, const char *name);


extern __attribute__((dllexport)) void SDL_UnloadObject(void *handle);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 73 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_loadso.h" 2
# 37 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2



# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 32 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h" 2


extern "C" {
# 46 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h"
extern __attribute__((dllexport)) Uint32 SDL_GetTicks(void);


extern __attribute__((dllexport)) void SDL_Delay(Uint32 ms);


typedef Uint32 ( *SDL_TimerCallback)(Uint32 interval);
# 82 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h"
extern __attribute__((dllexport)) int SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);
# 94 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h"
typedef Uint32 ( *SDL_NewTimerCallback)(Uint32 interval, void *param);


typedef struct _SDL_TimerID *SDL_TimerID;




extern __attribute__((dllexport)) SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param);




extern __attribute__((dllexport)) SDL_bool SDL_RemoveTimer(SDL_TimerID t);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 114 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_timer.h" 2
# 41 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h" 1
# 30 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h"
# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 31 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h" 2


extern "C" {
# 42 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h"
typedef struct SDL_version {
 Uint8 major;
 Uint8 minor;
 Uint8 patch;
} SDL_version;
# 77 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h"
extern __attribute__((dllexport)) const SDL_version * SDL_Linked_Version(void);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 84 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL_version.h" 2
# 43 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/begin_code.h" 1
# 45 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2


extern "C" {
# 69 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h"
extern __attribute__((dllexport)) int SDL_Init(Uint32 flags);


extern __attribute__((dllexport)) int SDL_InitSubSystem(Uint32 flags);


extern __attribute__((dllexport)) void SDL_QuitSubSystem(Uint32 flags);





extern __attribute__((dllexport)) Uint32 SDL_WasInit(Uint32 flags);




extern __attribute__((dllexport)) void SDL_Quit(void);



}

# 1 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/close_code.h" 1
# 93 "C:/Enrique/Programas/SDL/SDL-devel-1.2.12-VC8/SDL-1.2.12/include/SDL.h" 2
# 7 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.h" 2
# 15 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.h"
namespace DRTE
{
class DRTEPresentation
{
private:


 int width;
 int height;
 SDL_Surface* surface;
public:
 DRTEPresentation(SDL_Surface* surface);
 ~DRTEPresentation();
 int PutPixel(int x, int y, int color);
 int CreateBuffer(int width, int height);
 int DumpToScreen();
 int Clear(int color);
 int CopyMemoryToBuffer(int width, int height, int *mem);


};
}
# 2 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp" 2

using namespace DRTE;

DRTEPresentation::DRTEPresentation(SDL_Surface* surface)
{


 this->surface=surface;
}

DRTEPresentation::~DRTEPresentation()
{




}

int DRTEPresentation::PutPixel(int x, int y, int color)
{

  return 1;

 return 0;
}

int DRTEPresentation::CreateBuffer(int buffer_width, int buffer_height)
{
# 38 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp"
 return 0;
}

int DRTEPresentation::DumpToScreen()
{





 return 0;
}

int DRTEPresentation::Clear(int color)
{
# 61 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp"
 return 0;
}

int DRTEPresentation::CopyMemoryToBuffer(int width, int height, int *mem)
{
# 80 "C:\\Enrique\\Programas\\MyApps\\DRTEClient\\DRTEPresentation.cpp"
 SDL_LockSurface(surface);

 memcpy(surface->pixels,mem,width*height*3);

 SDL_UnlockSurface(surface);

 return 0;
}
